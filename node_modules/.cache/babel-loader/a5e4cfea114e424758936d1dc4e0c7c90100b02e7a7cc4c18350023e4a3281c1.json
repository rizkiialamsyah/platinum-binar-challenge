{"ast":null,"code":"import { Entity } from \"./Entity\";\nimport { Color } from \"./Color\";\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\nexport class ColorSet extends Entity {\n  //protected _currentPass: number = 0;\n  _afterNew() {\n    // Applying themes because color set will not have parent\n    super._afterNewApplyThemes();\n    this._dirty[\"colors\"] = false;\n  }\n  _beforeChanged() {\n    if (this.isDirty(\"colors\")) {\n      this.reset();\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  generateColors() {\n    this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\n    const pass = this.getPrivate(\"currentPass\");\n    const colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n    if (!this.getPrivate(\"numColors\")) {\n      this.setPrivate(\"numColors\", colors.length);\n    }\n    //const len = colors.length;\n    const len = this.getPrivate(\"numColors\");\n    //const start = len - this.getPrivate(\"numColors\")!;\n    const start = 0;\n    const passOptions = this.get(\"passOptions\");\n    const reuse = this.get(\"reuse\");\n    for (let i = start; i < len; i++) {\n      if (reuse) {\n        colors.push(colors[i]);\n      } else {\n        const hsl = colors[i].toHSL();\n        let h = hsl.h + (passOptions.hue || 0) * pass;\n        while (h > 1) h -= 1;\n        let s = hsl.s + (passOptions.saturation || 0) * pass;\n        //if (s > 1) s -= Math.floor(s);\n        if (s > 1) s = 1;\n        if (s < 0) s = 0;\n        let l = hsl.l + (passOptions.lightness || 0) * pass;\n        //if (l > 1) l -= Math.floor(l);\n        while (l > 1) l -= 1;\n        colors.push(Color.fromHSL(h, s, l));\n      }\n    }\n  }\n  /**\r\n   * Returns a [[Color]] at specific index.\r\n   *\r\n   * If there's no color at this index, a new color is generated.\r\n   *\r\n   * @param   index  Index\r\n   * @return         Color\r\n   */\n  getIndex(index) {\n    const colors = this.get(\"colors\", []);\n    const saturation = this.get(\"saturation\");\n    if (index >= colors.length) {\n      this.generateColors();\n      return this.getIndex(index);\n    }\n    return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\n  }\n  /**\r\n   * Returns next [[Color]] in the list.\r\n   *\r\n   * If the list is out of colors, new ones are generated dynamically.\r\n   */\n  next() {\n    let currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n    this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n    return this.getIndex(currentStep);\n  }\n  /**\r\n   * Resets counter to the start of the list, so the next call for `next()` will\r\n   * return the first color.\r\n   */\n  reset() {\n    this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n    this.setPrivate(\"currentPass\", 0);\n  }\n}\nObject.defineProperty(ColorSet, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"ColorSet\"\n});\nObject.defineProperty(ColorSet, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([ColorSet.className])\n});","map":{"version":3,"names":["Entity","Color","ColorSet","_afterNew","_afterNewApplyThemes","_dirty","_beforeChanged","isDirty","reset","generateColors","setPrivate","getPrivate","pass","colors","get","fromHex","length","len","start","passOptions","reuse","i","push","hsl","toHSL","h","hue","s","saturation","l","lightness","fromHSL","getIndex","index","saturate","next","currentStep","Object","defineProperty","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\util\\ColorSet.ts"],"sourcesContent":["import { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\";\nimport { Color } from \"./Color\";\n\n\nexport interface IColorSetSettings extends IEntitySettings {\n\n\t/**\n\t * List of colors in the set.\n\t */\n\tcolors?: Color[];\n\n\t/**\n\t * A step size when using `next()`.\n\t *\n\t * E.g. setting to `2` will make it return every second color in the list.\n\t *\n\t * @default 1\n\t */\n\tstep?: number;\n\n\t/**\n\t * Start iterating colors from specific index.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * If set to `true`, color set will reuse existing colors from the list\n\t * inestead of generating new ones.\n\t *\n\t * @default false\n\t */\n\treuse?: boolean;\n\n\t/**\n\t * A base color to generate new colors from if `colors` is not specified.\n\t * @type {[type]}\n\t */\n\tbaseColor?: Color;\n\n\t/**\n\t * A set of tranformation to apply to base list of colors when the set runs\n\t * out of colors and generates additional ones.\n\t */\n\tpassOptions?: IColorSetStepOptions;\n\n\t/**\n\t * If set, each returned color will be applied saturation.\n\t */\n\tsaturation?: number;\n\n\t// count?: number;\n}\n\nexport interface IColorSetPrivate extends IEntityPrivate {\n\n\tcurrentStep?: number;\n\tcurrentPass?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tnumColors?: number;\n\n}\n\nexport interface IColorSetStepOptions {\n\n\t/**\n\t * Value to add to \"hue\".\n\t */\n\thue?: number;\n\n\t/**\n\t * Value to add to \"saturation\".\n\t */\n\tsaturation?: number;\n\n\t/**\n\t * Value to add to \"lightness\".\n\t */\n\tlightness?: number;\n\n}\n\n\n/**\n * An object which holds list of colors and can generate new ones.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\n */\nexport class ColorSet extends Entity {\n\tpublic static className: string = \"ColorSet\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([ColorSet.className]);\n\n\tdeclare public _settings: IColorSetSettings;\n\tdeclare public _privateSettings: IColorSetPrivate;\n\n\t//protected _currentPass: number = 0;\n\n\tprotected _afterNew() {\n\t\t// Applying themes because color set will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t\tthis._dirty[\"colors\"] = false;\n\t}\n\n\tpublic _beforeChanged(): void {\n\t\tif (this.isDirty(\"colors\")) {\n\t\t\tthis.reset();\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic generateColors(): void {\n\t\tthis.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1)\n\t\tconst pass = this.getPrivate(\"currentPass\");\n\t\tconst colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\t\tif (!this.getPrivate(\"numColors\")) {\n\t\t\tthis.setPrivate(\"numColors\", colors.length);\n\t\t}\n\t\t//const len = colors.length;\n\t\tconst len = this.getPrivate(\"numColors\")!;\n\t\t//const start = len - this.getPrivate(\"numColors\")!;\n\t\tconst start = 0;\n\t\tconst passOptions = this.get(\"passOptions\")!;\n\t\tconst reuse = this.get(\"reuse\");\n\t\tfor (let i = start; i < len; i++) {\n\t\t\tif (reuse) {\n\t\t\t\tcolors.push(colors[i])\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst hsl = colors[i]!.toHSL();\n\t\t\t\tlet h = hsl.h + (passOptions.hue || 0) * pass!;\n\t\t\t\twhile (h > 1) h -= 1;\n\n\t\t\t\tlet s = hsl.s + (passOptions.saturation || 0) * pass!;\n\t\t\t\t//if (s > 1) s -= Math.floor(s);\n\t\t\t\tif (s > 1) s = 1;\n\t\t\t\tif (s < 0) s = 0;\n\n\t\t\t\tlet l = hsl.l + (passOptions.lightness || 0) * pass!;\n\t\t\t\t//if (l > 1) l -= Math.floor(l);\n\t\t\t\twhile (l > 1) l -= 1;\n\t\t\t\tcolors.push(Color.fromHSL(h, s, l));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a [[Color]] at specific index.\n\t *\n\t * If there's no color at this index, a new color is generated.\n\t *\n\t * @param   index  Index\n\t * @return         Color\n\t */\n\tpublic getIndex(index: number): Color {\n\t\tconst colors = this.get(\"colors\", []);\n\t\tconst saturation = this.get(\"saturation\");\n\t\tif (index >= colors.length) {\n\t\t\tthis.generateColors();\n\t\t\treturn this.getIndex(index);\n\t\t}\n\n\t\treturn saturation != null ? Color.saturate(colors[index], saturation!) : colors[index];\n\t}\n\n\t/**\n\t * Returns next [[Color]] in the list.\n\t *\n\t * If the list is out of colors, new ones are generated dynamically.\n\t */\n\tpublic next() {\n\t\tlet currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t\tthis.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n\t\treturn this.getIndex(currentStep);\n\t}\n\n\t/**\n\t * Resets counter to the start of the list, so the next call for `next()` will\n\t * return the first color.\n\t */\n\tpublic reset() {\n\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t\tthis.setPrivate(\"currentPass\", 0);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}