{"ast":null,"code":"import { ValueAxis } from \"./ValueAxis\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n/**\r\n * Creates a duration axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\r\n * @important\r\n */\nexport class DurationAxis extends ValueAxis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n    super._afterNew();\n  }\n  _adjustMinMax(min, max, gridCount, strictMode) {\n    let minMaxStep;\n    const durationFormatter = this.getDurationFormatter();\n    const baseUnit = this.get(\"baseUnit\");\n    // we don't allow to go to smaller units, setting so to avoid invalidation\n    this.setRaw(\"maxPrecision\", 0);\n    if (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n      // will fail if 0\n      if (gridCount <= 1) {\n        gridCount = 1;\n      }\n      gridCount = Math.round(gridCount);\n      //let initialMin: number = min;\n      //let initialMax: number = max;\n      let difference = max - min;\n      // in case min and max is the same, use max\n      if (difference === 0) {\n        difference = Math.abs(max);\n      }\n      let step = difference / gridCount;\n      let divisors = [60, 30, 20, 15, 10, 2, 1];\n      let realDivisor = 1;\n      if (baseUnit == \"hour\") {\n        divisors = [24, 12, 6, 4, 2, 1];\n      }\n      for (let divisor of divisors) {\n        if (difference / divisor > gridCount) {\n          realDivisor = divisor;\n          break;\n        }\n      }\n      let count = Math.ceil((max - min) / realDivisor / gridCount);\n      let exponent = Math.log(Math.abs(count)) * Math.LOG10E;\n      let power = Math.pow(10, Math.floor(exponent)) / 10;\n      let reducedCount = count / power;\n      // find closest to divisor\n      let closest = $math.closest(divisors, reducedCount);\n      count = closest * power;\n      step = realDivisor * count;\n      min = Math.floor(min / step) * step;\n      max = Math.ceil(max / step) * step;\n      /*\r\n      causese SO with seconds\r\n      if (strictMode) {\r\n          min -= step;\r\n          if (min < 0 && initialMin >= 0) {\r\n              min = 0;\r\n          }\r\n          max += step;\r\n            if (max > 0 && initialMax <= 0) {\r\n              max = 0;\r\n          }\r\n      }*/\n      minMaxStep = {\n        min: min,\n        max: max,\n        step: step\n      };\n    } else {\n      minMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);\n    }\n    // choose duration formatter based on step\n    this.setPrivateRaw(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n    return minMaxStep;\n  }\n  _formatText(value) {\n    const formatter = this.getDurationFormatter();\n    return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n  }\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  getTooltipText(position) {\n    const formatter = this.getDurationFormatter();\n    const extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n    const decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n    const value = $math.round(this.positionToValue(position), decimals);\n    return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n  }\n}\nObject.defineProperty(DurationAxis, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"DurationAxis\"\n});\nObject.defineProperty(DurationAxis, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: ValueAxis.classNames.concat([DurationAxis.className])\n});","map":{"version":3,"names":["ValueAxis","$utils","$math","DurationAxis","constructor","Object","defineProperty","_afterNew","_settings","themeTags","mergeTags","_adjustMinMax","min","max","gridCount","strictMode","minMaxStep","durationFormatter","getDurationFormatter","baseUnit","get","setRaw","Math","round","difference","abs","step","divisors","realDivisor","divisor","count","ceil","exponent","log","LOG10E","power","pow","floor","reducedCount","closest","setPrivateRaw","getFormat","_formatText","value","formatter","format","getPrivate","getTooltipText","position","extraDecimals","decimals","positionToValue","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\charts\\xy\\axes\\DurationAxis.ts"],"sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\nimport type { TimeUnit } from \"../../../core/util/Time\"\n\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IValueAxisEvents, IMinMaxStep } from \"./ValueAxis\";\n\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n\nexport interface IDurationAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * A base unit (granularity) of data.\n\t *\n\t * Used to indicate what are the base units of your data.\n\t *\n\t * Available options: `\"millisecond\"`, `\"second\"` (default), `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/#Base_unit} for more info\n\t * @default \"second\"\n\t */\n\tbaseUnit?: TimeUnit\n\n}\n\nexport interface IDurationAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDurationAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * A format to used by axis to format its labels.\n\t *\n\t * @readonly\n\t */\n\tdurationFormat: string;\n\n}\n\nexport interface IDurationAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a duration axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\n * @important\n */\nexport class DurationAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DurationAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DurationAxis.className]);\n\n\tdeclare public _settings: IDurationAxisSettings<R>;\n\tdeclare public _privateSettings: IDurationAxisPrivate;\n\tdeclare public _dataItemSettings: IDurationAxisDataItem;\n\tdeclare public _events: IDurationAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, strictMode?: boolean): IMinMaxStep {\n\t\tlet minMaxStep: IMinMaxStep;\n\n\t\tconst durationFormatter = this.getDurationFormatter();\n\t\tconst baseUnit = this.get(\"baseUnit\");\n\t\t// we don't allow to go to smaller units, setting so to avoid invalidation\n\t\tthis.setRaw(\"maxPrecision\", 0);\n\n\t\tif (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n\t\t\t// will fail if 0\n\t\t\tif (gridCount <= 1) {\n\t\t\t\tgridCount = 1;\n\t\t\t}\n\n\t\t\tgridCount = Math.round(gridCount);\n\n\t\t\t//let initialMin: number = min;\n\t\t\t//let initialMax: number = max;\n\n\t\t\tlet difference = max - min;\n\n\t\t\t// in case min and max is the same, use max\n\t\t\tif (difference === 0) {\n\t\t\t\tdifference = Math.abs(max);\n\t\t\t}\n\n\t\t\tlet step = difference / gridCount;\n\n\t\t\tlet divisors = [60, 30, 20, 15, 10, 2, 1];\n\t\t\tlet realDivisor = 1;\n\n\t\t\tif (baseUnit == \"hour\") {\n\t\t\t\tdivisors = [24, 12, 6, 4, 2, 1];\n\t\t\t}\n\n\t\t\tfor (let divisor of divisors) {\n\t\t\t\tif (difference / divisor > gridCount) {\n\t\t\t\t\trealDivisor = divisor;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet count = Math.ceil(((max - min) / realDivisor) / gridCount);\n\n\t\t\tlet exponent: number = Math.log(Math.abs(count)) * Math.LOG10E;\n\t\t\tlet power = Math.pow(10, Math.floor(exponent)) / 10;\n\t\t\tlet reducedCount = count / power;\n\n\t\t\t// find closest to divisor\n\t\t\tlet closest = $math.closest(divisors, reducedCount);\n\t\t\tcount = closest * power;\n\n\t\t\tstep = realDivisor * count;\n\n\t\t\tmin = Math.floor(min / step) * step;\n\t\t\tmax = Math.ceil(max / step) * step;\n\n\t\t\t/*\n\t\t\tcausese SO with seconds\n\t\t\tif (strictMode) {\n\t\t\t\tmin -= step;\n\t\t\t\tif (min < 0 && initialMin >= 0) {\n\t\t\t\t\tmin = 0;\n\t\t\t\t}\n\t\t\t\tmax += step;\n\n\t\t\t\tif (max > 0 && initialMax <= 0) {\n\t\t\t\t\tmax = 0;\n\t\t\t\t}\n\t\t\t}*/\t\t\t\n\t\t\tminMaxStep = { min: min, max: max, step: step };\n\t\t}\n\t\telse {\n\t\t\tminMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);\n\t\t}\n\n\t\t// choose duration formatter based on step\n\t\tthis.setPrivateRaw(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n\n\t\treturn minMaxStep;\n\t}\n\n\tprotected _formatText(value: number) {\n\t\tconst formatter = this.getDurationFormatter();\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\tconst formatter = this.getDurationFormatter();\n\t\tconst extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n\t\tconst decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n\t\tconst value = $math.round(this.positionToValue(position), decimals);\n\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}