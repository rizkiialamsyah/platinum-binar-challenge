{"ast":null,"code":"/** @ignore */ /** */\nimport { BlendMode } from \"./Renderer\";\nimport { Color } from \"../../util/Color\";\nimport { Matrix } from \"../../util/Matrix\";\nimport { Percent, percent } from \"../../util/Percent\";\n//import { Throttler } from \"../../util/Throttler\";\nimport { ArrayDisposer, Disposer, DisposerClass, CounterDisposer, MultiDisposer } from \"../../util/Disposer\";\nimport { TextFormatter } from \"../../util/TextFormatter\";\nimport * as $utils from \"../../util/Utils\";\nimport * as $array from \"../../util/Array\";\nimport * as $object from \"../../util/Object\";\nimport * as $type from \"../../util/Type\";\nimport * as $math from \"../../util/Math\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\n/**\r\n * @ignore\r\n */\nfunction checkArgs(name, actual, expected) {\n  if (actual !== expected) {\n    throw new Error(\"Required \" + expected + \" arguments for \" + name + \" but got \" + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction checkMinArgs(name, actual, expected) {\n  if (actual < expected) {\n    throw new Error(\"Required at least \" + expected + \" arguments for \" + name + \" but got \" + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction checkEvenArgs(name, actual, expected) {\n  checkMinArgs(name, actual, expected);\n  if (actual % expected !== 0) {\n    throw new Error(\"Arguments for \" + name + \" must be in pairs of \" + expected);\n  }\n}\n/**\r\n * @ignore\r\n * This splits the flag so that way 0017 will be processed as 0 0 17\r\n *\r\n * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`\r\n */\nfunction splitArcFlags(args) {\n  for (let i = 0; i < args.length; i += 7) {\n    let index = i + 3;\n    let flag = args[index];\n    if (flag.length > 1) {\n      const a = /^([01])([01])(.*)$/.exec(flag);\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args.splice(index, 0, a[2]);\n        ++index;\n        if (a[3].length > 0) {\n          args[index] = a[3];\n        } else {\n          args.splice(index, 1);\n        }\n      }\n    }\n    ++index;\n    flag = args[index];\n    if (flag.length > 1) {\n      const a = /^([01])(.+)$/.exec(flag);\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args[index] = a[2];\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction assertBinary(value) {\n  if (value === 0 || value === 1) {\n    return value;\n  } else {\n    throw new Error(\"Flag must be 0 or 1\");\n  }\n}\n//  1 -> 0xffffff * (2 / 2)\n//  2 -> 0xffffff * (1 / 2)\n//\n//  3 -> 0xffffff * (3 / 4)\n//  4 -> 0xffffff * (1 / 4)\n//\n//  5 -> 0xffffff * (7 / 8)\n//  6 -> 0xffffff * (5 / 8)\n//  7 -> 0xffffff * (3 / 8)\n//  8 -> 0xffffff * (1 / 8)\n//\n//  9 -> 0xffffff * (15 / 16)\n// 10 -> 0xffffff * (13 / 16)\n// 11 -> 0xffffff * (11 / 16)\n// 12 -> 0xffffff *  (9 / 16)\n// 13 -> 0xffffff *  (7 / 16)\n// 14 -> 0xffffff *  (5 / 16)\n// 15 -> 0xffffff *  (3 / 16)\n// 16 -> 0xffffff *  (1 / 16)\n// @todo remove this old color distribution algo if the new one pans out\n// function distributeIdBAK(id: number): number {\n// \tif (id === 1) {\n// \t\treturn 0x000001;\n// \t} else {\n// \t\t// Finds the closest power of 2\n// \t\tconst base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));\n// \t\t// Translates the id into an odd fraction index\n// \t\tconst index = ((base - id) * 2) + 1;\n// \t\t// TODO is Math.round correct ?\n// \t\treturn Math.round(0xffffff * (index / base));\n// \t}\n// }\n/**\r\n * Function by smeans:\r\n * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/\r\n * @ignore\r\n */\nfunction distributeId(id) {\n  const rgb = [0, 0, 0];\n  for (let i = 0; i < 24; i++) {\n    rgb[i % 3] <<= 1;\n    rgb[i % 3] |= id & 0x01;\n    id >>= 1;\n  }\n  return (rgb[2] | 0) + (rgb[1] << 8) + (rgb[0] << 16);\n}\n/**\r\n * @ignore\r\n */\nfunction eachTargets(hitTarget, f) {\n  for (;;) {\n    if (hitTarget.interactive) {\n      if (!f(hitTarget)) {\n        break;\n      }\n    }\n    if (hitTarget._parent) {\n      hitTarget = hitTarget._parent;\n    } else {\n      break;\n    }\n  }\n}\n// TODO feature detection for mouse/touch/pointer\n/**\r\n * @ignore\r\n */\nfunction onPointerEvent(element, name, f) {\n  return $utils.addEventListener(element, $utils.getRendererEvent(name), event => {\n    const target = $utils.getEventTarget(event);\n    let touches = event.touches;\n    if (touches) {\n      if (touches.length == 0) {\n        touches = event.changedTouches;\n      }\n      f($array.copy(touches), target);\n    } else {\n      f([event], target);\n    }\n  });\n}\n/**\r\n * @ignore\r\n */\nfunction isTainted(image) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  context.drawImage(image, 0, 0, 1, 1);\n  try {\n    context.getImageData(0, 0, 1, 1);\n    return false;\n  } catch (err) {\n    console.warn(\"Image \\\"\" + image.src + \"\\\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors\");\n    return true;\n  }\n}\n/**\r\n * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.\r\n *\r\n * @ignore\r\n */\nfunction clearCanvas(view) {\n  view.width = 0;\n  view.height = 0;\n  view.style.width = \"0px\";\n  view.style.height = \"0px\";\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasPivot {\n  constructor() {\n    Object.defineProperty(this, \"_x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  get x() {\n    return this._x;\n  }\n  get y() {\n    return this._y;\n  }\n  set x(value) {\n    this._x = value;\n  }\n  set y(value) {\n    this._y = value;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasDisplayObject extends DisposerClass {\n  constructor(renderer) {\n    super();\n    Object.defineProperty(this, \"_layer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"mask\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"visible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"exportable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"interactive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"inactive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"wheelable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"cancelTouch\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"isMeasured\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"buttonMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"alpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"compoundAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"angle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"scale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"crisp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"pivot\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new CanvasPivot()\n    });\n    Object.defineProperty(this, \"filter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"cursorOverStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_replacedCursorStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_localMatrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(this, \"_matrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    // TODO can this be replaced with _localMatrix ?\n    Object.defineProperty(this, \"_uMatrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(this, \"_renderer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_parent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_localBounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_bounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_colorId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._renderer = renderer;\n  }\n  _dispose() {\n    this._renderer._removeObject(this);\n    this.getLayer().dirty = true;\n  }\n  getCanvas() {\n    return this.getLayer().view;\n  }\n  getLayer() {\n    let self = this;\n    for (;;) {\n      if (self._layer) {\n        return self._layer;\n      } else if (self._parent) {\n        self = self._parent;\n      } else {\n        return this._renderer.defaultLayer;\n      }\n    }\n  }\n  setLayer(order, margin) {\n    if (order == null) {\n      this._layer = undefined;\n    } else {\n      const visible = true;\n      this._layer = this._renderer.getLayer(order, visible);\n      this._layer.visible = visible;\n      this._layer.margin = margin;\n      if (margin) {\n        $utils.setInteractive(this._layer.view, false);\n      }\n      this._renderer._ghostLayer.setMargin(this._renderer.layers);\n      if (this._parent) {\n        this._parent.registerChildLayer(this._layer);\n      }\n      this._layer.dirty = true;\n      this._renderer.resizeLayer(this._layer);\n      this._renderer.resizeGhost();\n    }\n  }\n  markDirtyLayer() {\n    this.getLayer().dirty = true;\n  }\n  clear() {\n    this.invalidateBounds();\n  }\n  invalidateBounds() {\n    this._localBounds = undefined;\n  }\n  _addBounds(_bounds) {}\n  _getColorId() {\n    if (this._colorId === undefined) {\n      this._colorId = this._renderer.paintId(this);\n    }\n    return this._colorId;\n  }\n  _isInteractive() {\n    return this.inactive == false && (this.interactive || this._renderer._forceInteractive > 0);\n  }\n  _isInteractiveMask() {\n    return this._isInteractive();\n  }\n  contains(child) {\n    for (;;) {\n      if (child === this) {\n        return true;\n      } else if (child._parent) {\n        child = child._parent;\n      } else {\n        return false;\n      }\n    }\n  }\n  toGlobal(point) {\n    return this._matrix.apply(point);\n  }\n  toLocal(point) {\n    return this._matrix.applyInverse(point);\n  }\n  getLocalMatrix() {\n    this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);\n    return this._uMatrix;\n  }\n  getLocalBounds() {\n    if (!this._localBounds) {\n      const bn = 10000000;\n      this._localBounds = {\n        left: bn,\n        top: bn,\n        right: -bn,\n        bottom: -bn\n      };\n      this._addBounds(this._localBounds);\n    }\n    return this._localBounds;\n  }\n  getAdjustedBounds(bounds) {\n    this._setMatrix();\n    const matrix = this.getLocalMatrix();\n    const p0 = matrix.apply({\n      x: bounds.left,\n      y: bounds.top\n    });\n    const p1 = matrix.apply({\n      x: bounds.right,\n      y: bounds.top\n    });\n    const p2 = matrix.apply({\n      x: bounds.right,\n      y: bounds.bottom\n    });\n    const p3 = matrix.apply({\n      x: bounds.left,\n      y: bounds.bottom\n    });\n    return {\n      left: Math.min(p0.x, p1.x, p2.x, p3.x),\n      top: Math.min(p0.y, p1.y, p2.y, p3.y),\n      right: Math.max(p0.x, p1.x, p2.x, p3.x),\n      bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n    };\n  }\n  on(key, callback, context) {\n    if (this.interactive) {\n      return this._renderer._addEvent(this, key, callback, context);\n    } else {\n      return new Disposer(() => {});\n    }\n  }\n  _setMatrix() {\n    // TODO only calculate this if it has actually changed\n    this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y,\n    // Converts degrees to radians\n    this.angle * Math.PI / 180, this.scale);\n    this._matrix.copyFrom(this._localMatrix);\n    if (this._parent) {\n      // TODO only calculate this if it has actually changed\n      this._matrix.prepend(this._parent._matrix);\n    }\n  }\n  _transform(context, resolution) {\n    const m = this._matrix;\n    let tx = m.tx * resolution;\n    let ty = m.ty * resolution;\n    if (this.crisp) {\n      tx = Math.floor(tx) + .5;\n      ty = Math.floor(ty) + .5;\n    }\n    context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, tx, ty);\n  }\n  _transformMargin(context, resolution, margin) {\n    const m = this._matrix;\n    context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);\n  }\n  _transformLayer(context, resolution, layer) {\n    if (layer.margin) {\n      this._transformMargin(context, layer.scale || resolution, layer.margin);\n    } else {\n      this._transform(context, layer.scale || resolution);\n    }\n  }\n  render(parentLayer) {\n    if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {\n      this._setMatrix();\n      const resolution = this._renderer.resolution;\n      const layers = this._renderer.layers;\n      const ghostLayer = this._renderer._ghostLayer;\n      const ghostContext = ghostLayer.context;\n      const mask = this.mask;\n      if (mask) {\n        mask._setMatrix();\n      }\n      // TODO improve this\n      $array.each(layers, layer => {\n        if (layer) {\n          const context = layer.context;\n          context.save();\n          // We must apply the mask before we transform the element\n          if (mask) {\n            mask._transformLayer(context, resolution, layer);\n            mask._runPath(context);\n            context.clip();\n          }\n          context.globalAlpha = this.compoundAlpha * this.alpha;\n          this._transformLayer(context, resolution, layer);\n          if (this.filter) {\n            context.filter = this.filter;\n          }\n        }\n      });\n      ghostContext.save();\n      // We must apply the mask before we transform the element\n      if (mask && this._isInteractiveMask()) {\n        mask._transformMargin(ghostContext, resolution, ghostLayer.margin);\n        mask._runPath(ghostContext);\n        ghostContext.clip();\n      }\n      this._transformMargin(ghostContext, resolution, ghostLayer.margin);\n      this._render(parentLayer);\n      ghostContext.restore();\n      $array.each(layers, layer => {\n        if (layer) {\n          layer.context.restore();\n        }\n      });\n    }\n  }\n  _render(parentLayer) {\n    if (this.exportable === false) {\n      const layer = this._layer || parentLayer;\n      layer.tainted = true;\n    }\n  }\n  hovering() {\n    return this._renderer._hovering.has(this);\n  }\n  dragging() {\n    return this._renderer._dragging.some(x => x.value === this);\n  }\n  shouldCancelTouch() {\n    const renderer = this._renderer;\n    if (renderer.tapToActivate && !renderer._touchActive) {\n      return false;\n    }\n    if (this.cancelTouch) {\n      return true;\n    } else if (this._parent) {\n      return this._parent.shouldCancelTouch();\n    }\n    return false;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasContainer extends CanvasDisplayObject {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"interactiveChildren\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_childLayers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_children\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  _isInteractiveMask() {\n    return this.interactiveChildren || super._isInteractiveMask();\n  }\n  addChild(child) {\n    child._parent = this;\n    this._children.push(child);\n    if (child._layer) {\n      this.registerChildLayer(child._layer);\n    }\n  }\n  addChildAt(child, index) {\n    child._parent = this;\n    this._children.splice(index, 0, child);\n    if (child._layer) {\n      this.registerChildLayer(child._layer);\n    }\n  }\n  removeChild(child) {\n    child._parent = undefined;\n    $array.removeFirst(this._children, child);\n  }\n  _render(parentLayer) {\n    super._render(parentLayer);\n    const renderer = this._renderer;\n    if (this.interactive && this.interactiveChildren) {\n      ++renderer._forceInteractive;\n    }\n    const layer = this._layer || parentLayer;\n    $array.each(this._children, child => {\n      child.compoundAlpha = this.compoundAlpha * this.alpha;\n      child.render(layer);\n    });\n    if (this.interactive && this.interactiveChildren) {\n      --renderer._forceInteractive;\n    }\n  }\n  registerChildLayer(layer) {\n    if (!this._childLayers) {\n      this._childLayers = [];\n    }\n    $array.pushOne(this._childLayers, layer);\n    if (this._parent) {\n      this._parent.registerChildLayer(layer);\n    }\n  }\n  markDirtyLayer() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super.markDirtyLayer();\n    if (deep && this._childLayers) {\n      $array.each(this._childLayers, layer => layer.dirty = true);\n    }\n  }\n  _dispose() {\n    super._dispose();\n    if (this._childLayers) {\n      $array.each(this._childLayers, layer => {\n        layer.dirty = true;\n      });\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction setPoint(bounds, point) {\n  bounds.left = Math.min(bounds.left, point.x);\n  bounds.top = Math.min(bounds.top, point.y);\n  bounds.right = Math.max(bounds.right, point.x);\n  bounds.bottom = Math.max(bounds.bottom, point.y);\n}\n/**\r\n * @ignore\r\n */\nclass Op {\n  colorize(_context, _forceColor) {}\n  path(_context) {}\n  addBounds(_bounds) {}\n}\n/**\r\n * @ignore\r\n */\nclass BeginPath extends Op {\n  colorize(context, _forceColor) {\n    context.beginPath();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass BeginFill extends Op {\n  constructor(color) {\n    super();\n    Object.defineProperty(this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n  }\n  colorize(context, forceColor) {\n    if (forceColor !== undefined) {\n      context.fillStyle = forceColor;\n    } else {\n      context.fillStyle = this.color;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass EndFill extends Op {\n  constructor(clearShadow) {\n    super();\n    Object.defineProperty(this, \"clearShadow\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: clearShadow\n    });\n  }\n  colorize(context, _forceColor) {\n    context.fill();\n    if (this.clearShadow) {\n      context.shadowColor = \"\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass EndStroke extends Op {\n  colorize(context, _forceColor) {\n    context.stroke();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineStyle extends Op {\n  constructor(width, color, lineJoin) {\n    super();\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(this, \"lineJoin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: lineJoin\n    });\n  }\n  colorize(context, forceColor) {\n    if (forceColor !== undefined) {\n      context.strokeStyle = forceColor;\n    } else {\n      context.strokeStyle = this.color;\n    }\n    context.lineWidth = this.width;\n    if (this.lineJoin) {\n      context.lineJoin = this.lineJoin;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineDash extends Op {\n  constructor(dash) {\n    super();\n    Object.defineProperty(this, \"dash\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dash\n    });\n  }\n  colorize(context, _forceColor) {\n    context.setLineDash(this.dash);\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineDashOffset extends Op {\n  constructor(dashOffset) {\n    super();\n    Object.defineProperty(this, \"dashOffset\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dashOffset\n    });\n  }\n  colorize(context, _forceColor) {\n    context.lineDashOffset = this.dashOffset;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawRect extends Op {\n  constructor(x, y, width, height) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n  }\n  path(context) {\n    context.rect(this.x, this.y, this.width, this.height);\n  }\n  addBounds(bounds) {\n    const l = this.x;\n    const t = this.y;\n    const r = l + this.width;\n    const b = t + this.height;\n    setPoint(bounds, {\n      x: l,\n      y: t\n    });\n    setPoint(bounds, {\n      x: r,\n      y: t\n    });\n    setPoint(bounds, {\n      x: l,\n      y: b\n    });\n    setPoint(bounds, {\n      x: r,\n      y: b\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawCircle extends Op {\n  constructor(x, y, radius) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n  }\n  path(context) {\n    context.moveTo(this.x + this.radius, this.y);\n    context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n  }\n  // TODO handle skewing and rotation\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x - this.radius,\n      y: this.y - this.radius\n    });\n    setPoint(bounds, {\n      x: this.x + this.radius,\n      y: this.y + this.radius\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawEllipse extends Op {\n  constructor(x, y, radiusX, radiusY) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, \"radiusX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusX\n    });\n    Object.defineProperty(this, \"radiusY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusY\n    });\n  }\n  path(context) {\n    context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);\n  }\n  // TODO handle skewing and rotation\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x - this.radiusX,\n      y: this.y - this.radiusY\n    });\n    setPoint(bounds, {\n      x: this.x + this.radiusX,\n      y: this.y + this.radiusY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Arc extends Op {\n  constructor(cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    super();\n    Object.defineProperty(this, \"cx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cx\n    });\n    Object.defineProperty(this, \"cy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cy\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n    Object.defineProperty(this, \"startAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: startAngle\n    });\n    Object.defineProperty(this, \"endAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: endAngle\n    });\n    Object.defineProperty(this, \"anticlockwise\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: anticlockwise\n    });\n  }\n  path(context) {\n    if (this.radius > 0) {\n      context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n    }\n  }\n  addBounds(bounds) {\n    let arcBounds = $math.getArcBounds(this.cx, this.cy, this.startAngle * $math.DEGREES, this.endAngle * $math.DEGREES, this.radius);\n    setPoint(bounds, {\n      x: arcBounds.left,\n      y: arcBounds.top\n    });\n    setPoint(bounds, {\n      x: arcBounds.right,\n      y: arcBounds.bottom\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass ArcTo extends Op {\n  constructor(x1, y1, x2, y2, radius) {\n    super();\n    Object.defineProperty(this, \"x1\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x1\n    });\n    Object.defineProperty(this, \"y1\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y1\n    });\n    Object.defineProperty(this, \"x2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x2\n    });\n    Object.defineProperty(this, \"y2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y2\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n  }\n  path(context) {\n    if (this.radius > 0) {\n      context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n    }\n  }\n  // TODO: add points\n  addBounds(_bounds) {\n    /*\r\n    // not finished\r\n    https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically\r\n      if (prevPoint) {\r\n        let x1 = prevPoint.x;\r\n        let y1 = prevPoint.y;\r\n        let x2 = this.x2;\r\n        let y2 = this.y2;\r\n        let r = this.radius;\r\n          let xa = (x2 - x1) / 2;\r\n        let ya = (y2 - y1) / 2;\r\n          let x0 = x1 + xa;\r\n        let y0 = y1 + ya;\r\n          let a = Math.hypot(xa, ya);\r\n        let b = Math.sqrt(r * r - a * a);\r\n          let cx = x0 + b * ya / a;\r\n        let cy = y0 - b * xa / a;\r\n          console.log(cx, cy);\r\n    }*/\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineTo extends Op {\n  constructor(x, y) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.lineTo(this.x, this.y);\n  }\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass MoveTo extends Op {\n  constructor(x, y) {\n    super();\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.moveTo(this.x, this.y);\n  }\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass ClosePath extends Op {\n  path(context) {\n    context.closePath();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass BezierCurveTo extends Op {\n  constructor(cpX, cpY, cpX2, cpY2, toX, toY) {\n    super();\n    Object.defineProperty(this, \"cpX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(this, \"cpY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(this, \"cpX2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX2\n    });\n    Object.defineProperty(this, \"cpY2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY2\n    });\n    Object.defineProperty(this, \"toX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(this, \"toY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n  }\n  path(context) {\n    context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.cpX,\n      y: this.cpY\n    });\n    setPoint(bounds, {\n      x: this.cpX2,\n      y: this.cpY2\n    });\n    setPoint(bounds, {\n      x: this.toX,\n      y: this.toY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass QuadraticCurveTo extends Op {\n  constructor(cpX, cpY, toX, toY) {\n    super();\n    Object.defineProperty(this, \"cpX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(this, \"cpY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(this, \"toX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(this, \"toY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n  }\n  path(context) {\n    context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.cpX,\n      y: this.cpY\n    });\n    setPoint(bounds, {\n      x: this.toX,\n      y: this.toY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Shadow extends Op {\n  constructor(color, blur, offsetX, offsetY, opacity) {\n    super();\n    Object.defineProperty(this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(this, \"blur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: blur\n    });\n    Object.defineProperty(this, \"offsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetX\n    });\n    Object.defineProperty(this, \"offsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetY\n    });\n    Object.defineProperty(this, \"opacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: opacity\n    });\n  }\n  colorize(context, _forceColor) {\n    if (this.opacity) {\n      context.fillStyle = this.color;\n    }\n    context.shadowColor = this.color;\n    context.shadowBlur = this.blur;\n    context.shadowOffsetX = this.offsetX;\n    context.shadowOffsetY = this.offsetY;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass GraphicsImage extends Op {\n  constructor(image, width, height, x, y) {\n    super();\n    Object.defineProperty(this, \"image\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: image\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n    Object.defineProperty(this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.drawImage(this.image, this.x, this.y, this.width, this.height);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n    setPoint(bounds, {\n      x: this.width,\n      y: this.height\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasGraphics extends CanvasDisplayObject {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_operations\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"blendMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: BlendMode.NORMAL\n    });\n    Object.defineProperty(this, \"_hasShadows\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_fillAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_strokeAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  clear() {\n    super.clear();\n    this._operations.length = 0;\n  }\n  _pushOp(op) {\n    this._operations.push(op);\n  }\n  beginFill(color) {\n    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this._fillAlpha = alpha;\n    if (color) {\n      if (color instanceof Color) {\n        this._pushOp(new BeginFill(color.toCSS(alpha)));\n      } else {\n        this.isMeasured = true;\n        this._pushOp(new BeginFill(color));\n      }\n    } else {\n      this._pushOp(new BeginFill(\"rgba(0, 0, 0, \" + alpha + \")\"));\n    }\n  }\n  endFill() {\n    this._pushOp(new EndFill(this._hasShadows));\n  }\n  endStroke() {\n    this._pushOp(new EndStroke());\n  }\n  beginPath() {\n    this._pushOp(new BeginPath());\n  }\n  lineStyle() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let color = arguments.length > 1 ? arguments[1] : undefined;\n    let alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let lineJoin = arguments.length > 3 ? arguments[3] : undefined;\n    this._strokeAlpha = alpha;\n    if (color) {\n      if (color instanceof Color) {\n        this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));\n      } else {\n        this._pushOp(new LineStyle(width, color, lineJoin));\n      }\n    } else {\n      this._pushOp(new LineStyle(width, \"rgba(0, 0, 0, \" + alpha + \")\", lineJoin));\n    }\n  }\n  setLineDash(dash) {\n    this._pushOp(new LineDash(dash ? dash : []));\n  }\n  setLineDashOffset() {\n    let dashOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this._pushOp(new LineDashOffset(dashOffset));\n  }\n  drawRect(x, y, width, height) {\n    this._pushOp(new DrawRect(x, y, width, height));\n  }\n  drawCircle(x, y, radius) {\n    this._pushOp(new DrawCircle(x, y, radius));\n  }\n  drawEllipse(x, y, radiusX, radiusY) {\n    this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));\n  }\n  arc(cx, cy, radius, startAngle, endAngle) {\n    let anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));\n  }\n  arcTo(x1, y1, x2, y2, radius) {\n    this._pushOp(new ArcTo(x1, y1, x2, y2, radius));\n  }\n  lineTo(x, y) {\n    this._pushOp(new LineTo(x, y));\n  }\n  moveTo(x, y) {\n    this._pushOp(new MoveTo(x, y));\n  }\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));\n  }\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));\n  }\n  closePath() {\n    this._pushOp(new ClosePath());\n  }\n  shadow(color) {\n    let blur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let opacity = arguments.length > 4 ? arguments[4] : undefined;\n    this._hasShadows = true;\n    this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));\n  }\n  image(image, width, height, x, y) {\n    this._pushOp(new GraphicsImage(image, width, height, x, y));\n  }\n  // https://svgwg.org/svg2-draft/paths.html#DProperty\n  // TODO better error checking\n  svgPath(path) {\n    let x = 0;\n    let y = 0;\n    let cpx = null;\n    let cpy = null;\n    let qcpx = null;\n    let qcpy = null;\n    const SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;\n    const ARGS_REGEXP = /[\\u0009\\u0020\\u000A\\u000C\\u000D]*([\\+\\-]?[0-9]*\\.?[0-9]+(?:[eE][\\+\\-]?[0-9]+)?)[\\u0009\\u0020\\u000A\\u000C\\u000D]*,?/g;\n    let match;\n    while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {\n      const name = match[1];\n      const rest = match[2];\n      const args = [];\n      while ((match = ARGS_REGEXP.exec(rest)) !== null) {\n        args.push(match[1]);\n      }\n      // Reset control point\n      if (name !== \"S\" && name !== \"s\" && name !== \"C\" && name !== \"c\") {\n        cpx = null;\n        cpy = null;\n      }\n      // Reset control point\n      if (name !== \"Q\" && name !== \"q\" && name !== \"T\" && name !== \"t\") {\n        qcpx = null;\n        qcpy = null;\n      }\n      switch (name) {\n        case \"M\":\n          checkEvenArgs(name, args.length, 2);\n          x = +args[0];\n          y = +args[1];\n          this.moveTo(x, y);\n          for (let i = 2; i < args.length; i += 2) {\n            x = +args[i];\n            y = +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"m\":\n          checkEvenArgs(name, args.length, 2);\n          x += +args[0];\n          y += +args[1];\n          this.moveTo(x, y);\n          for (let i = 2; i < args.length; i += 2) {\n            x += +args[i];\n            y += +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"L\":\n          checkEvenArgs(name, args.length, 2);\n          for (let i = 0; i < args.length; i += 2) {\n            x = +args[i];\n            y = +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"l\":\n          checkEvenArgs(name, args.length, 2);\n          for (let i = 0; i < args.length; i += 2) {\n            x += +args[i];\n            y += +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"H\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            x = +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"h\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            x += +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"V\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            y = +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"v\":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            y += +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case \"C\":\n          checkEvenArgs(name, args.length, 6);\n          for (let i = 0; i < args.length; i += 6) {\n            const x1 = +args[i];\n            const y1 = +args[i + 1];\n            cpx = +args[i + 2];\n            cpy = +args[i + 3];\n            x = +args[i + 4];\n            y = +args[i + 5];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"c\":\n          checkEvenArgs(name, args.length, 6);\n          for (let i = 0; i < args.length; i += 6) {\n            const x1 = +args[i] + x;\n            const y1 = +args[i + 1] + y;\n            cpx = +args[i + 2] + x;\n            cpy = +args[i + 3] + y;\n            x += +args[i + 4];\n            y += +args[i + 5];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"S\":\n          checkEvenArgs(name, args.length, 4);\n          if (cpx === null || cpy === null) {\n            cpx = x;\n            cpy = y;\n          }\n          for (let i = 0; i < args.length; i += 4) {\n            const x1 = 2 * x - cpx;\n            const y1 = 2 * y - cpy;\n            cpx = +args[i];\n            cpy = +args[i + 1];\n            x = +args[i + 2];\n            y = +args[i + 3];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"s\":\n          checkEvenArgs(name, args.length, 4);\n          if (cpx === null || cpy === null) {\n            cpx = x;\n            cpy = y;\n          }\n          for (let i = 0; i < args.length; i += 4) {\n            const x1 = 2 * x - cpx;\n            const y1 = 2 * y - cpy;\n            cpx = +args[i] + x;\n            cpy = +args[i + 1] + y;\n            x += +args[i + 2];\n            y += +args[i + 3];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case \"Q\":\n          checkEvenArgs(name, args.length, 4);\n          for (let i = 0; i < args.length; i += 4) {\n            qcpx = +args[i];\n            qcpy = +args[i + 1];\n            x = +args[i + 2];\n            y = +args[i + 3];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"q\":\n          checkEvenArgs(name, args.length, 4);\n          for (let i = 0; i < args.length; i += 4) {\n            qcpx = +args[i] + x;\n            qcpy = +args[i + 1] + y;\n            x += +args[i + 2];\n            y += +args[i + 3];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"T\":\n          checkEvenArgs(name, args.length, 2);\n          if (qcpx === null || qcpy === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          for (let i = 0; i < args.length; i += 2) {\n            qcpx = 2 * x - qcpx;\n            qcpy = 2 * y - qcpy;\n            x = +args[i];\n            y = +args[i + 1];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"t\":\n          checkEvenArgs(name, args.length, 2);\n          if (qcpx === null || qcpy === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          for (let i = 0; i < args.length; i += 2) {\n            qcpx = 2 * x - qcpx;\n            qcpy = 2 * y - qcpy;\n            x += +args[i];\n            y += +args[i + 1];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case \"A\":\n        case \"a\":\n          const relative = name === \"a\";\n          splitArcFlags(args);\n          checkEvenArgs(name, args.length, 7);\n          for (let i = 0; i < args.length; i += 7) {\n            let cx = +args[i + 5];\n            let cy = +args[i + 6];\n            if (relative) {\n              cx += x;\n              cy += y;\n            }\n            const bs = arcToBezier({\n              px: x,\n              py: y,\n              rx: +args[i],\n              ry: +args[i + 1],\n              xAxisRotation: +args[i + 2],\n              largeArcFlag: assertBinary(+args[i + 3]),\n              sweepFlag: assertBinary(+args[i + 4]),\n              cx,\n              cy\n            });\n            $array.each(bs, b => {\n              this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);\n              x = b.x;\n              y = b.y;\n            });\n          }\n          break;\n        case \"Z\":\n        case \"z\":\n          checkArgs(name, args.length, 0);\n          this.closePath();\n          break;\n      }\n    }\n  }\n  _runPath(context) {\n    context.beginPath();\n    $array.each(this._operations, op => {\n      op.path(context);\n    });\n  }\n  _render(parentLayer) {\n    super._render(parentLayer);\n    const layer = this._layer || parentLayer;\n    const layerDirty = layer.dirty;\n    const interactive = this._isInteractive();\n    if (layerDirty || interactive) {\n      const context = layer.context;\n      const ghostContext = this._renderer._ghostLayer.context;\n      if (layerDirty) {\n        context.globalCompositeOperation = this.blendMode;\n        context.beginPath();\n      }\n      let color;\n      if (interactive) {\n        ghostContext.beginPath();\n        color = this._getColorId();\n      }\n      $array.each(this._operations, op => {\n        if (layerDirty) {\n          op.path(context);\n          op.colorize(context, undefined);\n        }\n        if (interactive) {\n          op.path(ghostContext);\n          op.colorize(ghostContext, color);\n        }\n      });\n    }\n  }\n  renderDetached(context) {\n    if (this.visible) {\n      this._setMatrix();\n      context.save();\n      // We must apply the mask before we transform the element\n      const mask = this.mask;\n      if (mask) {\n        mask._setMatrix();\n        mask._transform(context, 1);\n        mask._runPath(context);\n        context.clip();\n      }\n      // TODO handle compoundAlpha somehow ?\n      context.globalAlpha = this.compoundAlpha * this.alpha;\n      this._transform(context, 1);\n      if (this.filter) {\n        context.filter = this.filter;\n      }\n      context.globalCompositeOperation = this.blendMode;\n      context.beginPath();\n      $array.each(this._operations, op => {\n        op.path(context);\n        op.colorize(context, undefined);\n      });\n      context.restore();\n    }\n  }\n  _addBounds(bounds) {\n    if (this.visible && this.isMeasured) {\n      $array.each(this._operations, op => {\n        op.addBounds(bounds);\n      });\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasText extends CanvasDisplayObject {\n  constructor(renderer, text, style) {\n    super(renderer);\n    Object.defineProperty(this, \"text\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"style\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"textVisible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_textInfo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_originalScale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    this.text = text;\n    this.style = style;\n  }\n  invalidateBounds() {\n    super.invalidateBounds();\n    this._textInfo = undefined;\n  }\n  _shared(context) {\n    if (this.style.textAlign) {\n      context.textAlign = this.style.textAlign;\n    }\n    if (this.style.direction) {\n      context.direction = this.style.direction;\n    }\n    if (this.style.textBaseline) {\n      context.textBaseline = this.style.textBaseline;\n    }\n  }\n  _prerender(layer) {\n    let ignoreGhost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ignoreFontWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super._render(layer);\n    const context = layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    // Font style\n    const style = this.style;\n    let fontStyle = this._getFontStyle(undefined, ignoreFontWeight);\n    context.font = fontStyle;\n    if (this._isInteractive() && !ignoreGhost) {\n      ghostContext.font = fontStyle;\n    }\n    // Other parameters\n    if (style.fill) {\n      if (style.fill instanceof Color) {\n        context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);\n      } else {\n        context.fillStyle = style.fill;\n      }\n    }\n    if (style.shadowColor) {\n      layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);\n    }\n    if (style.shadowBlur) {\n      layer.context.shadowBlur = style.shadowBlur;\n    }\n    if (style.shadowOffsetX) {\n      layer.context.shadowOffsetX = style.shadowOffsetX;\n    }\n    if (style.shadowOffsetY) {\n      layer.context.shadowOffsetY = style.shadowOffsetY;\n    }\n    this._shared(context);\n    if (this._isInteractive() && !ignoreGhost) {\n      ghostContext.fillStyle = this._getColorId();\n      this._shared(ghostContext);\n    }\n  }\n  _getFontStyle(style2) {\n    let ignoreFontWeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // Process defaults\n    const style = this.style;\n    let fontStyle = [];\n    if (style2 && style2.fontVariant) {\n      fontStyle.push(style2.fontVariant);\n    } else if (style.fontVariant) {\n      fontStyle.push(style.fontVariant);\n    }\n    if (!ignoreFontWeight) {\n      if (style2 && style2.fontWeight) {\n        fontStyle.push(style2.fontWeight);\n      } else if (style.fontWeight) {\n        fontStyle.push(style.fontWeight);\n      }\n    }\n    if (style2 && style2.fontStyle) {\n      fontStyle.push(style2.fontStyle);\n    } else if (style.fontStyle) {\n      fontStyle.push(style.fontStyle);\n    }\n    if (style2 && style2.fontSize) {\n      if ($type.isNumber(style2.fontSize)) {\n        style2.fontSize = style2.fontSize + \"px\";\n      }\n      fontStyle.push(style2.fontSize);\n    } else if (style.fontSize) {\n      if ($type.isNumber(style.fontSize)) {\n        style.fontSize = style.fontSize + \"px\";\n      }\n      fontStyle.push(style.fontSize);\n    }\n    if (style2 && style2.fontFamily) {\n      fontStyle.push(style2.fontFamily);\n    } else if (style.fontFamily) {\n      fontStyle.push(style.fontFamily);\n    } else if (fontStyle.length) {\n      fontStyle.push(\"Arial\");\n    }\n    return fontStyle.join(\" \");\n  }\n  _render(parentLayer) {\n    const layer = this._layer || parentLayer;\n    // We need measurements in order to properly position text for alignment\n    if (!this._textInfo) {\n      this._measure(layer);\n    }\n    if (this.textVisible) {\n      const interactive = this._isInteractive();\n      const context = layer.context;\n      const layerDirty = layer.dirty;\n      const ghostContext = this._renderer._ghostLayer.context;\n      context.save();\n      ghostContext.save();\n      this._prerender(layer);\n      // const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n      // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;\n      // Process text info produced by _measure()\n      $array.each(this._textInfo, (line, _index) => {\n        $array.each(line.textChunks, (chunk, _index) => {\n          // Set style\n          if (chunk.style) {\n            context.save();\n            ghostContext.save();\n            context.font = chunk.style;\n            if (this._isInteractive()) {\n              ghostContext.font = chunk.style;\n            }\n          }\n          if (chunk.fill) {\n            context.save();\n            context.fillStyle = chunk.fill.toCSS();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Draw text\n          if (layerDirty) {\n            context.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n          }\n          // Draw underline\n          if (chunk.textDecoration == \"underline\" || chunk.textDecoration == \"line-through\") {\n            let thickness = 1;\n            let offset = 1;\n            let fontSize = chunk.height;\n            let offsetX = chunk.offsetX;\n            switch (this.style.textAlign) {\n              case \"right\":\n              case \"end\":\n                offsetX -= chunk.width;\n                break;\n              case \"center\":\n                offsetX -= chunk.width / 2;\n                break;\n            }\n            if (chunk.style) {\n              const format = TextFormatter.getTextStyle(chunk.style);\n              switch (format.fontWeight) {\n                case \"bolder\":\n                case \"bold\":\n                case \"700\":\n                case \"800\":\n                case \"900\":\n                  thickness = 2;\n                  break;\n              }\n            }\n            if (fontSize) {\n              offset = fontSize / 20;\n            }\n            let y;\n            if (chunk.textDecoration == \"line-through\") {\n              y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;\n            } else {\n              y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;\n            }\n            context.save();\n            context.beginPath();\n            if (chunk.fill) {\n              context.strokeStyle = chunk.fill.toCSS();\n            } else if (this.style.fill && this.style.fill instanceof Color) {\n              context.strokeStyle = this.style.fill.toCSS();\n            }\n            context.lineWidth = thickness * offset;\n            context.moveTo(offsetX, y);\n            context.lineTo(offsetX + chunk.width, y);\n            context.stroke();\n            context.restore();\n          }\n          if (interactive && this.interactive) {\n            // Draw text in ghost canvas ONLY if it is set as interactive\n            // explicitly. This way we avoid hit test anomalies caused by anti\n            // aliasing of text.\n            ghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n          }\n          if (chunk.fill) {\n            context.restore();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Reset style\n          if (chunk.style) {\n            context.restore();\n            ghostContext.restore();\n          }\n        });\n      });\n      context.restore();\n      ghostContext.restore();\n    }\n  }\n  _addBounds(bounds) {\n    if (this.visible && this.isMeasured) {\n      //if (this._textVisible) {\n      const x = this._measure(this.getLayer());\n      setPoint(bounds, {\n        x: x.left,\n        y: x.top\n      });\n      setPoint(bounds, {\n        x: x.right,\n        y: x.bottom\n      });\n      //}\n    }\n  }\n\n  _ignoreFontWeight() {\n    return /apple/i.test(navigator.vendor);\n  }\n  _measure(layer) {\n    const context = layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    const rtl = this.style.direction == \"rtl\";\n    // Reset text info\n    this._textInfo = [];\n    // Init\n    const oversizedBehavior = this.style.oversizedBehavior;\n    const maxWidth = this.style.maxWidth;\n    const truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n    const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n    // Pre-render\n    context.save();\n    ghostContext.save();\n    this._prerender(layer, true, this._ignoreFontWeight());\n    // Get default font metrix\n    const refText = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\n    // Split up text into lines\n    const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n    let styleRestored = true;\n    let minX = 0;\n    let maxX = 0;\n    // Iterate through the lines\n    let offsetY = 0;\n    let currentStyle;\n    $array.each(lines, (line, _index) => {\n      // Split up line into format/value chunks\n      let chunks;\n      if (line == \"\") {\n        chunks = [{\n          type: \"value\",\n          text: \"\"\n        }];\n      } else {\n        chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n      }\n      while (chunks.length > 0) {\n        // Init line object\n        let lineInfo = {\n          offsetY: offsetY,\n          ascent: 0,\n          width: 0,\n          height: 0,\n          left: 0,\n          right: 0,\n          textChunks: []\n        };\n        // Measure reference text\n        const metrics = this._measureText(refText, context);\n        const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n        lineInfo.height = height;\n        lineInfo.ascent = metrics.actualBoundingBoxAscent;\n        let currentFormat;\n        let currentDecoration = this.style.textDecoration;\n        let currentFill;\n        let currentChunkWidth;\n        let skipFurtherText = false;\n        let firstTextChunk = true;\n        let leftoverChunks = [];\n        let currentVerticalAlign;\n        //let offsetX = 0;\n        //let chunk;\n        //while(chunk = chunks.shift()) {\n        $array.eachContinue(chunks, (chunk, index) => {\n          // Format chunk\n          if (chunk.type == \"format\") {\n            if (chunk.text == \"[/]\") {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n                styleRestored = true;\n              }\n              currentFill = undefined;\n              currentStyle = undefined;\n              currentChunkWidth = undefined;\n              currentDecoration = this.style.textDecoration;\n              currentVerticalAlign = undefined;\n              currentFormat = chunk.text;\n            } else {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n              }\n              let format = TextFormatter.getTextStyle(chunk.text);\n              const fontStyle = this._getFontStyle(format);\n              context.save();\n              ghostContext.save();\n              context.font = fontStyle;\n              currentStyle = fontStyle;\n              currentFormat = chunk.text;\n              if (format.textDecoration) {\n                currentDecoration = format.textDecoration;\n              }\n              if (format.fill) {\n                currentFill = format.fill;\n              }\n              if (format.width) {\n                currentChunkWidth = $type.toNumber(format.width);\n              }\n              if (format.verticalAlign) {\n                currentVerticalAlign = format.verticalAlign;\n              }\n              styleRestored = false;\n              // Measure reference text after change of format\n              const metrics = this._measureText(refText, context);\n              const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n              if (height > lineInfo.height) {\n                lineInfo.height = height;\n              }\n              if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n                lineInfo.ascent = metrics.actualBoundingBoxAscent;\n              }\n            }\n          }\n          // Text chunk\n          else if (chunk.type == \"value\" && !skipFurtherText) {\n            // Measure\n            const metrics = this._measureText(chunk.text, context);\n            let chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n            // Check for fit\n            if (truncate) {\n              // Break words?\n              let breakWords = firstTextChunk || this.style.breakWords || false;\n              // Measure ellipsis and check if it fits\n              const ellipsis = this.style.ellipsis || \"\";\n              const ellipsisMetrics = this._measureText(ellipsis, context);\n              const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n              // Check fit\n              if (lineInfo.width + chunkWidth > maxWidth) {\n                const excessWidth = maxWidth - lineInfo.width - ellipsisWidth;\n                chunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);\n                chunk.text += ellipsis;\n                skipFurtherText = true;\n              }\n            } else if (wrap) {\n              // Check fit\n              if (lineInfo.width + chunkWidth > maxWidth) {\n                const excessWidth = maxWidth - lineInfo.width;\n                const tmpText = this._truncateText(context, chunk.text, excessWidth, false, firstTextChunk && this.style.oversizedBehavior != \"wrap-no-break\");\n                if (tmpText == \"\") {\n                  // Unable to fit a single letter - hide the whole label\n                  this.textVisible = true;\n                  return false;\n                }\n                //skipFurtherText = true;\n                //Add remaining chunks for the next line\n                leftoverChunks = chunks.slice(index + 1);\n                //Add remaining text of current chunk if it was forced-cut\n                if ($utils.trim(tmpText) != $utils.trim(chunk.text)) {\n                  leftoverChunks.unshift({\n                    type: \"value\",\n                    text: chunk.text.substr(tmpText.length)\n                  });\n                  if (currentFormat) {\n                    leftoverChunks.unshift({\n                      type: \"format\",\n                      text: currentFormat\n                    });\n                  }\n                }\n                // Set current chunk (truncated)\n                chunk.text = $utils.trim(tmpText);\n                chunks = [];\n                skipFurtherText = true;\n              }\n            }\n            // Chunk width?\n            let leftBoundMod = 1;\n            let rightBoundMod = 1;\n            if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n              // increase horizontal bounding boxes accordingly\n              const boundsMod = chunkWidth / currentChunkWidth;\n              switch (this.style.textAlign) {\n                case \"right\":\n                case \"end\":\n                  leftBoundMod = boundsMod;\n                  break;\n                case \"center\":\n                  leftBoundMod = boundsMod;\n                  rightBoundMod = boundsMod;\n                  break;\n                default:\n                  rightBoundMod = boundsMod;\n              }\n              chunkWidth = currentChunkWidth;\n            }\n            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            if (chunkHeight > lineInfo.height) {\n              lineInfo.height = chunkHeight;\n            }\n            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n              lineInfo.ascent = metrics.actualBoundingBoxAscent;\n            }\n            lineInfo.width += chunkWidth;\n            lineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;\n            lineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;\n            lineInfo.textChunks.push({\n              style: currentStyle,\n              fill: currentFill,\n              text: chunk.text,\n              width: chunkWidth,\n              height: chunkHeight,\n              left: metrics.actualBoundingBoxLeft,\n              right: metrics.actualBoundingBoxRight,\n              ascent: metrics.actualBoundingBoxAscent,\n              offsetX: 0,\n              offsetY: 0,\n              textDecoration: currentDecoration,\n              verticalAlign: currentVerticalAlign\n            });\n            //offsetX += chunkWidth;\n            firstTextChunk = false;\n          }\n          if (leftoverChunks) {\n            //return false;\n          }\n          return true;\n          //}\n        });\n\n        if (this.style.lineHeight instanceof Percent) {\n          lineInfo.height *= this.style.lineHeight.value;\n          lineInfo.ascent *= this.style.lineHeight.value;\n        } else {\n          lineInfo.height *= this.style.lineHeight || 1.2;\n          lineInfo.ascent *= this.style.lineHeight || 1.2;\n        }\n        if (minX < lineInfo.left) {\n          minX = lineInfo.left;\n        }\n        if (maxX < lineInfo.right) {\n          maxX = lineInfo.right;\n        }\n        this._textInfo.push(lineInfo);\n        //lineInfo.offsetY += lineInfo.ascent;\n        offsetY += lineInfo.height;\n        // Reset chunks so that it can proceed to the next line\n        chunks = leftoverChunks || [];\n      }\n    });\n    if (!styleRestored) {\n      context.restore();\n      ghostContext.restore();\n    }\n    // Adjust chunk internal offsets\n    $array.each(this._textInfo, (lineInfo, _index) => {\n      let currentChunkOffset = 0;\n      $array.each(lineInfo.textChunks, chunk => {\n        chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;\n        chunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);\n        currentChunkOffset += chunk.width;\n        if (chunk.verticalAlign) {\n          switch (chunk.verticalAlign) {\n            case \"super\":\n              chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;\n              break;\n            case \"sub\":\n              chunk.offsetY += chunk.height / 2;\n              break;\n          }\n        }\n      });\n    });\n    const bounds = {\n      left: rtl ? -maxX : -minX,\n      top: 0,\n      right: rtl ? minX : maxX,\n      bottom: offsetY\n    };\n    // We need to fit?\n    if (oversizedBehavior !== \"none\") {\n      const ratio = this._fitRatio(bounds);\n      if (ratio < 1) {\n        if (oversizedBehavior == \"fit\") {\n          if ($type.isNumber(this.style.minScale) && ratio < this.style.minScale) {\n            this.textVisible = false;\n            bounds.left = 0;\n            bounds.top = 0;\n            bounds.right = 0;\n            bounds.bottom = 0;\n          } else {\n            if (!this._originalScale || this._originalScale == 1) {\n              this._originalScale = this.scale;\n            }\n            this.scale = ratio;\n            this.textVisible = true;\n          }\n        } else if (oversizedBehavior == \"hide\") {\n          this.textVisible = false;\n          bounds.left = 0;\n          bounds.top = 0;\n          bounds.right = 0;\n          bounds.bottom = 0;\n        } else {\n          switch (this.style.textAlign) {\n            case \"right\":\n            case \"end\":\n              bounds.left = -maxWidth;\n              bounds.right = 0;\n              break;\n            case \"center\":\n              bounds.left = -maxWidth / 2;\n              bounds.right = maxWidth / 2;\n              break;\n            default:\n              bounds.left = 0;\n              bounds.right = maxWidth;\n          }\n          this.scale = this._originalScale || 1;\n          this._originalScale = undefined;\n          this.textVisible = true;\n        }\n      } else {\n        this.scale = this._originalScale || 1;\n        this._originalScale = undefined;\n        this.textVisible = true;\n      }\n    }\n    context.restore();\n    ghostContext.restore();\n    return bounds;\n  }\n  _fitRatio(bounds) {\n    const maxW = this.style.maxWidth;\n    const maxH = this.style.maxHeight;\n    if (!$type.isNumber(maxW) && !$type.isNumber(maxH)) {\n      return 1;\n    }\n    const w = bounds.right - bounds.left;\n    const h = bounds.bottom - bounds.top;\n    return Math.min(maxW / w || 1, maxH / h || 1);\n  }\n  _truncateText(context, text, maxWidth) {\n    let breakWords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let fallbackBreakWords = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let width;\n    do {\n      if (breakWords) {\n        text = text.slice(0, -1);\n      } else {\n        let tmp = text.replace(/[^,;:!?\\\\\\/\\s]+[,;:!?\\\\\\/\\s]*$/g, \"\");\n        if (tmp == \"\" && fallbackBreakWords) {\n          breakWords = true;\n        } else if (tmp == \"\") {\n          return text;\n        } else {\n          text = tmp;\n        }\n      }\n      const metrics = this._measureText(text, context);\n      width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n    } while (width > maxWidth && text != \"\");\n    return text;\n  }\n  _measureText(text, context) {\n    let metrics = context.measureText(text);\n    let fakeMetrics = {};\n    if (metrics.actualBoundingBoxAscent == null) {\n      const div = document.createElement(\"div\");\n      div.innerText = text;\n      div.style.visibility = \"hidden\";\n      div.style.position = \"absolute\";\n      div.style.top = \"-1000000px;\";\n      div.style.fontFamily = this.style.fontFamily || \"\";\n      div.style.fontSize = this.style.fontSize + \"\";\n      document.body.appendChild(div);\n      const bbox = div.getBoundingClientRect();\n      document.body.removeChild(div);\n      const h = bbox.height;\n      const w = metrics.width;\n      let left = 0;\n      let right = w;\n      fakeMetrics = {\n        actualBoundingBoxAscent: h,\n        actualBoundingBoxDescent: 0,\n        actualBoundingBoxLeft: left,\n        actualBoundingBoxRight: right,\n        fontBoundingBoxAscent: h,\n        fontBoundingBoxDescent: 0,\n        width: w\n      };\n      //return fake;\n    } else {\n      fakeMetrics = {\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight,\n        fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n        fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n        width: metrics.width\n      };\n    }\n    const w = metrics.width;\n    switch (this.style.textAlign) {\n      case \"right\":\n      case \"end\":\n        fakeMetrics.actualBoundingBoxLeft = w;\n        fakeMetrics.actualBoundingBoxRight = 0;\n        break;\n      case \"center\":\n        fakeMetrics.actualBoundingBoxLeft = w / 2;\n        fakeMetrics.actualBoundingBoxRight = w / 2;\n        break;\n      default:\n        fakeMetrics.actualBoundingBoxLeft = 0;\n        fakeMetrics.actualBoundingBoxRight = w;\n    }\n    return fakeMetrics;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasTextStyle {\n  constructor() {\n    //public wordWrapWidth: number = 100;\n    Object.defineProperty(this, \"fill\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fillOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textAlign\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontFamily\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontWeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontVariant\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textDecoration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowColor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowBlur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // leading?: number;\n    // letterSpacing?: number;\n    Object.defineProperty(this, \"lineHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: percent(120)\n    });\n    Object.defineProperty(this, \"baselineRatio\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0.19\n    });\n    // padding?: number;\n    // stroke?: number;\n    // strokeThickness?: number;\n    // trim?: number;\n    // wordWrap?: boolean;\n    Object.defineProperty(this, \"direction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textBaseline\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"oversizedBehavior\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"none\"\n    });\n    Object.defineProperty(this, \"breakWords\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"ellipsis\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"…\"\n    });\n    Object.defineProperty(this, \"maxWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"maxHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"minScale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ignoreFormatting\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasRadialText extends CanvasText {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"textType\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"circular\"\n    });\n    Object.defineProperty(this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"startAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inside\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"orientation\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"auto\"\n    });\n    Object.defineProperty(this, \"kerning\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_textReversed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _render(parentLayer) {\n    switch (this.textType) {\n      case \"circular\":\n        this._renderCircular(parentLayer);\n        break;\n      default:\n        super._render(parentLayer);\n        break;\n    }\n  }\n  _renderCircular(parentLayer) {\n    if (this.textVisible) {\n      const layer = this._layer || parentLayer;\n      this._prerender(layer);\n      const interactive = this._isInteractive();\n      const context = layer.context;\n      const layerDirty = layer.dirty;\n      const ghostContext = this._renderer._ghostLayer.context;\n      // Savepoint\n      context.save();\n      if (interactive) {\n        ghostContext.save();\n      }\n      // We need measurements in order to properly position text for alignment\n      if (!this._textInfo) {\n        this._measure(layer);\n      }\n      // Init\n      let radius = this.radius || 0;\n      let startAngle = this.startAngle || 0;\n      let deltaAngle = 0;\n      let orientation = this.orientation;\n      let inward = orientation == \"auto\" ? \"auto\" : orientation == \"inward\";\n      const inside = this.inside;\n      const align = this.style.textAlign || \"left\";\n      const kerning = this.kerning || 0;\n      let clockwise = align == \"left\" ? 1 : -1;\n      const shouldReverse = !this._textReversed;\n      // Check if we need to invert the whole stuff\n      if (inward == \"auto\") {\n        // Calc max angle so we know whether we need to flip it\n        let maxAngle = 0;\n        let midAngle = 0;\n        $array.each(this._textInfo, (line, _index) => {\n          const deltaAngle = startAngle + line.width / (radius - line.height) / 2 * -clockwise;\n          if (deltaAngle > maxAngle) {\n            maxAngle = deltaAngle;\n          }\n        });\n        if (align == \"left\") {\n          midAngle = (maxAngle + deltaAngle / 2) * $math.DEGREES;\n        } else if (align == \"right\") {\n          midAngle = (maxAngle - deltaAngle / 2) * $math.DEGREES;\n        } else {\n          midAngle = startAngle * $math.DEGREES;\n        }\n        midAngle = $math.normalizeAngle(midAngle);\n        inward = midAngle >= 270 || midAngle <= 90;\n      }\n      if (inward == true && shouldReverse) {\n        this._textInfo.reverse();\n        this._textReversed = true;\n      }\n      // if ((inward == false && align == \"left\") || (inward == true && align == \"right\")) {\n      // \tclockwise *= -1;\n      // }\n      // Process text info produced by _measure()\n      $array.each(this._textInfo, (line, _index) => {\n        const textHeight = line.height;\n        // Adjust radius (for `inside = false`)\n        // Radius adjustment for `inside = false` is below the line calculation\n        if (!inside) {\n          radius += textHeight;\n        }\n        // Reverse letters if we're painting them counter-clockwise\n        if ((clockwise == -1 && inward || clockwise == 1 && !inward) && shouldReverse) {\n          line.textChunks.reverse();\n        }\n        // Init angles\n        let lineStartAngle = startAngle;\n        deltaAngle = 0;\n        // Adjust for center-align\n        if (align == \"center\") {\n          lineStartAngle += line.width / (radius - textHeight) / 2 * -clockwise;\n          deltaAngle = lineStartAngle - startAngle;\n        }\n        // if (inward == \"auto\") {\n        // \tlet midAngle;\n        // \tif (align == \"left\") {\n        // \t\tmidAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;\n        // \t}\n        // \telse if () {\n        // \t\tmidAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;\n        // \t}\n        // \tinward = (midAngle >= 270) || (midAngle <= 90);\n        // }\n        // Rotate letters if they are facing outward\n        lineStartAngle += Math.PI * (inward ? 0 : 1); // Rotate 180 if outward\n        // Savepoint\n        context.save();\n        if (interactive) {\n          ghostContext.save();\n        }\n        // Assume starting angle\n        context.rotate(lineStartAngle);\n        if (interactive) {\n          ghostContext.rotate(lineStartAngle);\n        }\n        let angleShift = 0;\n        $array.each(line.textChunks, (chunk, _index) => {\n          // Draw the letter\n          const char = chunk.text;\n          const charWidth = chunk.width;\n          // Rotate half a letter\n          angleShift = charWidth / 2 / (radius - textHeight) * clockwise;\n          context.rotate(angleShift);\n          if (interactive) {\n            ghostContext.rotate(angleShift);\n          }\n          // Set style\n          if (chunk.style) {\n            context.save();\n            ghostContext.save();\n            context.font = chunk.style;\n            if (interactive) {\n              ghostContext.font = chunk.style;\n            }\n          }\n          if (chunk.fill) {\n            context.save();\n            context.fillStyle = chunk.fill.toCSS();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Center letters\n          context.textBaseline = \"middle\";\n          context.textAlign = \"center\";\n          if (interactive) {\n            ghostContext.textBaseline = \"middle\";\n            ghostContext.textAlign = \"center\";\n          }\n          // Plop the letter\n          if (layerDirty) {\n            context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n          }\n          if (interactive) {\n            ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n          }\n          if (chunk.fill) {\n            context.restore();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Reset style\n          if (chunk.style) {\n            context.restore();\n            ghostContext.restore();\n          }\n          // Rotate half a letter and add spacing\n          angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;\n          context.rotate(angleShift);\n          if (interactive) {\n            ghostContext.rotate(angleShift);\n          }\n        });\n        // Restore angle\n        context.restore();\n        if (interactive) {\n          ghostContext.restore();\n        }\n        // Adjust radius (for `inside = true`)\n        if (inside) {\n          radius -= textHeight;\n        }\n      });\n      // Restore\n      context.restore();\n      if (interactive) {\n        ghostContext.restore();\n      }\n    }\n  }\n  _measure(layer) {\n    switch (this.textType) {\n      case \"circular\":\n        return this._measureCircular(layer);\n      default:\n        return super._measure(layer);\n    }\n  }\n  _measureCircular(layer) {\n    const context = layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    const rtl = this.style.direction == \"rtl\";\n    const oversizedBehavior = this.style.oversizedBehavior;\n    const maxWidth = this.style.maxWidth;\n    const truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n    const ellipsis = this.style.ellipsis || \"\";\n    let ellipsisMetrics;\n    //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n    // Reset text info\n    this.textVisible = true;\n    this._textInfo = [];\n    this._textReversed = false;\n    // Pre-render\n    context.save();\n    ghostContext.save();\n    this._prerender(layer, true);\n    // Split up text into lines\n    const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n    let styleRestored = true;\n    let totalWidth = 0;\n    // Iterate through the lines\n    let offsetY = 0;\n    $array.each(lines, (line, _index) => {\n      // Split up line into format/value chunks\n      let chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n      // Init line object\n      let lineInfo = {\n        offsetY: offsetY,\n        ascent: 0,\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        textChunks: []\n      };\n      let currentStyle;\n      let currentFill;\n      let currentChunkWidth;\n      //while(chunk = chunks.shift()) {\n      $array.each(chunks, (chunk, _index) => {\n        // Format chunk\n        if (chunk.type == \"format\") {\n          if (chunk.text == \"[/]\") {\n            if (!styleRestored) {\n              context.restore();\n              ghostContext.restore();\n              styleRestored = true;\n            }\n            currentFill = undefined;\n            currentStyle = undefined;\n            currentChunkWidth = undefined;\n          } else {\n            let format = TextFormatter.getTextStyle(chunk.text);\n            const fontStyle = this._getFontStyle(format);\n            context.save();\n            ghostContext.save();\n            context.font = fontStyle;\n            currentStyle = fontStyle;\n            if (format.fill) {\n              currentFill = format.fill;\n            }\n            if (format.width) {\n              currentChunkWidth = $type.toNumber(format.width);\n            }\n            styleRestored = false;\n          }\n          if (truncate) {\n            ellipsisMetrics = this._measureText(ellipsis, context);\n          }\n        }\n        // Text format\n        else if (chunk.type == \"value\") {\n          // Measure each letter\n          const chars = chunk.text.match(/./ug) || [];\n          if (rtl) {\n            chars.reverse();\n          }\n          for (let i = 0; i < chars.length; i++) {\n            const char = chars[i];\n            // Measure\n            const metrics = this._measureText(char, context);\n            let chunkWidth = metrics.width;\n            // Chunk width?\n            if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n              chunkWidth = currentChunkWidth;\n            }\n            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            if (chunkHeight > lineInfo.height) {\n              lineInfo.height = chunkHeight;\n            }\n            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n              lineInfo.ascent = metrics.actualBoundingBoxAscent;\n            }\n            lineInfo.width += chunkWidth;\n            lineInfo.left += metrics.actualBoundingBoxLeft;\n            lineInfo.right += metrics.actualBoundingBoxRight;\n            lineInfo.textChunks.push({\n              style: currentStyle,\n              fill: currentFill,\n              text: char,\n              width: chunkWidth,\n              height: chunkHeight + metrics.actualBoundingBoxDescent,\n              left: metrics.actualBoundingBoxLeft,\n              right: metrics.actualBoundingBoxRight,\n              ascent: metrics.actualBoundingBoxAscent,\n              offsetX: 0,\n              offsetY: chunkHeight,\n              textDecoration: undefined\n            });\n            totalWidth += chunkWidth;\n            // Handle oversized behavior\n            if (truncate) {\n              // Measure ellipsis and check if it fits\n              if (!ellipsisMetrics) {\n                ellipsisMetrics = this._measureText(ellipsis, context);\n              }\n              const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n              totalWidth += ellipsisWidth;\n              if (totalWidth + ellipsisWidth > maxWidth) {\n                if (lineInfo.textChunks.length == 1) {\n                  this.textVisible = false;\n                } else {\n                  lineInfo.width += ellipsisWidth;\n                  lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;\n                  lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;\n                  lineInfo.textChunks.push({\n                    style: currentStyle,\n                    fill: currentFill,\n                    text: ellipsis,\n                    width: ellipsisWidth,\n                    height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,\n                    left: ellipsisMetrics.actualBoundingBoxLeft,\n                    right: ellipsisMetrics.actualBoundingBoxRight,\n                    ascent: ellipsisMetrics.actualBoundingBoxAscent,\n                    offsetX: 0,\n                    offsetY: chunkHeight,\n                    textDecoration: undefined\n                  });\n                }\n                break;\n              }\n            }\n            if (rtl) {\n              break;\n            }\n          }\n        }\n      });\n      if (this.style.lineHeight instanceof Percent) {\n        lineInfo.height *= this.style.lineHeight.value;\n      } else {\n        lineInfo.height *= this.style.lineHeight || 1.2;\n      }\n      this._textInfo.push(lineInfo);\n      //lineInfo.offsetY += lineInfo.ascent;\n      offsetY += lineInfo.height;\n    });\n    if (!styleRestored) {\n      context.restore();\n      ghostContext.restore();\n    }\n    if (oversizedBehavior == \"hide\" && totalWidth > maxWidth) {\n      this.textVisible = false;\n    }\n    // Adjust chunk internal offsets\n    $array.each(this._textInfo, lineInfo => {\n      $array.each(lineInfo.textChunks, chunk => {\n        chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);\n      });\n    });\n    context.restore();\n    ghostContext.restore();\n    return {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasImage extends CanvasDisplayObject {\n  constructor(renderer, image) {\n    super(renderer);\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"image\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowColor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowBlur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_imageMask\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.image = image;\n  }\n  _dispose() {\n    super._dispose();\n    if (this._imageMask) {\n      clearCanvas(this._imageMask);\n    }\n  }\n  getLocalBounds() {\n    if (!this._localBounds) {\n      let w = 0;\n      let h = 0;\n      if (this.width) {\n        w = this.width;\n      }\n      if (this.height) {\n        h = this.height;\n      }\n      this._localBounds = {\n        left: 0,\n        top: 0,\n        right: w,\n        bottom: h\n      };\n      this._addBounds(this._localBounds);\n    }\n    return this._localBounds;\n  }\n  _render(parentLayer) {\n    super._render(parentLayer);\n    if (this.image) {\n      const layer = this._layer || parentLayer;\n      if (this.tainted === undefined) {\n        this.tainted = isTainted(this.image);\n        layer.tainted = true;\n      }\n      if (this.tainted && this._renderer._omitTainted) {\n        return;\n      }\n      if (layer.dirty) {\n        if (this.shadowColor) {\n          layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);\n        }\n        if (this.shadowBlur) {\n          layer.context.shadowBlur = this.shadowBlur;\n        }\n        if (this.shadowOffsetX) {\n          layer.context.shadowOffsetX = this.shadowOffsetX;\n        }\n        if (this.shadowOffsetY) {\n          layer.context.shadowOffsetY = this.shadowOffsetY;\n        }\n        // TODO should this round ?\n        const width = this.width || this.image.naturalWidth;\n        const height = this.height || this.image.naturalHeight;\n        layer.context.drawImage(this.image, 0, 0, width, height);\n      }\n      if (this.interactive && this._isInteractive()) {\n        const mask = this._getMask(this.image);\n        this._renderer._ghostLayer.context.drawImage(mask, 0, 0);\n      }\n    }\n  }\n  clear() {\n    super.clear();\n    this.image = undefined;\n    this._imageMask = undefined;\n  }\n  _getMask(image) {\n    if (this._imageMask === undefined) {\n      // TODO should this round ?\n      const width = this.width || image.naturalWidth;\n      const height = this.height || image.naturalHeight;\n      // We need to create a second canvas because destination-in clears out the entire canvas\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = width;\n      canvas.height = height;\n      const context = canvas.getContext(\"2d\");\n      context.imageSmoothingEnabled = false;\n      context.fillStyle = this._getColorId();\n      context.fillRect(0, 0, width, height);\n      if (!isTainted(image)) {\n        context.globalCompositeOperation = \"destination-in\";\n        context.drawImage(image, 0, 0, width, height);\n      }\n      this._imageMask = canvas;\n    }\n    return this._imageMask;\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasRendererEvent {\n  constructor(event, originalPoint, point, bbox) {\n    Object.defineProperty(this, \"event\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: event\n    });\n    Object.defineProperty(this, \"originalPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: originalPoint\n    });\n    Object.defineProperty(this, \"point\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: point\n    });\n    Object.defineProperty(this, \"bbox\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: bbox\n    });\n    Object.defineProperty(this, \"id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"simulated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"native\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    if ($utils.supports(\"touchevents\") && event instanceof Touch) {\n      this.id = event.identifier;\n    } else {\n      this.id = null;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasRenderer extends ArrayDisposer {\n  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {\r\n      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);\r\n  });\r\n  */\n  constructor(resolution) {\n    super();\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"div\")\n    });\n    Object.defineProperty(this, \"_layerDom\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"div\")\n    });\n    Object.defineProperty(this, \"layers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_dirtyLayers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"defaultLayer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.getLayer(0)\n    });\n    Object.defineProperty(this, \"_ghostLayer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new GhostLayer()\n    });\n    Object.defineProperty(this, \"_patternCanvas\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"canvas\")\n    });\n    Object.defineProperty(this, \"_patternContext\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._patternCanvas.getContext(\"2d\")\n    });\n    Object.defineProperty(this, \"_domWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_domHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_canvasWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_canvasHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"interactionsEnabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_events\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_colorId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_colorMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_forceInteractive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_omitTainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    // TODO this should store the Id as well\n    Object.defineProperty(this, \"_hovering\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"_dragging\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_mousedown\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_lastPointerMoveEvent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tapToActivate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"tapToActivateTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3000\n    });\n    Object.defineProperty(this, \"_touchActive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_touchActiveTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (resolution == null) {\n      this.resolution = window.devicePixelRatio;\n    } else {\n      this.resolution = resolution;\n    }\n    this.view.style.position = \"absolute\";\n    this.view.appendChild(this._layerDom);\n    this._disposers.push(new Disposer(() => {\n      $object.each(this._events, (_key, events) => {\n        events.disposer.dispose();\n      });\n      $array.each(this.layers, layer => {\n        clearCanvas(layer.view);\n        if (layer.exportableView) {\n          clearCanvas(layer.exportableView);\n        }\n      });\n      clearCanvas(this._ghostLayer.view);\n      clearCanvas(this._patternCanvas);\n    }));\n    /*\r\n    this._disposers.push($utils.addEventListener(this._ghostLayer.view, \"click\", (originalEvent: MouseEvent) => {\r\n        const event = this.getEvent(originalEvent);\r\n        const target = this._getHitTarget(event.originalPoint, event.bbox);\r\n        console.debug(target);\r\n    }));\r\n    */\n    // Monitor for possible pixel ratio changes (when page is zoomed)\n    this._disposers.push($utils.onZoom(() => {\n      if (resolution == null) {\n        this.resolution = window.devicePixelRatio;\n      }\n    }));\n    // We need this in order top prevent default touch gestures when dragging\n    // draggable elements\n    if ($utils.supports(\"touchevents\")) {\n      const listener = ev => {\n        if (this._dragging.length !== 0) {\n          $array.eachContinue(this._dragging, item => {\n            if (item.value.shouldCancelTouch()) {\n              ev.preventDefault();\n              return false;\n            }\n            return true;\n          });\n        }\n        // If touch down happends, delay touch out\n        if (this._touchActiveTimeout) {\n          this._delayTouchDeactivate();\n        }\n      };\n      this._disposers.push($utils.addEventListener(window, \"touchstart\", listener, {\n        passive: false\n      }));\n      this._disposers.push($utils.addEventListener(this.view, \"touchstart\", listener, {\n        passive: false\n      }));\n      this._disposers.push($utils.addEventListener(this.view, \"touchmove\", () => {\n        // If touch is moving, delay touch out\n        if (this._touchActiveTimeout) {\n          this._delayTouchDeactivate();\n        }\n      }, {\n        passive: true\n      }));\n      this._disposers.push($utils.addEventListener(window, \"click\", _ev => {\n        this._touchActive = false;\n      }, {\n        passive: true\n      }));\n      this._disposers.push($utils.addEventListener(this.view, \"click\", _ev => {\n        window.setTimeout(() => {\n          this._touchActive = true;\n          this._delayTouchDeactivate();\n        }, 100);\n      }, {\n        passive: true\n      }));\n    }\n    // Prevent scrolling of the window when hovering on \"wheelable\" object\n    if ($utils.supports(\"wheelevents\")) {\n      this._disposers.push($utils.addEventListener(this.view, \"wheel\", ev => {\n        let prevent = false;\n        this._hovering.forEach(obj => {\n          if (obj.wheelable) {\n            prevent = true;\n            return false;\n          }\n        });\n        if (prevent) {\n          ev.preventDefault();\n        }\n      }, {\n        passive: false\n      }));\n    }\n  }\n  _delayTouchDeactivate() {\n    if (this._touchActiveTimeout) {\n      clearTimeout(this._touchActiveTimeout);\n    }\n    if (this.tapToActivateTimeout > 0) {\n      this._touchActiveTimeout = window.setTimeout(() => {\n        this._touchActive = false;\n      }, this.tapToActivateTimeout);\n    }\n  }\n  get debugGhostView() {\n    return !!this._ghostLayer.view.parentNode;\n  }\n  set debugGhostView(value) {\n    if (value) {\n      if (!this._ghostLayer.view.parentNode) {\n        this.view.appendChild(this._ghostLayer.view);\n      }\n    } else {\n      if (this._ghostLayer.view.parentNode) {\n        this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);\n      }\n    }\n  }\n  createLinearGradient(x1, y1, x2, y2) {\n    return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);\n  }\n  createRadialGradient(x1, y1, radius1, x2, y2, radius2) {\n    return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);\n  }\n  createPattern(graphics, background, repetition, width, height) {\n    // const patternCanvas = document.createElement(\"canvas\");\n    // const patternContext = patternCanvas.getContext(\"2d\")!;\n    // patternCanvas.width = width;\n    // patternCanvas.height = height;\n    // if (fill) {\n    // \tpatternContext.fillStyle = fill.toCSS();\n    // \tpatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\n    // }\n    // const layer = {\n    // \tview: patternCanvas,\n    // \tcontext: patternContext,\n    // \tvisible: true,\n    // \torder: 0,\n    // \twidth: width,\n    // \theight: height,\n    // \tdirty: true\n    // };\n    // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);\n    // // patternContext.stroke();\n    // image.targetLayer = layer;\n    // image.render(layer);\n    //this._layerDom.appendChild(patternCanvas);\n    this._patternCanvas.width = width;\n    this._patternCanvas.height = height;\n    this._patternContext.clearRect(0, 0, width, height);\n    // patternCanvas.style.width = width * this.resolution + \"px\";\n    // patternCanvas.style.height = height * this.resolution + \"px\";\n    background.renderDetached(this._patternContext);\n    graphics.renderDetached(this._patternContext);\n    return this._patternContext.createPattern(this._patternCanvas, repetition);\n  }\n  makeContainer() {\n    return new CanvasContainer(this);\n  }\n  makeGraphics() {\n    return new CanvasGraphics(this);\n  }\n  makeText(text, style) {\n    return new CanvasText(this, text, style);\n  }\n  makeTextStyle() {\n    return new CanvasTextStyle();\n  }\n  makeRadialText(text, style) {\n    return new CanvasRadialText(this, text, style);\n  }\n  makePicture(image) {\n    return new CanvasImage(this, image);\n  }\n  resizeLayer(layer) {\n    layer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);\n  }\n  resizeGhost() {\n    this._ghostLayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight) {\n    this._canvasWidth = canvasWidth;\n    this._canvasHeight = canvasHeight;\n    this._domWidth = domWidth;\n    this._domHeight = domHeight;\n    $array.each(this.layers, layer => {\n      if (layer) {\n        layer.dirty = true;\n        this.resizeLayer(layer);\n      }\n    });\n    this.resizeGhost();\n    this.view.style.width = domWidth + \"px\";\n    this.view.style.height = domHeight + \"px\";\n  }\n  createDetachedLayer() {\n    let willReadFrequently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const view = document.createElement(\"canvas\");\n    const context = view.getContext(\"2d\", {\n      willReadFrequently: willReadFrequently\n    });\n    const layer = new CanvasLayer(view, context);\n    view.style.position = \"absolute\";\n    view.style.top = \"0px\";\n    view.style.left = \"0px\";\n    return layer;\n  }\n  getLayerByOrder(order) {\n    const layers = this.layers;\n    const length = layers.length;\n    for (let i = 0; i < length; i++) {\n      const layer = layers[i];\n      if (layer.order == order) {\n        return layer;\n      }\n    }\n  }\n  getLayer(order) {\n    let visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let existingLayer = this.getLayerByOrder(order);\n    if (existingLayer) {\n      return existingLayer;\n    }\n    const layer = this.createDetachedLayer(order == 99);\n    layer.order = order;\n    layer.visible = visible;\n    if (layer.visible) {\n      this.resizeLayer(layer);\n    }\n    const layers = this.layers;\n    layers.push(layer);\n    layers.sort((a, b) => {\n      if (a.order > b.order) {\n        return 1;\n      } else if (a.order < b.order) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    const length = layers.length;\n    const layerIndex = $array.indexOf(layers, layer);\n    let next;\n    for (let i = layerIndex + 1; i < length; i++) {\n      if (layers[i].visible) {\n        next = layers[i];\n        break;\n      }\n    }\n    if (layer.visible) {\n      if (next === undefined) {\n        this._layerDom.appendChild(layer.view);\n      } else {\n        this._layerDom.insertBefore(layer.view, next.view);\n      }\n    }\n    return layer;\n  }\n  render(root) {\n    this._dirtyLayers.length = 0;\n    $array.each(this.layers, layer => {\n      if (layer) {\n        if (layer.dirty && layer.visible) {\n          this._dirtyLayers.push(layer);\n          layer.clear();\n        }\n      }\n    });\n    this._ghostLayer.clear();\n    root.render(this.defaultLayer);\n    this._ghostLayer.context.restore();\n    //setTimeout(() => {\n    // Remove this after the Chrome bug is fixed:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394\n    $array.each(this.layers, layer => {\n      if (layer) {\n        const context = layer.context;\n        context.beginPath();\n        context.moveTo(0, 0);\n        context.stroke();\n      }\n    });\n    $array.each(this._dirtyLayers, layer => {\n      layer.context.restore();\n      layer.dirty = false;\n    });\n    //}, 100)\n    if (this._hovering.size && this._lastPointerMoveEvent) {\n      const {\n        events,\n        target,\n        native\n      } = this._lastPointerMoveEvent;\n      //this._mouseMoveThrottler.run();\n      $array.each(events, event => {\n        this._dispatchGlobalMousemove(event, target, native);\n      });\n    }\n  }\n  paintId(obj) {\n    const id = distributeId(++this._colorId);\n    const color = Color.fromHex(id).toCSS();\n    this._colorMap[color] = obj;\n    return color;\n  }\n  _removeObject(obj) {\n    if (obj._colorId !== undefined) {\n      delete this._colorMap[obj._colorId];\n    }\n  }\n  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {\n  // \treturn this._colorMap[colorId];\n  // }\n  _adjustBoundingBox(bbox) {\n    const margin = this._ghostLayer.margin;\n    return new DOMRect(bbox.left - margin.left, bbox.top - margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);\n  }\n  getEvent(originalEvent) {\n    let adjustPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const bbox = this.view.getBoundingClientRect();\n    const originalPoint = {\n      x: originalEvent.clientX || 0,\n      y: originalEvent.clientY || 0\n    };\n    const point = {\n      x: originalPoint.x - (adjustPoint ? bbox.left : 0),\n      y: originalPoint.y - (adjustPoint ? bbox.top : 0)\n    };\n    return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));\n  }\n  _getHitTarget(point, bbox, target) {\n    if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {\n      return;\n    }\n    if (!target || !this._layerDom.contains(target)) {\n      return;\n    }\n    const pixel = this._ghostLayer.getImageData(point, bbox);\n    if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {\n      return false;\n    }\n    const colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();\n    const hit = this._colorMap[colorId];\n    return hit;\n  }\n  _withEvents(key, f) {\n    const events = this._events[key];\n    if (events !== undefined) {\n      events.dispatching = true;\n      try {\n        f(events);\n      } finally {\n        events.dispatching = false;\n        if (events.cleanup) {\n          events.cleanup = false;\n          $array.keepIf(events.callbacks, callback => {\n            return !callback.disposed;\n          });\n          if (events.callbacks.length === 0) {\n            events.disposer.dispose();\n            delete this._events[key];\n          }\n        }\n      }\n    }\n  }\n  _dispatchEventAll(key, event) {\n    if (!this.interactionsEnabled) {\n      return;\n    }\n    this._withEvents(key, events => {\n      $array.each(events.callbacks, callback => {\n        if (!callback.disposed) {\n          callback.callback.call(callback.context, event);\n        }\n      });\n    });\n  }\n  _dispatchEvent(key, target, event) {\n    if (!this.interactionsEnabled) {\n      return false;\n    }\n    let dispatched = false;\n    this._withEvents(key, events => {\n      $array.each(events.callbacks, callback => {\n        if (!callback.disposed && callback.object === target) {\n          callback.callback.call(callback.context, event);\n          dispatched = true;\n        }\n      });\n    });\n    return dispatched;\n  }\n  _dispatchMousedown(originalEvent, originalTarget) {\n    const button = originalEvent.button;\n    if (button != 0 && button != 2 && button != 1 && button !== undefined) {\n      // Ignore non-primary mouse buttons\n      return;\n    }\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      const id = event.id;\n      let dragged = false;\n      eachTargets(target, obj => {\n        const info = {\n          id: id,\n          value: obj\n        };\n        this._mousedown.push(info);\n        if (!dragged && this._dispatchEvent(\"pointerdown\", obj, event)) {\n          // Only dispatch the first element which matches\n          dragged = true;\n          const has = this._dragging.some(x => {\n            return x.value === obj && x.id === id;\n          });\n          if (!has) {\n            this._dragging.push(info);\n          }\n        }\n        return true;\n      });\n    }\n  }\n  _dispatchGlobalMousemove(originalEvent, originalTarget, native) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    event.native = native;\n    if (target) {\n      this._hovering.forEach(obj => {\n        if (!obj.contains(target)) {\n          this._hovering.delete(obj);\n          if (obj.cursorOverStyle) {\n            $utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle);\n          }\n          this._dispatchEvent(\"pointerout\", obj, event);\n        }\n      });\n      if (event.native) {\n        eachTargets(target, obj => {\n          if (!this._hovering.has(obj)) {\n            this._hovering.add(obj);\n            if (obj.cursorOverStyle) {\n              obj._replacedCursorStyle = $utils.getStyle(document.body, \"cursor\");\n              $utils.setStyle(document.body, \"cursor\", obj.cursorOverStyle);\n            }\n            this._dispatchEvent(\"pointerover\", obj, event);\n          }\n          return true;\n        });\n      }\n      //} else if (target === false) {\n    } else {\n      this._hovering.forEach(obj => {\n        if (obj.cursorOverStyle) {\n          $utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle);\n        }\n        this._dispatchEvent(\"pointerout\", obj, event);\n      });\n      this._hovering.clear();\n    }\n    this._dispatchEventAll(\"globalpointermove\", event);\n  }\n  _dispatchGlobalMouseup(originalEvent, native) {\n    const event = this.getEvent(originalEvent);\n    event.native = native;\n    //const target = this._getHitTarget(event.originalPoint);\n    this._dispatchEventAll(\"globalpointerup\", event);\n  }\n  _dispatchDragMove(originalEvent) {\n    if (this._dragging.length !== 0) {\n      const event = this.getEvent(originalEvent);\n      const id = event.id;\n      this._dragging.forEach(obj => {\n        if (obj.id === id) {\n          this._dispatchEvent(\"pointermove\", obj.value, event);\n        }\n      });\n    }\n  }\n  _dispatchDragEnd(originalEvent, originalTarget) {\n    const button = originalEvent.button;\n    let clickevent;\n    if (button == 0 || button === undefined) {\n      clickevent = \"click\";\n    } else if (button == 2) {\n      clickevent = \"rightclick\";\n    } else if (button == 1) {\n      clickevent = \"middleclick\";\n    } else {\n      // Ignore non-primary mouse buttons\n      return;\n    }\n    const event = this.getEvent(originalEvent);\n    const id = event.id;\n    if (this._mousedown.length !== 0) {\n      const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n      if (target) {\n        this._mousedown.forEach(obj => {\n          if (obj.id === id && obj.value.contains(target)) {\n            this._dispatchEvent(clickevent, obj.value, event);\n          }\n        });\n      }\n      this._mousedown.length = 0;\n    }\n    if (this._dragging.length !== 0) {\n      this._dragging.forEach(obj => {\n        if (obj.id === id) {\n          this._dispatchEvent(\"pointerup\", obj.value, event);\n        }\n      });\n      this._dragging.length = 0;\n    }\n  }\n  _dispatchDoubleClick(originalEvent, originalTarget) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      eachTargets(target, obj => {\n        if (this._dispatchEvent(\"dblclick\", obj, event)) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  }\n  _dispatchWheel(originalEvent, originalTarget) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      eachTargets(target, obj => {\n        if (this._dispatchEvent(\"wheel\", obj, event)) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  }\n  _makeSharedEvent(key, f) {\n    if (this._listeners[key] === undefined) {\n      const listener = f();\n      this._listeners[key] = new CounterDisposer(() => {\n        delete this._listeners[key];\n        listener.dispose();\n      });\n    }\n    return this._listeners[key].increment();\n  }\n  _onPointerEvent(name, f) {\n    let native = false;\n    let timer = null;\n    function clear() {\n      timer = null;\n      native = false;\n    }\n    return new MultiDisposer([new Disposer(() => {\n      if (timer !== null) {\n        clearTimeout(timer);\n      }\n      clear();\n    }), $utils.addEventListener(this.view, $utils.getRendererEvent(name), _ => {\n      native = true;\n      if (timer !== null) {\n        clearTimeout(timer);\n      }\n      timer = window.setTimeout(clear, 0);\n    }), onPointerEvent(window, name, (ev, target) => {\n      if (timer !== null) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      f(ev, target, native);\n      native = false;\n    })]);\n  }\n  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)\n  _initEvent(key) {\n    switch (key) {\n      case \"globalpointermove\":\n      case \"pointerover\":\n      case \"pointerout\":\n        return this._makeSharedEvent(\"pointermove\", () => {\n          const listener = (events, target, native) => {\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n            $array.each(events, event => {\n              this._dispatchGlobalMousemove(event, target, native);\n            });\n          };\n          return new MultiDisposer([this._onPointerEvent(\"pointerdown\", listener), this._onPointerEvent(\"pointermove\", listener)]);\n        });\n      case \"globalpointerup\":\n        return this._makeSharedEvent(\"pointerup\", () => {\n          const mouseup = this._onPointerEvent(\"pointerup\", (events, target, native) => {\n            $array.each(events, event => {\n              this._dispatchGlobalMouseup(event, native);\n            });\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n          });\n          const pointercancel = this._onPointerEvent(\"pointercancel\", (events, target, native) => {\n            $array.each(events, event => {\n              this._dispatchGlobalMouseup(event, native);\n            });\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n          });\n          return new Disposer(() => {\n            mouseup.dispose();\n            pointercancel.dispose();\n          });\n        });\n      case \"click\":\n      case \"rightclick\":\n      case \"middleclick\":\n      case \"pointerdown\":\n      /*\r\n          return this._makeSharedEvent(\"pointerdown\", () => {\r\n              return this._onPointerEvent(\"pointerdown\", (event, target, native) => {\r\n                  this._lastPointerMoveEvent = { event, target, native };\r\n                  this._dispatchMousedown(event)\r\n              });\r\n          });\r\n      */\n      case \"pointermove\":\n      case \"pointerup\":\n        return this._makeSharedEvent(\"pointerdown\", () => {\n          //const throttler = new Throttler();\n          const mousedown = this._onPointerEvent(\"pointerdown\", (events, target) => {\n            $array.each(events, ev => {\n              this._dispatchMousedown(ev, target);\n            });\n          });\n          // TODO handle throttling properly for multitouch\n          const mousemove = this._onPointerEvent(\"pointermove\", ev => {\n            //throttler.throttle(() => {\n            $array.each(ev, ev => {\n              this._dispatchDragMove(ev);\n            });\n            //});\n          });\n\n          const mouseup = this._onPointerEvent(\"pointerup\", (ev, target) => {\n            $array.each(ev, ev => {\n              this._dispatchDragEnd(ev, target);\n            });\n          });\n          const pointercancel = this._onPointerEvent(\"pointercancel\", (ev, target) => {\n            $array.each(ev, ev => {\n              this._dispatchDragEnd(ev, target);\n            });\n          });\n          return new Disposer(() => {\n            mousedown.dispose();\n            mousemove.dispose();\n            mouseup.dispose();\n            pointercancel.dispose();\n          });\n        });\n      case \"dblclick\":\n        return this._makeSharedEvent(\"dblclick\", () => {\n          return this._onPointerEvent(\"dblclick\", (ev, target) => {\n            $array.each(ev, ev => {\n              this._dispatchDoubleClick(ev, target);\n            });\n          });\n        });\n      case \"wheel\":\n        return this._makeSharedEvent(\"wheel\", () => {\n          return $utils.addEventListener(window, $utils.getRendererEvent(\"wheel\"), event => {\n            this._dispatchWheel(event, $utils.getEventTarget(event));\n          }, {\n            passive: false\n          });\n        });\n    }\n  }\n  _addEvent(object, key, callback, context) {\n    let events = this._events[key];\n    if (events === undefined) {\n      events = this._events[key] = {\n        disposer: this._initEvent(key),\n        callbacks: [],\n        dispatching: false,\n        cleanup: false\n      };\n    }\n    const listener = {\n      object,\n      context,\n      callback,\n      disposed: false\n    };\n    events.callbacks.push(listener);\n    return new Disposer(() => {\n      listener.disposed = true;\n      if (events.dispatching) {\n        events.cleanup = true;\n      } else {\n        $array.removeFirst(events.callbacks, listener);\n        if (events.callbacks.length === 0) {\n          events.disposer.dispose();\n          delete this._events[key];\n        }\n      }\n    });\n  }\n  getCanvas(root, options) {\n    // Make sure everything is rendered\n    this.render(root);\n    if (!options) {\n      options = {};\n    }\n    let scale = this.resolution;\n    let canvasWidth = Math.floor(this._canvasWidth * this.resolution);\n    let canvasHeight = Math.floor(this._canvasHeight * this.resolution);\n    // Check if we need to scale\n    if (options.minWidth && options.minWidth > canvasWidth) {\n      let minScale = options.minWidth / canvasWidth;\n      if (minScale > scale) {\n        scale = minScale * this.resolution;\n      }\n    }\n    if (options.minHeight && options.minHeight > canvasHeight) {\n      let minScale = options.minHeight / canvasHeight;\n      if (minScale > scale) {\n        scale = minScale * this.resolution;\n      }\n    }\n    if (options.maxWidth && options.maxWidth < canvasWidth) {\n      let maxScale = options.maxWidth / canvasWidth;\n      if (maxScale < scale) {\n        scale = maxScale * this.resolution;\n      }\n    }\n    if (options.maxHeight && options.maxHeight > canvasHeight) {\n      let maxScale = options.maxHeight / canvasHeight;\n      if (maxScale < scale) {\n        scale = maxScale * this.resolution;\n      }\n    }\n    // Check if we need to compensate for pixel ratio\n    if (options.maintainPixelRatio) {\n      scale /= this.resolution;\n    }\n    // Init list canvases to remove from DOM after export\n    const canvases = [];\n    // Set up new canvas for export\n    let forceRender = false;\n    const canvas = document.createElement(\"canvas\");\n    if (scale != this.resolution) {\n      forceRender = true;\n      canvasWidth = canvasWidth * scale / this.resolution;\n      canvasHeight = canvasHeight * scale / this.resolution;\n    }\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    // Add to DOM so it inherits CSS\n    canvas.style.position = \"fixed\";\n    canvas.style.top = \"-10000px\";\n    this.view.appendChild(canvas);\n    canvases.push(canvas);\n    // Context\n    const context = canvas.getContext(\"2d\");\n    let width = 0;\n    let height = 0;\n    let needRerender = false;\n    $array.each(this.layers, layer => {\n      if (layer && layer.visible) {\n        if (layer.tainted || forceRender) {\n          needRerender = true;\n          layer.exportableView = layer.view;\n          layer.exportableContext = layer.context;\n          layer.view = document.createElement(\"canvas\");\n          // Add to DOM so it inherits CSS\n          layer.view.style.position = \"fixed\";\n          layer.view.style.top = \"-10000px\";\n          this.view.appendChild(layer.view);\n          canvases.push(layer.view);\n          let extraX = 0;\n          let extraY = 0;\n          if (layer.margin) {\n            extraX += layer.margin.left || 0 + layer.margin.right || 0;\n            extraY += layer.margin.top || 0 + layer.margin.bottom || 0;\n          }\n          layer.view.width = canvasWidth + extraX;\n          layer.view.height = canvasHeight + extraY;\n          layer.context = layer.view.getContext(\"2d\");\n          layer.dirty = true;\n          layer.scale = scale;\n        }\n      }\n    });\n    if (needRerender) {\n      this._omitTainted = true;\n      this.render(root);\n      this._omitTainted = false;\n    }\n    $array.each(this.layers, layer => {\n      if (layer && layer.visible) {\n        // Layer is fine. Just plop it into our target canvas\n        let x = 0;\n        let y = 0;\n        if (layer.margin) {\n          x = -(layer.margin.left || 0) * this.resolution;\n          y = -(layer.margin.top || 0) * this.resolution;\n        }\n        context.drawImage(layer.view, x, y);\n        // Restore layer original canvas\n        if (layer.exportableView) {\n          layer.view = layer.exportableView;\n          layer.exportableView = undefined;\n        }\n        if (layer.exportableContext) {\n          layer.context = layer.exportableContext;\n          layer.exportableContext = undefined;\n        }\n        if (width < layer.view.clientWidth) {\n          width = layer.view.clientWidth;\n        }\n        if (height < layer.view.clientHeight) {\n          height = layer.view.clientHeight;\n        }\n        layer.scale = undefined;\n      }\n    });\n    canvas.style.width = width + \"px\";\n    canvas.style.height = height + \"px\";\n    $array.each(canvases, canvas => {\n      canvas.style.position = \"\";\n      canvas.style.top = \"\";\n      this.view.removeChild(canvas);\n    });\n    return canvas;\n  }\n}\nclass GhostLayer {\n  constructor() {\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"margin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    this.view = document.createElement(\"canvas\");\n    this.context = this.view.getContext(\"2d\", {\n      alpha: false,\n      willReadFrequently: true\n    });\n    this.context.imageSmoothingEnabled = false;\n    this.view.style.position = \"absolute\";\n    this.view.style.top = \"0px\";\n    this.view.style.left = \"0px\";\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {\n    canvasWidth += this.margin.left + this.margin.right;\n    canvasHeight += this.margin.top + this.margin.bottom;\n    // TODO this should take into account calculateSize\n    domWidth += this.margin.left + this.margin.right;\n    domHeight += this.margin.top + this.margin.bottom;\n    this.view.style.left = -this.margin.left + \"px\";\n    this.view.style.top = -this.margin.top + \"px\";\n    this._width = Math.floor(canvasWidth * resolution);\n    this._height = Math.floor(canvasHeight * resolution);\n    this.view.width = this._width;\n    this.view.style.width = domWidth + \"px\";\n    this.view.height = this._height;\n    this.view.style.height = domHeight + \"px\";\n  }\n  getImageData(point, bbox) {\n    return this.context.getImageData(\n    // TODO should this round ?\n    Math.round((point.x - bbox.left) / bbox.width * this._width), Math.round((point.y - bbox.top) / bbox.height * this._height), 1, 1);\n  }\n  setMargin(layers) {\n    this.margin.left = 0;\n    this.margin.right = 0;\n    this.margin.top = 0;\n    this.margin.bottom = 0;\n    $array.each(layers, layer => {\n      if (layer.margin) {\n        this.margin.left = Math.max(this.margin.left, layer.margin.left);\n        this.margin.right = Math.max(this.margin.right, layer.margin.right);\n        this.margin.top = Math.max(this.margin.top, layer.margin.top);\n        this.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);\n      }\n    });\n  }\n  clear() {\n    this.context.save();\n    this.context.fillStyle = '#000';\n    this.context.fillRect(0, 0, this._width, this._height);\n  }\n}\n/**\r\n * @ignore\r\n */\nexport class CanvasLayer {\n  constructor(view, context) {\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"margin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"order\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"visible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"scale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"dirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"exportableView\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"exportableContext\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    this.view = view;\n    this.context = context;\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {\n    // TODO should this take into account calculateSize ?\n    if (this.width != null) {\n      canvasWidth = this.width;\n      domWidth = this.width;\n    }\n    // TODO should this take into account calculateSize ?\n    if (this.height != null) {\n      canvasHeight = this.height;\n      domHeight = this.height;\n    }\n    if (this.margin) {\n      canvasWidth += this.margin.left + this.margin.right;\n      canvasHeight += this.margin.top + this.margin.bottom;\n      // TODO this should take into account calculateSize\n      domWidth += this.margin.left + this.margin.right;\n      domHeight += this.margin.top + this.margin.bottom;\n      this.view.style.left = -this.margin.left + \"px\";\n      this.view.style.top = -this.margin.top + \"px\";\n    } else {\n      this.view.style.left = \"0px\";\n      this.view.style.top = \"0px\";\n    }\n    this._width = Math.floor(canvasWidth * resolution);\n    this._height = Math.floor(canvasHeight * resolution);\n    this.view.width = this._width;\n    this.view.style.width = domWidth + \"px\";\n    this.view.height = this._height;\n    this.view.style.height = domHeight + \"px\";\n  }\n  clear() {\n    this.context.save();\n    this.context.clearRect(0, 0, this._width, this._height);\n  }\n}","map":{"version":3,"names":["BlendMode","Color","Matrix","Percent","percent","ArrayDisposer","Disposer","DisposerClass","CounterDisposer","MultiDisposer","TextFormatter","$utils","$array","$object","$type","$math","arcToBezier","checkArgs","name","actual","expected","Error","checkMinArgs","checkEvenArgs","splitArcFlags","args","i","length","index","flag","a","exec","splice","assertBinary","value","distributeId","id","rgb","eachTargets","hitTarget","f","interactive","_parent","onPointerEvent","element","addEventListener","getRendererEvent","event","target","getEventTarget","touches","changedTouches","copy","isTainted","image","canvas","document","createElement","width","height","context","getContext","willReadFrequently","drawImage","getImageData","err","console","warn","src","clearCanvas","view","style","CanvasPivot","constructor","Object","defineProperty","x","_x","y","_y","CanvasDisplayObject","renderer","_renderer","_dispose","_removeObject","getLayer","dirty","getCanvas","self","_layer","defaultLayer","setLayer","order","margin","undefined","visible","setInteractive","_ghostLayer","setMargin","layers","registerChildLayer","resizeLayer","resizeGhost","markDirtyLayer","clear","invalidateBounds","_localBounds","_addBounds","_bounds","_getColorId","_colorId","paintId","_isInteractive","inactive","_forceInteractive","_isInteractiveMask","contains","child","toGlobal","point","_matrix","apply","toLocal","applyInverse","getLocalMatrix","_uMatrix","setTransform","pivot","angle","Math","PI","scale","getLocalBounds","bn","left","top","right","bottom","getAdjustedBounds","bounds","_setMatrix","matrix","p0","p1","p2","p3","min","max","on","key","callback","_addEvent","_localMatrix","copyFrom","prepend","_transform","resolution","m","tx","ty","crisp","floor","b","c","d","_transformMargin","_transformLayer","layer","render","parentLayer","exportable","_omitTainted","ghostLayer","ghostContext","mask","each","save","_runPath","clip","globalAlpha","compoundAlpha","alpha","filter","_render","restore","tainted","hovering","_hovering","has","dragging","_dragging","some","shouldCancelTouch","tapToActivate","_touchActive","cancelTouch","CanvasContainer","interactiveChildren","addChild","_children","push","addChildAt","removeChild","removeFirst","_childLayers","pushOne","deep","arguments","setPoint","Op","colorize","_context","_forceColor","path","addBounds","BeginPath","beginPath","BeginFill","color","forceColor","fillStyle","EndFill","clearShadow","fill","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","EndStroke","stroke","LineStyle","lineJoin","strokeStyle","lineWidth","LineDash","dash","setLineDash","LineDashOffset","dashOffset","lineDashOffset","DrawRect","rect","l","t","r","DrawCircle","radius","moveTo","arc","DrawEllipse","radiusX","radiusY","ellipse","Arc","cx","cy","startAngle","endAngle","anticlockwise","arcBounds","getArcBounds","DEGREES","ArcTo","x1","y1","x2","y2","arcTo","LineTo","lineTo","MoveTo","ClosePath","closePath","BezierCurveTo","cpX","cpY","cpX2","cpY2","toX","toY","bezierCurveTo","QuadraticCurveTo","quadraticCurveTo","Shadow","blur","offsetX","offsetY","opacity","GraphicsImage","CanvasGraphics","NORMAL","_operations","_pushOp","op","beginFill","_fillAlpha","toCSS","isMeasured","endFill","_hasShadows","endStroke","lineStyle","_strokeAlpha","setLineDashOffset","drawRect","drawCircle","drawEllipse","shadow","svgPath","cpx","cpy","qcpx","qcpy","SEGMENTS_REGEXP","ARGS_REGEXP","match","rest","relative","bs","px","py","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","layerDirty","globalCompositeOperation","blendMode","renderDetached","CanvasText","text","_textInfo","_shared","textAlign","direction","textBaseline","_prerender","ignoreGhost","ignoreFontWeight","fontStyle","_getFontStyle","font","fillOpacity","shadowOpacity","style2","fontVariant","fontWeight","fontSize","isNumber","fontFamily","join","_measure","textVisible","line","_index","textChunks","chunk","fillText","textDecoration","thickness","offset","format","getTextStyle","_ignoreFontWeight","test","navigator","vendor","rtl","oversizedBehavior","maxWidth","truncate","wrap","refText","lines","toString","replace","split","styleRestored","minX","maxX","currentStyle","chunks","type","ignoreFormatting","lineInfo","ascent","metrics","_measureText","actualBoundingBoxAscent","actualBoundingBoxDescent","currentFormat","currentDecoration","currentFill","currentChunkWidth","skipFurtherText","firstTextChunk","leftoverChunks","currentVerticalAlign","eachContinue","toNumber","verticalAlign","chunkWidth","actualBoundingBoxLeft","actualBoundingBoxRight","breakWords","ellipsis","ellipsisMetrics","ellipsisWidth","excessWidth","_truncateText","tmpText","slice","trim","unshift","substr","leftBoundMod","rightBoundMod","boundsMod","chunkHeight","lineHeight","currentChunkOffset","baselineRatio","ratio","_fitRatio","minScale","_originalScale","maxW","maxH","maxHeight","w","h","fallbackBreakWords","tmp","measureText","fakeMetrics","div","innerText","visibility","position","body","appendChild","bbox","getBoundingClientRect","fontBoundingBoxAscent","fontBoundingBoxDescent","CanvasTextStyle","CanvasRadialText","textType","_renderCircular","deltaAngle","orientation","inward","inside","align","kerning","clockwise","shouldReverse","_textReversed","maxAngle","midAngle","normalizeAngle","reverse","textHeight","lineStartAngle","rotate","angleShift","char","charWidth","_measureCircular","totalWidth","chars","round","CanvasImage","_imageMask","naturalWidth","naturalHeight","_getMask","imageSmoothingEnabled","fillRect","CanvasRendererEvent","originalPoint","supports","Touch","identifier","CanvasRenderer","GhostLayer","_patternCanvas","Set","window","devicePixelRatio","_layerDom","_disposers","_events","_key","events","disposer","dispose","exportableView","onZoom","listener","ev","item","preventDefault","_touchActiveTimeout","_delayTouchDeactivate","passive","_ev","setTimeout","prevent","forEach","obj","wheelable","clearTimeout","tapToActivateTimeout","debugGhostView","parentNode","createLinearGradient","createRadialGradient","radius1","radius2","createPattern","graphics","background","repetition","_patternContext","clearRect","makeContainer","makeGraphics","makeText","makeTextStyle","makeRadialText","makePicture","resize","_canvasWidth","_canvasHeight","_domWidth","_domHeight","canvasWidth","canvasHeight","domWidth","domHeight","createDetachedLayer","CanvasLayer","getLayerByOrder","existingLayer","sort","layerIndex","indexOf","next","insertBefore","root","_dirtyLayers","size","_lastPointerMoveEvent","native","_dispatchGlobalMousemove","fromHex","_colorMap","_adjustBoundingBox","DOMRect","getEvent","originalEvent","adjustPoint","clientX","clientY","_getHitTarget","pixel","data","colorId","fromRGB","hit","_withEvents","dispatching","cleanup","keepIf","callbacks","disposed","_dispatchEventAll","interactionsEnabled","call","_dispatchEvent","dispatched","object","_dispatchMousedown","originalTarget","button","dragged","info","_mousedown","delete","cursorOverStyle","setStyle","_replacedCursorStyle","add","getStyle","_dispatchGlobalMouseup","_dispatchDragMove","_dispatchDragEnd","clickevent","_dispatchDoubleClick","_dispatchWheel","_makeSharedEvent","_listeners","increment","_onPointerEvent","timer","_","_initEvent","mouseup","pointercancel","mousedown","mousemove","options","minWidth","minHeight","maxScale","maintainPixelRatio","canvases","forceRender","needRerender","exportableContext","extraX","extraY","clientWidth","clientHeight","_width","_height"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\render\\backend\\CanvasRenderer.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport {\n\tIRenderer, IContainer, IDisplayObject, IGraphics, IRendererEvents, IMargin,\n\tIText, ITextStyle, IRadialText, IPicture, IRendererEvent, ILayer, ICanvasOptions, BlendMode, IPointerEvent, Id\n} from \"./Renderer\";\nimport type { IBounds } from \"../../util/IBounds\";\nimport type { IPoint } from \"../../util/IPoint\";\nimport { Color } from \"../../util/Color\";\nimport { Matrix } from \"../../util/Matrix\";\nimport { Percent, percent } from \"../../util/Percent\";\n//import { Throttler } from \"../../util/Throttler\";\nimport { ArrayDisposer, Disposer, DisposerClass, IDisposer, CounterDisposer, MultiDisposer } from \"../../util/Disposer\";\nimport { TextFormatter, ITextChunk } from \"../../util/TextFormatter\";\nimport * as $utils from \"../../util/Utils\";\nimport * as $array from \"../../util/Array\";\nimport * as $object from \"../../util/Object\";\nimport * as $type from \"../../util/Type\";\nimport * as $math from \"../../util/Math\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\n\n\n/**\n * @ignore\n */\nfunction checkArgs(name: string, actual: number, expected: number) {\n\tif (actual !== expected) {\n\t\tthrow new Error(\"Required \" + expected + \" arguments for \" + name + \" but got \" + actual);\n\t}\n}\n\n/**\n * @ignore\n */\nfunction checkMinArgs(name: string, actual: number, expected: number) {\n\tif (actual < expected) {\n\t\tthrow new Error(\"Required at least \" + expected + \" arguments for \" + name + \" but got \" + actual);\n\t}\n}\n\n/**\n * @ignore\n */\nfunction checkEvenArgs(name: string, actual: number, expected: number) {\n\tcheckMinArgs(name, actual, expected);\n\n\tif ((actual % expected) !== 0) {\n\t\tthrow new Error(\"Arguments for \" + name + \" must be in pairs of \" + expected);\n\t}\n}\n\n/**\n * @ignore\n * This splits the flag so that way 0017 will be processed as 0 0 17\n *\n * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`\n */\nfunction splitArcFlags(args: Array<string>) {\n\tfor (let i = 0; i < args.length; i += 7) {\n\t\tlet index = i + 3;\n\t\tlet flag = args[index];\n\n\t\tif (flag.length > 1) {\n\t\t\tconst a = /^([01])([01])(.*)$/.exec(flag);\n\n\t\t\tif (a !== null) {\n\t\t\t\targs.splice(index, 0, a[1]);\n\t\t\t\t++index;\n\n\t\t\t\targs.splice(index, 0, a[2]);\n\t\t\t\t++index;\n\n\t\t\t\tif (a[3].length > 0) {\n\t\t\t\t\targs[index] = a[3];\n\n\t\t\t\t} else {\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++index;\n\n\t\tflag = args[index];\n\n\t\tif (flag.length > 1) {\n\t\t\tconst a = /^([01])(.+)$/.exec(flag);\n\n\t\t\tif (a !== null) {\n\t\t\t\targs.splice(index, 0, a[1]);\n\t\t\t\t++index;\n\n\t\t\t\targs[index] = a[2];\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nfunction assertBinary(value: number): 0 | 1 {\n\tif (value === 0 || value === 1) {\n\t\treturn value;\n\n\t} else {\n\t\tthrow new Error(\"Flag must be 0 or 1\");\n\t}\n}\n\n//  1 -> 0xffffff * (2 / 2)\n//  2 -> 0xffffff * (1 / 2)\n//\n//  3 -> 0xffffff * (3 / 4)\n//  4 -> 0xffffff * (1 / 4)\n//\n//  5 -> 0xffffff * (7 / 8)\n//  6 -> 0xffffff * (5 / 8)\n//  7 -> 0xffffff * (3 / 8)\n//  8 -> 0xffffff * (1 / 8)\n//\n//  9 -> 0xffffff * (15 / 16)\n// 10 -> 0xffffff * (13 / 16)\n// 11 -> 0xffffff * (11 / 16)\n// 12 -> 0xffffff *  (9 / 16)\n// 13 -> 0xffffff *  (7 / 16)\n// 14 -> 0xffffff *  (5 / 16)\n// 15 -> 0xffffff *  (3 / 16)\n// 16 -> 0xffffff *  (1 / 16)\n// @todo remove this old color distribution algo if the new one pans out\n// function distributeIdBAK(id: number): number {\n// \tif (id === 1) {\n// \t\treturn 0x000001;\n\n// \t} else {\n// \t\t// Finds the closest power of 2\n// \t\tconst base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));\n\n// \t\t// Translates the id into an odd fraction index\n// \t\tconst index = ((base - id) * 2) + 1;\n\n// \t\t// TODO is Math.round correct ?\n// \t\treturn Math.round(0xffffff * (index / base));\n// \t}\n// }\n\n/**\n * Function by smeans:\n * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/\n * @ignore\n */\nfunction distributeId(id: number): number {\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 24; i++) {\n\t\trgb[i % 3] <<= 1;\n\t\trgb[i % 3] |= id & 0x01;\n\t\tid >>= 1;\n\t}\n\treturn (rgb[2] | 0) + (rgb[1] << 8) + (rgb[0] << 16);\n}\n\n/**\n * @ignore\n */\nfunction eachTargets(hitTarget: CanvasDisplayObject, f: (target: CanvasDisplayObject) => boolean): void {\n\tfor (; ;) {\n\t\tif (hitTarget.interactive) {\n\t\t\tif (!f(hitTarget)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hitTarget._parent) {\n\t\t\thitTarget = hitTarget._parent;\n\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// TODO feature detection for mouse/touch/pointer\n/**\n * @ignore\n */\nfunction onPointerEvent(element: EventTarget, name: string, f: (event: Array<IPointerEvent>, target: Node | null) => void): IDisposer {\n\treturn $utils.addEventListener(element, $utils.getRendererEvent(name), (event: MouseEvent | TouchEvent) => {\n\t\tconst target = $utils.getEventTarget(event);\n\n\t\tlet touches = (<any>event).touches;\n\t\tif (touches) {\n\t\t\tif (touches.length == 0) {\n\t\t\t\ttouches = (<any>event).changedTouches;\n\t\t\t}\n\n\t\t\tf($array.copy(<TouchList>touches), target);\n\n\t\t} else {\n\t\t\tf([<MouseEvent>event], target);\n\t\t}\n\t});\n}\n\n/**\n * @ignore\n */\nfunction isTainted(image: HTMLImageElement): boolean {\n\tconst canvas = document.createElement(\"canvas\");\n\tcanvas.width = 1;\n\tcanvas.height = 1;\n\tconst context = canvas.getContext(\"2d\", { willReadFrequently: true })! as CanvasRenderingContext2D;\n\tcontext.drawImage(image, 0, 0, 1, 1);\n\n\ttry {\n\t\tcontext.getImageData(0, 0, 1, 1);\n\t\treturn false;\n\t}\n\tcatch (err) {\n\t\tconsole.warn(\"Image \\\"\" + image.src + \"\\\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors\");\n\t\treturn true;\n\t}\n}\n\n/**\n * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.\n *\n * @ignore\n */\nfunction clearCanvas(view: HTMLCanvasElement) {\n\tview.width = 0;\n\tview.height = 0;\n\tview.style.width = \"0px\";\n\tview.style.height = \"0px\";\n}\n\n/**\n * @ignore\n */\nexport class CanvasPivot implements IPoint {\n\tprotected _x: number = 0;\n\tprotected _y: number = 0;\n\n\tget x(): number {\n\t\treturn this._x;\n\t}\n\n\tget y(): number {\n\t\treturn this._y;\n\t}\n\n\tset x(value: number) {\n\t\tthis._x = value;\n\t}\n\n\tset y(value: number) {\n\t\tthis._y = value;\n\t}\n}\n\n/**\n * @ignore\n */\nexport class CanvasDisplayObject extends DisposerClass implements IDisplayObject, IDisposer {\n\tpublic _layer?: CanvasLayer;\n\n\tpublic mask: CanvasGraphics | null = null;\n\tpublic visible: boolean = true;\n\tpublic exportable?: boolean = true;\n\tpublic interactive: boolean = false;\n\tpublic inactive: boolean = false;\n\tpublic wheelable: boolean = false;\n\tpublic cancelTouch: boolean = false;\n\tpublic isMeasured: boolean = false;\n\tpublic buttonMode: boolean = false;\n\tpublic alpha: number = 1;\n\tpublic compoundAlpha: number = 1;\n\tpublic angle: number = 0;\n\tpublic scale: number = 1;\n\tpublic x: number = 0;\n\tpublic y: number = 0;\n\tpublic crisp: boolean = false;\n\tpublic pivot: CanvasPivot = new CanvasPivot();\n\n\tpublic filter?: string;\n\n\tpublic cursorOverStyle?: string;\n\tpublic _replacedCursorStyle?: string;\n\n\tpublic _localMatrix: Matrix = new Matrix();\n\tpublic _matrix: Matrix = new Matrix();\n\t// TODO can this be replaced with _localMatrix ?\n\tprotected _uMatrix: Matrix = new Matrix();\n\n\tpublic _renderer: CanvasRenderer;\n\tpublic _parent: CanvasContainer | undefined;\n\n\tprotected _localBounds: IBounds | undefined;\n\tprotected _bounds: IBounds | undefined;\n\tpublic _colorId: string | undefined;\n\n\tconstructor(renderer: CanvasRenderer) {\n\t\tsuper();\n\t\tthis._renderer = renderer;\n\t}\n\n\tprotected _dispose(): void {\n\t\tthis._renderer._removeObject(this);\n\t\tthis.getLayer().dirty = true;\n\t}\n\n\tpublic getCanvas(): HTMLCanvasElement {\n\t\treturn this.getLayer().view;\n\t}\n\n\tpublic getLayer(): CanvasLayer {\n\t\tlet self: CanvasDisplayObject = this;\n\n\t\tfor (; ;) {\n\t\t\tif (self._layer) {\n\t\t\t\treturn self._layer;\n\n\t\t\t} else if (self._parent) {\n\t\t\t\tself = self._parent;\n\n\t\t\t} else {\n\t\t\t\treturn this._renderer.defaultLayer;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic setLayer(order: number | undefined, margin: IMargin | undefined): void {\n\t\tif (order == null) {\n\t\t\tthis._layer = undefined;\n\n\t\t} else {\n\t\t\tconst visible = true;\n\t\t\tthis._layer = this._renderer.getLayer(order, visible);\n\t\t\tthis._layer.visible = visible;\n\t\t\tthis._layer.margin = margin;\n\t\t\tif (margin) {\n\t\t\t\t$utils.setInteractive(this._layer.view, false);\n\t\t\t}\n\n\t\t\tthis._renderer._ghostLayer.setMargin(this._renderer.layers);\n\n\t\t\tif (this._parent) {\n\t\t\t\tthis._parent.registerChildLayer(this._layer);\n\t\t\t}\n\n\t\t\tthis._layer.dirty = true;\n\t\t\tthis._renderer.resizeLayer(this._layer);\n\t\t\tthis._renderer.resizeGhost();\n\t\t}\n\t}\n\n\tpublic markDirtyLayer(): void {\n\t\tthis.getLayer().dirty = true;\n\t}\n\n\tpublic clear(): void {\n\t\tthis.invalidateBounds();\n\t}\n\n\tpublic invalidateBounds(): void {\n\t\tthis._localBounds = undefined;\n\t}\n\n\tpublic _addBounds(_bounds: IBounds): void { }\n\n\tprotected _getColorId(): string {\n\t\tif (this._colorId === undefined) {\n\t\t\tthis._colorId = this._renderer.paintId(this);\n\t\t}\n\n\t\treturn this._colorId;\n\t}\n\n\tprotected _isInteractive(): boolean {\n\t\treturn this.inactive == false && (this.interactive || this._renderer._forceInteractive > 0);\n\t}\n\n\tprotected _isInteractiveMask(): boolean {\n\t\treturn this._isInteractive();\n\t}\n\n\tpublic contains(child: CanvasDisplayObject): boolean {\n\t\tfor (; ;) {\n\t\t\tif (child === this) {\n\t\t\t\treturn true;\n\n\t\t\t} else if (child._parent) {\n\t\t\t\tchild = child._parent;\n\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\ttoGlobal(point: IPoint): IPoint {\n\t\treturn this._matrix.apply(point);\n\t}\n\n\ttoLocal(point: IPoint): IPoint {\n\t\treturn this._matrix.applyInverse(point);\n\t}\n\n\tpublic getLocalMatrix(): Matrix {\n\t\tthis._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);\n\t\treturn this._uMatrix;\n\t}\n\n\tgetLocalBounds(): IBounds {\n\t\tif (!this._localBounds) {\n\n\t\t\tconst bn = 10000000;\n\t\t\tthis._localBounds = {\n\t\t\t\tleft: bn,\n\t\t\t\ttop: bn,\n\t\t\t\tright: -bn,\n\t\t\t\tbottom: -bn\n\t\t\t};\n\n\t\t\tthis._addBounds(this._localBounds);\n\t\t}\n\t\treturn this._localBounds;\n\t}\n\n\tgetAdjustedBounds(bounds: IBounds): IBounds {\n\t\tthis._setMatrix();\n\n\t\tconst matrix = this.getLocalMatrix();\n\n\t\tconst p0 = matrix.apply({ x: bounds.left, y: bounds.top });\n\t\tconst p1 = matrix.apply({ x: bounds.right, y: bounds.top });\n\t\tconst p2 = matrix.apply({ x: bounds.right, y: bounds.bottom });\n\t\tconst p3 = matrix.apply({ x: bounds.left, y: bounds.bottom });\n\n\t\treturn {\n\t\t\tleft: Math.min(p0.x, p1.x, p2.x, p3.x),\n\t\t\ttop: Math.min(p0.y, p1.y, p2.y, p3.y),\n\t\t\tright: Math.max(p0.x, p1.x, p2.x, p3.x),\n\t\t\tbottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n\t\t}\n\t}\n\n\ton<C, Key extends keyof IRendererEvents>(key: Key, callback: (this: C, event: IRendererEvents[Key]) => void, context?: C): IDisposer {\n\t\tif (this.interactive) {\n\t\t\treturn this._renderer._addEvent(this, key, callback, context);\n\n\t\t} else {\n\t\t\treturn new Disposer(() => { });\n\t\t}\n\t}\n\n\tpublic _setMatrix(): void {\n\t\t// TODO only calculate this if it has actually changed\n\t\tthis._localMatrix.setTransform(\n\t\t\tthis.x,\n\t\t\tthis.y,\n\t\t\tthis.pivot.x,\n\t\t\tthis.pivot.y,\n\t\t\t// Converts degrees to radians\n\t\t\tthis.angle * Math.PI / 180,\n\t\t\tthis.scale\n\t\t);\n\n\t\tthis._matrix.copyFrom(this._localMatrix);\n\n\t\tif (this._parent) {\n\t\t\t// TODO only calculate this if it has actually changed\n\t\t\tthis._matrix.prepend(this._parent._matrix);\n\t\t}\n\t}\n\n\tpublic _transform(context: CanvasRenderingContext2D, resolution: number): void {\n\t\tconst m = this._matrix;\n\t\tlet tx = m.tx * resolution;\n\t\tlet ty = m.ty * resolution;\n\t\tif (this.crisp) {\n\t\t\ttx = Math.floor(tx) + .5;\n\t\t\tty = Math.floor(ty) + .5;\n\t\t}\n\n\t\tcontext.setTransform(\n\t\t\tm.a * resolution,\n\t\t\tm.b * resolution,\n\t\t\tm.c * resolution,\n\t\t\tm.d * resolution,\n\t\t\ttx,\n\t\t\tty)\n\n\t}\n\n\tpublic _transformMargin(context: CanvasRenderingContext2D, resolution: number, margin: IMargin): void {\n\t\tconst m = this._matrix;\n\t\tcontext.setTransform(\n\t\t\tm.a * resolution,\n\t\t\tm.b * resolution,\n\t\t\tm.c * resolution,\n\t\t\tm.d * resolution,\n\t\t\t(m.tx + margin.left) * resolution,\n\t\t\t(m.ty + margin.top) * resolution\n\t\t);\n\t}\n\n\tpublic _transformLayer(context: CanvasRenderingContext2D, resolution: number, layer: CanvasLayer): void {\n\t\tif (layer.margin) {\n\t\t\tthis._transformMargin(context, layer.scale || resolution, layer.margin);\n\n\t\t} else {\n\t\t\tthis._transform(context, layer.scale || resolution);\n\t\t}\n\t}\n\n\tpublic render(parentLayer: CanvasLayer): void {\n\t\tif (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {\n\t\t\tthis._setMatrix();\n\n\t\t\tconst resolution = this._renderer.resolution;\n\n\t\t\tconst layers = this._renderer.layers;\n\t\t\tconst ghostLayer = this._renderer._ghostLayer;\n\t\t\tconst ghostContext = ghostLayer.context;\n\n\t\t\tconst mask = this.mask;\n\t\t\tif (mask) {\n\t\t\t\tmask._setMatrix();\n\t\t\t}\n\n\t\t\t// TODO improve this\n\t\t\t$array.each(layers, (layer) => {\n\t\t\t\tif (layer) {\n\t\t\t\t\tconst context = layer.context;\n\t\t\t\t\tcontext.save();\n\n\t\t\t\t\t// We must apply the mask before we transform the element\n\t\t\t\t\tif (mask) {\n\t\t\t\t\t\tmask._transformLayer(context, resolution, layer);\n\t\t\t\t\t\tmask._runPath(context);\n\t\t\t\t\t\tcontext.clip();\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.globalAlpha = this.compoundAlpha * this.alpha;\n\n\t\t\t\t\tthis._transformLayer(context, resolution, layer);\n\n\t\t\t\t\tif (this.filter) {\n\t\t\t\t\t\tcontext.filter = this.filter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tghostContext.save();\n\n\t\t\t// We must apply the mask before we transform the element\n\t\t\tif (mask && this._isInteractiveMask()) {\n\t\t\t\tmask._transformMargin(ghostContext, resolution, ghostLayer.margin);\n\t\t\t\tmask._runPath(ghostContext);\n\t\t\t\tghostContext.clip();\n\t\t\t}\n\n\t\t\tthis._transformMargin(ghostContext, resolution, ghostLayer.margin);\n\n\t\t\tthis._render(parentLayer);\n\n\t\t\tghostContext.restore();\n\n\t\t\t$array.each(layers, (layer) => {\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.context.restore();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _render(parentLayer: CanvasLayer): void {\n\t\tif (this.exportable === false) {\n\t\t\tconst layer = this._layer || parentLayer;\n\t\t\tlayer.tainted = true;\n\t\t}\n\t}\n\n\thovering(): boolean {\n\t\treturn this._renderer._hovering.has(this);\n\t}\n\n\tdragging(): boolean {\n\t\treturn this._renderer._dragging.some((x) => x.value === this);\n\t}\n\n\n\tpublic shouldCancelTouch(): boolean {\n\t\tconst renderer = this._renderer;\n\t\tif (renderer.tapToActivate && !renderer._touchActive) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.cancelTouch) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this._parent) {\n\t\t\treturn this._parent.shouldCancelTouch();\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasContainer extends CanvasDisplayObject implements IContainer {\n\tpublic interactiveChildren: boolean = true;\n\tprivate _childLayers?: CanvasLayer[];\n\n\tprotected _children: Array<CanvasDisplayObject> = [];\n\n\tprotected _isInteractiveMask(): boolean {\n\t\treturn this.interactiveChildren || super._isInteractiveMask();\n\t}\n\n\taddChild(child: CanvasDisplayObject): void {\n\t\tchild._parent = this;\n\t\tthis._children.push(child);\n\t\tif (child._layer) {\n\t\t\tthis.registerChildLayer(child._layer);\n\t\t}\n\t}\n\n\taddChildAt(child: CanvasDisplayObject, index: number): void {\n\t\tchild._parent = this;\n\t\tthis._children.splice(index, 0, child);\n\t\tif (child._layer) {\n\t\t\tthis.registerChildLayer(child._layer);\n\t\t}\n\t}\n\n\tremoveChild(child: CanvasDisplayObject): void {\n\t\tchild._parent = undefined;\n\t\t$array.removeFirst(this._children, child);\n\t}\n\n\tprotected _render(parentLayer: CanvasLayer): void {\n\t\tsuper._render(parentLayer);\n\n\t\tconst renderer = this._renderer;\n\n\t\tif (this.interactive && this.interactiveChildren) {\n\t\t\t++renderer._forceInteractive;\n\t\t}\n\n\t\tconst layer = this._layer || parentLayer;\n\n\t\t$array.each(this._children, (child) => {\n\t\t\tchild.compoundAlpha = this.compoundAlpha * this.alpha;\n\t\t\tchild.render(layer);\n\t\t});\n\n\t\tif (this.interactive && this.interactiveChildren) {\n\t\t\t--renderer._forceInteractive;\n\t\t}\n\t}\n\n\tregisterChildLayer(layer: CanvasLayer): void {\n\t\tif (!this._childLayers) {\n\t\t\tthis._childLayers = [];\n\t\t}\n\t\t$array.pushOne(this._childLayers, layer);\n\t\tif (this._parent) {\n\t\t\tthis._parent.registerChildLayer(layer);\n\t\t}\n\t}\n\n\tpublic markDirtyLayer(deep: boolean = false): void {\n\t\tsuper.markDirtyLayer();\n\t\tif (deep && this._childLayers) {\n\t\t\t$array.each(this._childLayers, (layer) => layer.dirty = true);\n\t\t}\n\t}\n\n\tprotected _dispose() {\n\t\tsuper._dispose();\n\t\tif (this._childLayers) {\n\t\t\t$array.each(this._childLayers, (layer) => {\n\t\t\t\tlayer.dirty = true;\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nfunction setPoint(bounds: IBounds, point: IPoint): void {\n\tbounds.left = Math.min(bounds.left, point.x);\n\tbounds.top = Math.min(bounds.top, point.y);\n\tbounds.right = Math.max(bounds.right, point.x);\n\tbounds.bottom = Math.max(bounds.bottom, point.y);\n}\n\n/**\n * @ignore\n */\nabstract class Op {\n\tpublic colorize(_context: CanvasRenderingContext2D, _forceColor: string | undefined): void { }\n\n\tpublic path(_context: CanvasRenderingContext2D): void { }\n\n\tpublic addBounds(_bounds: IBounds): void { }\n}\n\n/**\n * @ignore\n */\nclass BeginPath extends Op {\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.beginPath();\n\t}\n}\n\n/**\n * @ignore\n */\nclass BeginFill extends Op {\n\tconstructor(public color: string | CanvasGradient | CanvasPattern) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, forceColor: string | undefined): void {\n\t\tif (forceColor !== undefined) {\n\t\t\tcontext.fillStyle = forceColor;\n\n\t\t} else {\n\t\t\tcontext.fillStyle = this.color;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nclass EndFill extends Op {\n\tconstructor(public clearShadow: boolean) { super(); }\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.fill();\n\t\tif (this.clearShadow) {\n\t\t\tcontext.shadowColor = \"\";\n\t\t\tcontext.shadowBlur = 0;\n\t\t\tcontext.shadowOffsetX = 0;\n\t\t\tcontext.shadowOffsetY = 0;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nclass EndStroke extends Op {\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.stroke();\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineStyle extends Op {\n\tconstructor(public width: number, public color: string | CanvasGradient | CanvasPattern, public lineJoin?: \"miter\" | \"round\" | \"bevel\") { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, forceColor: string | undefined): void {\n\t\tif (forceColor !== undefined) {\n\t\t\tcontext.strokeStyle = forceColor;\n\n\t\t} else {\n\t\t\tcontext.strokeStyle = this.color;\n\t\t}\n\n\t\tcontext.lineWidth = this.width;\n\t\tif (this.lineJoin) {\n\t\t\tcontext.lineJoin = this.lineJoin;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineDash extends Op {\n\tconstructor(public dash: number[]) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.setLineDash(this.dash);\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineDashOffset extends Op {\n\tconstructor(public dashOffset: number) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tcontext.lineDashOffset = this.dashOffset;\n\t}\n}\n\n/**\n * @ignore\n */\nclass DrawRect extends Op {\n\tconstructor(public x: number, public y: number, public width: number, public height: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.rect(this.x, this.y, this.width, this.height);\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tconst l = this.x;\n\t\tconst t = this.y;\n\t\tconst r = l + this.width;\n\t\tconst b = t + this.height;\n\n\t\tsetPoint(bounds, { x: l, y: t });\n\t\tsetPoint(bounds, { x: r, y: t });\n\t\tsetPoint(bounds, { x: l, y: b });\n\t\tsetPoint(bounds, { x: r, y: b });\n\t}\n}\n\n/**\n * @ignore\n */\nclass DrawCircle extends Op {\n\tconstructor(public x: number, public y: number, public radius: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.moveTo(this.x + this.radius, this.y);\n\t\tcontext.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n\t}\n\n\t// TODO handle skewing and rotation\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x - this.radius, y: this.y - this.radius });\n\t\tsetPoint(bounds, { x: this.x + this.radius, y: this.y + this.radius });\n\t}\n}\n\n/**\n * @ignore\n */\nclass DrawEllipse extends Op {\n\tconstructor(public x: number, public y: number, public radiusX: number, public radiusY: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);\n\t}\n\n\t// TODO handle skewing and rotation\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x - this.radiusX, y: this.y - this.radiusY });\n\t\tsetPoint(bounds, { x: this.x + this.radiusX, y: this.y + this.radiusY });\n\t}\n}\n\n/**\n * @ignore\n */\nclass Arc extends Op {\n\tconstructor(\n\t\tpublic cx: number,\n\t\tpublic cy: number,\n\t\tpublic radius: number,\n\t\tpublic startAngle: number,\n\t\tpublic endAngle: number,\n\t\tpublic anticlockwise: boolean,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tif (this.radius > 0) {\n\t\t\tcontext.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n\t\t}\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tlet arcBounds = $math.getArcBounds(this.cx, this.cy, this.startAngle * $math.DEGREES, this.endAngle * $math.DEGREES, this.radius);\n\t\tsetPoint(bounds, { x: arcBounds.left, y: arcBounds.top });\n\t\tsetPoint(bounds, { x: arcBounds.right, y: arcBounds.bottom });\n\t}\n}\n\n/**\n * @ignore\n */\nclass ArcTo extends Op {\n\tconstructor(\n\t\tpublic x1: number,\n\t\tpublic y1: number,\n\t\tpublic x2: number,\n\t\tpublic y2: number,\n\t\tpublic radius: number,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tif (this.radius > 0) {\n\t\t\tcontext.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n\t\t}\n\t}\n\n\t// TODO: add points\n\tpublic addBounds(_bounds: IBounds): void {\n\t\t/*\n\t\t// not finished\n\t\thttps://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically\n\n\t\tif (prevPoint) {\n\t\t\tlet x1 = prevPoint.x;\n\t\t\tlet y1 = prevPoint.y;\n\t\t\tlet x2 = this.x2;\n\t\t\tlet y2 = this.y2;\n\t\t\tlet r = this.radius;\n\n\t\t\tlet xa = (x2 - x1) / 2;\n\t\t\tlet ya = (y2 - y1) / 2;\n\n\t\t\tlet x0 = x1 + xa;\n\t\t\tlet y0 = y1 + ya;\n\n\t\t\tlet a = Math.hypot(xa, ya);\n\t\t\tlet b = Math.sqrt(r * r - a * a);\n\n\t\t\tlet cx = x0 + b * ya / a;\n\t\t\tlet cy = y0 - b * xa / a;\n\n\t\t\tconsole.log(cx, cy);\n\t\t}*/\n\t}\n}\n\n/**\n * @ignore\n */\nclass LineTo extends Op {\n\tconstructor(public x: number, public y: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.lineTo(this.x, this.y);\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x, y: this.y });\n\t}\n}\n\n/**\n * @ignore\n */\nclass MoveTo extends Op {\n\tconstructor(public x: number, public y: number) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.moveTo(this.x, this.y);\n\t}\n\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x, y: this.y });\n\t}\n}\n\n/**\n * @ignore\n */\nclass ClosePath extends Op {\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.closePath();\n\t}\n}\n\n/**\n * @ignore\n */\nclass BezierCurveTo extends Op {\n\tconstructor(\n\t\tpublic cpX: number,\n\t\tpublic cpY: number,\n\t\tpublic cpX2: number,\n\t\tpublic cpY2: number,\n\t\tpublic toX: number,\n\t\tpublic toY: number,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);\n\t}\n\n\t// TODO: OK?\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.cpX, y: this.cpY });\n\t\tsetPoint(bounds, { x: this.cpX2, y: this.cpY2 });\n\t\tsetPoint(bounds, { x: this.toX, y: this.toY });\n\t}\n}\n\n/**\n * @ignore\n */\nclass QuadraticCurveTo extends Op {\n\tconstructor(\n\t\tpublic cpX: number,\n\t\tpublic cpY: number,\n\t\tpublic toX: number,\n\t\tpublic toY: number,\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);\n\t}\n\n\t// TODO: OK?\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.cpX, y: this.cpY });\n\t\tsetPoint(bounds, { x: this.toX, y: this.toY });\n\t}\n}\n\n/**\n * @ignore\n */\nclass Shadow extends Op {\n\tconstructor(\n\t\tpublic color: string,\n\t\tpublic blur: number,\n\t\tpublic offsetX: number,\n\t\tpublic offsetY: number,\n\t\tpublic opacity?: number\n\t) { super(); }\n\n\tpublic colorize(context: CanvasRenderingContext2D, _forceColor: string | undefined): void {\n\t\tif (this.opacity) {\n\t\t\tcontext.fillStyle = this.color;\n\t\t}\n\t\tcontext.shadowColor = this.color;\n\t\tcontext.shadowBlur = this.blur;\n\t\tcontext.shadowOffsetX = this.offsetX;\n\t\tcontext.shadowOffsetY = this.offsetY;\n\t}\n}\n\n/**\n * @ignore\n */\nclass GraphicsImage extends Op {\n\tconstructor(\n\t\tpublic image: HTMLImageElement,\n\t\tpublic width: number,\n\t\tpublic height: number,\n\t\tpublic x: number,\n\t\tpublic y: number\n\t) { super(); }\n\n\tpublic path(context: CanvasRenderingContext2D): void {\n\t\tcontext.drawImage(this.image, this.x, this.y, this.width, this.height);\n\t}\n\n\t// TODO: OK?\n\tpublic addBounds(bounds: IBounds): void {\n\t\tsetPoint(bounds, { x: this.x, y: this.y });\n\t\tsetPoint(bounds, { x: this.width, y: this.height });\n\t}\n}\n\n/**\n * @ignore\n */\nexport class CanvasGraphics extends CanvasDisplayObject implements IGraphics {\n\tprotected _operations: Array<Op> = [];\n\n\tpublic blendMode: BlendMode = BlendMode.NORMAL;\n\n\tprotected _hasShadows: boolean = false;\n\tprotected _fillAlpha?: number;\n\tprotected _strokeAlpha?: number;\n\n\tclear(): void {\n\t\tsuper.clear();\n\t\tthis._operations.length = 0;\n\t}\n\n\tprotected _pushOp(op: Op): void {\n\t\tthis._operations.push(op);\n\t}\n\n\tbeginFill(color?: Color | CanvasGradient | CanvasPattern, alpha: number = 1): void {\n\t\tthis._fillAlpha = alpha;\n\t\tif (color) {\n\t\t\tif (color instanceof Color) {\n\t\t\t\tthis._pushOp(new BeginFill(color.toCSS(alpha)));\n\n\t\t\t} else {\n\t\t\t\tthis.isMeasured = true;\n\t\t\t\tthis._pushOp(new BeginFill(color));\n\t\t\t}\n\t\t} else {\n\t\t\tthis._pushOp(new BeginFill(\"rgba(0, 0, 0, \" + alpha + \")\"));\n\t\t}\n\t}\n\n\tendFill(): void {\n\t\tthis._pushOp(new EndFill(this._hasShadows));\n\t}\n\n\tendStroke(): void {\n\t\tthis._pushOp(new EndStroke());\n\t}\n\n\tbeginPath(): void {\n\t\tthis._pushOp(new BeginPath());\n\t}\n\n\tlineStyle(width: number = 0, color?: Color | CanvasGradient | CanvasPattern, alpha: number = 1, lineJoin?: \"miter\" | \"round\" | \"bevel\"): void {\n\t\tthis._strokeAlpha = alpha;\n\t\tif (color) {\n\t\t\tif (color instanceof Color) {\n\t\t\t\tthis._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));\n\t\t\t} else {\n\t\t\t\tthis._pushOp(new LineStyle(width, color, lineJoin));\n\t\t\t}\n\t\t} else {\n\t\t\tthis._pushOp(new LineStyle(width, \"rgba(0, 0, 0, \" + alpha + \")\", lineJoin));\n\t\t}\n\t}\n\n\tsetLineDash(dash?: number[]): void {\n\t\tthis._pushOp(new LineDash(dash ? dash : []));\n\t}\n\n\tsetLineDashOffset(dashOffset: number = 0): void {\n\t\tthis._pushOp(new LineDashOffset(dashOffset));\n\t}\n\n\tdrawRect(x: number, y: number, width: number, height: number): void {\n\t\tthis._pushOp(new DrawRect(x, y, width, height));\n\t}\n\n\tdrawCircle(x: number, y: number, radius: number): void {\n\t\tthis._pushOp(new DrawCircle(x, y, radius));\n\t}\n\n\tdrawEllipse(x: number, y: number, radiusX: number, radiusY: number): void {\n\t\tthis._pushOp(new DrawEllipse(x, y, radiusX, radiusY));\n\t}\n\n\tarc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise: boolean = false): void {\n\t\tthis._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));\n\t}\n\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void {\n\t\tthis._pushOp(new ArcTo(x1, y1, x2, y2, radius));\n\t}\n\n\tlineTo(x: number, y: number): void {\n\t\tthis._pushOp(new LineTo(x, y));\n\t}\n\n\tmoveTo(x: number, y: number): void {\n\t\tthis._pushOp(new MoveTo(x, y));\n\t}\n\n\tbezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): void {\n\t\tthis._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));\n\t}\n\n\tquadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): void {\n\t\tthis._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));\n\t}\n\n\tclosePath(): void {\n\t\tthis._pushOp(new ClosePath());\n\t}\n\n\tshadow(color: Color, blur: number = 0, offsetX: number = 0, offsetY: number = 0, opacity?: number): void {\n\t\tthis._hasShadows = true;\n\t\tthis._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));\n\t}\n\n\timage(image: HTMLImageElement, width: number, height: number, x: number, y: number): void {\n\t\tthis._pushOp(new GraphicsImage(image, width, height, x, y));\n\t}\n\n\t// https://svgwg.org/svg2-draft/paths.html#DProperty\n\t// TODO better error checking\n\tsvgPath(path: string): void {\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tlet cpx: number | null = null;\n\t\tlet cpy: number | null = null;\n\t\tlet qcpx: number | null = null;\n\t\tlet qcpy: number | null = null;\n\n\t\tconst SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;\n\t\tconst ARGS_REGEXP = /[\\u0009\\u0020\\u000A\\u000C\\u000D]*([\\+\\-]?[0-9]*\\.?[0-9]+(?:[eE][\\+\\-]?[0-9]+)?)[\\u0009\\u0020\\u000A\\u000C\\u000D]*,?/g;\n\n\t\tlet match;\n\n\t\twhile ((match = SEGMENTS_REGEXP.exec(path)) !== null) {\n\t\t\tconst name = match[1];\n\t\t\tconst rest = match[2];\n\n\t\t\tconst args: Array<string> = [];\n\n\t\t\twhile ((match = ARGS_REGEXP.exec(rest)) !== null) {\n\t\t\t\targs.push(match[1]);\n\t\t\t}\n\n\t\t\t// Reset control point\n\t\t\tif (name !== \"S\" && name !== \"s\" && name !== \"C\" && name !== \"c\") {\n\t\t\t\tcpx = null;\n\t\t\t\tcpy = null;\n\t\t\t}\n\n\t\t\t// Reset control point\n\t\t\tif (name !== \"Q\" && name !== \"q\" && name !== \"T\" && name !== \"t\") {\n\t\t\t\tqcpx = null;\n\t\t\t\tqcpy = null;\n\t\t\t}\n\n\t\t\tswitch (name) {\n\t\t\t\tcase \"M\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tx = +args[0];\n\t\t\t\t\ty = +args[1];\n\t\t\t\t\tthis.moveTo(x, y);\n\n\t\t\t\t\tfor (let i = 2; i < args.length; i += 2) {\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\ty = +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"m\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tx += +args[0];\n\t\t\t\t\ty += +args[1];\n\t\t\t\t\tthis.moveTo(x, y);\n\n\t\t\t\t\tfor (let i = 2; i < args.length; i += 2) {\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\ty += +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"L\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\ty = +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"l\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\ty += +args[i + 1];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"H\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"h\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"V\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\ty = +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\tcheckMinArgs(name, args.length, 1);\n\t\t\t\t\tfor (let i = 0; i < args.length; ++i) {\n\t\t\t\t\t\ty += +args[i];\n\t\t\t\t\t\tthis.lineTo(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"C\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 6);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 6) {\n\t\t\t\t\t\tconst x1 = +args[i];\n\t\t\t\t\t\tconst y1 = +args[i + 1];\n\t\t\t\t\t\tcpx = +args[i + 2];\n\t\t\t\t\t\tcpy = +args[i + 3];\n\t\t\t\t\t\tx = +args[i + 4];\n\t\t\t\t\t\ty = +args[i + 5];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"c\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 6);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 6) {\n\t\t\t\t\t\tconst x1 = +args[i] + x;\n\t\t\t\t\t\tconst y1 = +args[i + 1] + y;\n\t\t\t\t\t\tcpx = +args[i + 2] + x;\n\t\t\t\t\t\tcpy = +args[i + 3] + y;\n\t\t\t\t\t\tx += +args[i + 4];\n\t\t\t\t\t\ty += +args[i + 5];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"S\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tif (cpx === null || cpy === null) {\n\t\t\t\t\t\tcpx = x;\n\t\t\t\t\t\tcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tconst x1 = 2 * x - cpx;\n\t\t\t\t\t\tconst y1 = 2 * y - cpy;\n\t\t\t\t\t\tcpx = +args[i];\n\t\t\t\t\t\tcpy = +args[i + 1];\n\t\t\t\t\t\tx = +args[i + 2];\n\t\t\t\t\t\ty = +args[i + 3];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"s\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tif (cpx === null || cpy === null) {\n\t\t\t\t\t\tcpx = x;\n\t\t\t\t\t\tcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tconst x1 = 2 * x - cpx;\n\t\t\t\t\t\tconst y1 = 2 * y - cpy;\n\t\t\t\t\t\tcpx = +args[i] + x;\n\t\t\t\t\t\tcpy = +args[i + 1] + y;\n\t\t\t\t\t\tx += +args[i + 2];\n\t\t\t\t\t\ty += +args[i + 3];\n\t\t\t\t\t\tthis.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Q\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tqcpx = +args[i];\n\t\t\t\t\t\tqcpy = +args[i + 1];\n\t\t\t\t\t\tx = +args[i + 2];\n\t\t\t\t\t\ty = +args[i + 3];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"q\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 4);\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 4) {\n\t\t\t\t\t\tqcpx = +args[i] + x;\n\t\t\t\t\t\tqcpy = +args[i + 1] + y;\n\t\t\t\t\t\tx += +args[i + 2];\n\t\t\t\t\t\ty += +args[i + 3];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"T\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tif (qcpx === null || qcpy === null) {\n\t\t\t\t\t\tqcpx = x;\n\t\t\t\t\t\tqcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tqcpx = 2 * x - qcpx;\n\t\t\t\t\t\tqcpy = 2 * y - qcpy;\n\t\t\t\t\t\tx = +args[i];\n\t\t\t\t\t\ty = +args[i + 1];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"t\":\n\t\t\t\t\tcheckEvenArgs(name, args.length, 2);\n\t\t\t\t\tif (qcpx === null || qcpy === null) {\n\t\t\t\t\t\tqcpx = x;\n\t\t\t\t\t\tqcpy = y;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 2) {\n\t\t\t\t\t\tqcpx = 2 * x - qcpx;\n\t\t\t\t\t\tqcpy = 2 * y - qcpy;\n\t\t\t\t\t\tx += +args[i];\n\t\t\t\t\t\ty += +args[i + 1];\n\t\t\t\t\t\tthis.quadraticCurveTo(qcpx, qcpy, x, y);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"A\":\n\t\t\t\tcase \"a\":\n\t\t\t\t\tconst relative = (name === \"a\");\n\n\t\t\t\t\tsplitArcFlags(args);\n\t\t\t\t\tcheckEvenArgs(name, args.length, 7);\n\n\t\t\t\t\tfor (let i = 0; i < args.length; i += 7) {\n\t\t\t\t\t\tlet cx = +args[i + 5];\n\t\t\t\t\t\tlet cy = +args[i + 6];\n\n\t\t\t\t\t\tif (relative) {\n\t\t\t\t\t\t\tcx += x;\n\t\t\t\t\t\t\tcy += y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst bs = arcToBezier({\n\t\t\t\t\t\t\tpx: x,\n\t\t\t\t\t\t\tpy: y,\n\t\t\t\t\t\t\trx: +args[i],\n\t\t\t\t\t\t\try: +args[i + 1],\n\t\t\t\t\t\t\txAxisRotation: +args[i + 2],\n\t\t\t\t\t\t\tlargeArcFlag: assertBinary(+args[i + 3]),\n\t\t\t\t\t\t\tsweepFlag: assertBinary(+args[i + 4]),\n\t\t\t\t\t\t\tcx,\n\t\t\t\t\t\t\tcy,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t$array.each(bs, (b) => {\n\t\t\t\t\t\t\tthis.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);\n\t\t\t\t\t\t\tx = b.x;\n\t\t\t\t\t\t\ty = b.y;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Z\":\n\t\t\t\tcase \"z\":\n\t\t\t\t\tcheckArgs(name, args.length, 0);\n\t\t\t\t\tthis.closePath();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _runPath(context: CanvasRenderingContext2D): void {\n\t\tcontext.beginPath();\n\n\t\t$array.each(this._operations, (op) => {\n\t\t\top.path(context);\n\t\t});\n\t}\n\n\tprotected _render(parentLayer: CanvasLayer): void {\n\t\tsuper._render(parentLayer);\n\n\t\tconst layer = this._layer || parentLayer;\n\n\t\tconst layerDirty = layer.dirty;\n\t\tconst interactive = this._isInteractive();\n\n\t\tif (layerDirty || interactive) {\n\n\t\t\tconst context = layer.context;\n\t\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t\tif (layerDirty) {\n\t\t\t\tcontext.globalCompositeOperation = this.blendMode;\n\n\t\t\t\tcontext.beginPath();\n\t\t\t}\n\n\t\t\tlet color: string | undefined;\n\n\t\t\tif (interactive) {\n\t\t\t\tghostContext.beginPath();\n\t\t\t\tcolor = this._getColorId();\n\t\t\t}\n\n\t\t\t$array.each(this._operations, (op) => {\n\t\t\t\tif (layerDirty) {\n\t\t\t\t\top.path(context);\n\t\t\t\t\top.colorize(context, undefined);\n\t\t\t\t}\n\n\t\t\t\tif (interactive) {\n\t\t\t\t\top.path(ghostContext);\n\t\t\t\t\top.colorize(ghostContext, color);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic renderDetached(context: CanvasRenderingContext2D): void {\n\t\tif (this.visible) {\n\t\t\tthis._setMatrix();\n\n\t\t\tcontext.save();\n\n\t\t\t// We must apply the mask before we transform the element\n\t\t\tconst mask = this.mask;\n\t\t\tif (mask) {\n\t\t\t\tmask._setMatrix();\n\t\t\t\tmask._transform(context, 1);\n\t\t\t\tmask._runPath(context);\n\t\t\t\tcontext.clip();\n\t\t\t}\n\n\t\t\t// TODO handle compoundAlpha somehow ?\n\t\t\tcontext.globalAlpha = this.compoundAlpha * this.alpha;\n\n\t\t\tthis._transform(context, 1);\n\n\t\t\tif (this.filter) {\n\t\t\t\tcontext.filter = this.filter;\n\t\t\t}\n\n\t\t\tcontext.globalCompositeOperation = this.blendMode;\n\n\t\t\tcontext.beginPath();\n\n\t\t\t$array.each(this._operations, (op) => {\n\t\t\t\top.path(context);\n\t\t\t\top.colorize(context, undefined);\n\t\t\t});\n\n\t\t\tcontext.restore();\n\t\t}\n\t}\n\n\tpublic _addBounds(bounds: IBounds): void {\n\t\tif (this.visible && this.isMeasured) {\n\t\t\t$array.each(this._operations, (op) => {\n\t\t\t\top.addBounds(bounds);\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\ninterface ILineChunk {\n\tstyle: string | undefined,\n\tfill: Color | undefined,\n\ttext: string,\n\twidth: number,\n\theight: number,\n\tleft: number,\n\tright: number,\n\tascent: number,\n\toffsetX: number,\n\toffsetY: number,\n\ttextDecoration: string | undefined,\n\tverticalAlign?: \"baseline\" | \"sub\" | \"super\"\n}\n\n/**\n * @ignore\n */\ninterface ILine {\n\toffsetY: number,\n\tascent: number,\n\twidth: number,\n\theight: number,\n\tleft: number,\n\tright: number,\n\ttextChunks: Array<ILineChunk>,\n}\n\n/**\n * @ignore\n */\nexport class CanvasText extends CanvasDisplayObject implements IText {\n\tpublic text: string;\n\tpublic style: CanvasTextStyle;\n\tpublic resolution: number = 1;\n\tpublic textVisible: boolean = true;\n\n\tprotected _textInfo: Array<ILine> | undefined;\n\tprotected _originalScale?: number = 1;\n\n\tconstructor(renderer: CanvasRenderer, text: string, style: CanvasTextStyle) {\n\t\tsuper(renderer);\n\t\tthis.text = text;\n\t\tthis.style = style;\n\t}\n\n\tpublic invalidateBounds(): void {\n\t\tsuper.invalidateBounds();\n\t\tthis._textInfo = undefined;\n\t}\n\n\tprivate _shared(context: CanvasRenderingContext2D) {\n\t\tif (this.style.textAlign) {\n\t\t\tcontext.textAlign = this.style.textAlign;\n\t\t}\n\n\t\tif (this.style.direction) {\n\t\t\tcontext.direction = this.style.direction;\n\t\t}\n\n\t\tif (this.style.textBaseline) {\n\t\t\tcontext.textBaseline = this.style.textBaseline;\n\t\t}\n\n\t}\n\n\tprotected _prerender(layer: CanvasLayer, ignoreGhost = false, ignoreFontWeight = false): void {\n\t\tsuper._render(layer);\n\n\t\tconst context = layer.context;\n\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t// Font style\n\n\t\tconst style = this.style;\n\t\tlet fontStyle = this._getFontStyle(undefined, ignoreFontWeight);\n\n\t\tcontext.font = fontStyle;\n\t\tif (this._isInteractive() && !ignoreGhost) {\n\t\t\tghostContext.font = fontStyle;\n\t\t}\n\n\t\t// Other parameters\n\t\tif (style.fill) {\n\t\t\tif (style.fill instanceof Color) {\n\t\t\t\tcontext.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);\n\t\t\t} else {\n\t\t\t\tcontext.fillStyle = style.fill;\n\t\t\t}\n\t\t}\n\n\t\tif (style.shadowColor) {\n\t\t\tlayer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);\n\t\t}\n\t\tif (style.shadowBlur) {\n\t\t\tlayer.context.shadowBlur = style.shadowBlur;\n\t\t}\n\t\tif (style.shadowOffsetX) {\n\t\t\tlayer.context.shadowOffsetX = style.shadowOffsetX;\n\t\t}\n\t\tif (style.shadowOffsetY) {\n\t\t\tlayer.context.shadowOffsetY = style.shadowOffsetY;\n\t\t}\n\n\t\tthis._shared(context);\n\n\t\tif (this._isInteractive() && !ignoreGhost) {\n\t\t\tghostContext.fillStyle = this._getColorId();\n\t\t\tthis._shared(ghostContext);\n\t\t}\n\t}\n\n\tprotected _getFontStyle(style2?: ITextStyle, ignoreFontWeight = false): string {\n\n\t\t// Process defaults\n\t\tconst style = this.style;\n\t\tlet fontStyle: string[] = [];\n\n\t\tif (style2 && style2.fontVariant) {\n\t\t\tfontStyle.push(style2.fontVariant);\n\t\t}\n\t\telse if (style.fontVariant) {\n\t\t\tfontStyle.push(style.fontVariant);\n\t\t}\n\n\t\tif (!ignoreFontWeight) {\n\t\t\tif (style2 && style2.fontWeight) {\n\t\t\t\tfontStyle.push(style2.fontWeight);\n\t\t\t}\n\t\t\telse if (style.fontWeight) {\n\t\t\t\tfontStyle.push(style.fontWeight);\n\t\t\t}\n\t\t}\n\n\t\tif (style2 && style2.fontStyle) {\n\t\t\tfontStyle.push(style2.fontStyle);\n\t\t}\n\t\telse if (style.fontStyle) {\n\t\t\tfontStyle.push(style.fontStyle);\n\t\t}\n\n\t\tif (style2 && style2.fontSize) {\n\t\t\tif ($type.isNumber(style2.fontSize)) {\n\t\t\t\tstyle2.fontSize = style2.fontSize + \"px\";\n\t\t\t}\n\t\t\tfontStyle.push(style2.fontSize);\n\t\t}\n\t\telse if (style.fontSize) {\n\t\t\tif ($type.isNumber(style.fontSize)) {\n\t\t\t\tstyle.fontSize = style.fontSize + \"px\";\n\t\t\t}\n\t\t\tfontStyle.push(style.fontSize);\n\t\t}\n\n\t\tif (style2 && style2.fontFamily) {\n\t\t\tfontStyle.push(style2.fontFamily);\n\t\t}\n\t\telse if (style.fontFamily) {\n\t\t\tfontStyle.push(style.fontFamily);\n\t\t}\n\t\telse if (fontStyle.length) {\n\t\t\tfontStyle.push(\"Arial\");\n\t\t}\n\n\t\treturn fontStyle.join(\" \");\n\t}\n\n\tprotected _render(parentLayer: CanvasLayer): void {\n\t\tconst layer = this._layer || parentLayer;\n\n\t\t// We need measurements in order to properly position text for alignment\n\t\tif (!this._textInfo) {\n\t\t\tthis._measure(layer);\n\t\t}\n\n\t\tif (this.textVisible) {\n\n\t\t\tconst interactive = this._isInteractive();\n\t\t\tconst context = layer.context;\n\t\t\tconst layerDirty = layer.dirty;\n\t\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t\tcontext.save();\n\t\t\tghostContext.save();\n\t\t\tthis._prerender(layer);\n\n\t\t\t// const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n\t\t\t// const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;\n\n\t\t\t// Process text info produced by _measure()\n\t\t\t$array.each(this._textInfo!, (line, _index) => {\n\t\t\t\t$array.each(line.textChunks, (chunk, _index) => {\n\n\t\t\t\t\t// Set style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tghostContext.save();\n\n\t\t\t\t\t\tcontext.font = chunk.style;\n\t\t\t\t\t\tif (this._isInteractive()) {\n\t\t\t\t\t\t\tghostContext.font = chunk.style;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.fillStyle = chunk.fill.toCSS();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw text\n\t\t\t\t\tif (layerDirty) {\n\t\t\t\t\t\tcontext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw underline\n\t\t\t\t\tif (chunk.textDecoration == \"underline\" || chunk.textDecoration == \"line-through\") {\n\n\t\t\t\t\t\tlet thickness = 1;\n\t\t\t\t\t\tlet offset = 1;\n\t\t\t\t\t\tlet fontSize = chunk.height;\n\n\t\t\t\t\t\tlet offsetX = chunk.offsetX;\n\t\t\t\t\t\tswitch (this.style.textAlign) {\n\t\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\toffsetX -= chunk.width;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\t\toffsetX -= chunk.width / 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\t\tconst format = TextFormatter.getTextStyle(chunk.style);\n\t\t\t\t\t\t\tswitch (format.fontWeight) {\n\t\t\t\t\t\t\t\tcase \"bolder\":\n\t\t\t\t\t\t\t\tcase \"bold\":\n\t\t\t\t\t\t\t\tcase \"700\":\n\t\t\t\t\t\t\t\tcase \"800\":\n\t\t\t\t\t\t\t\tcase \"900\":\n\t\t\t\t\t\t\t\t\tthickness = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (fontSize) {\n\t\t\t\t\t\t\toffset = fontSize / 20;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet y: number;\n\n\t\t\t\t\t\tif (chunk.textDecoration == \"line-through\") {\n\t\t\t\t\t\t\ty = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ty = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\t\tcontext.strokeStyle = chunk.fill.toCSS();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.style.fill && this.style.fill instanceof Color) {\n\t\t\t\t\t\t\tcontext.strokeStyle = this.style.fill.toCSS();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontext.lineWidth = thickness * offset;\n\t\t\t\t\t\tcontext.moveTo(offsetX, y);\n\t\t\t\t\t\tcontext.lineTo(offsetX + chunk.width, y);\n\t\t\t\t\t\tcontext.stroke();\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (interactive && this.interactive) {\n\t\t\t\t\t\t// Draw text in ghost canvas ONLY if it is set as interactive\n\t\t\t\t\t\t// explicitly. This way we avoid hit test anomalies caused by anti\n\t\t\t\t\t\t// aliasing of text.\n\t\t\t\t\t\tghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcontext.restore();\n\t\t\tghostContext.restore();\n\t\t}\n\t}\n\n\tpublic _addBounds(bounds: IBounds): void {\n\t\tif (this.visible && this.isMeasured) {\n\t\t\t//if (this._textVisible) {\n\t\t\tconst x = this._measure(this.getLayer());\n\t\t\tsetPoint(bounds, { x: x.left, y: x.top });\n\t\t\tsetPoint(bounds, { x: x.right, y: x.bottom });\n\t\t\t//}\n\t\t}\n\t}\n\n\tprotected _ignoreFontWeight(): boolean {\n\t\treturn /apple/i.test(navigator.vendor);\n\t}\n\n\tpublic _measure(layer: CanvasLayer): IBounds {\n\t\tconst context = layer.context;\n\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\t\tconst rtl = this.style.direction == \"rtl\";\n\n\t\t// Reset text info\n\t\tthis._textInfo = [];\n\n\t\t// Init\n\t\tconst oversizedBehavior = this.style.oversizedBehavior;\n\t\tconst maxWidth = this.style.maxWidth!;\n\n\t\tconst truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n\t\tconst wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n\n\t\t// Pre-render\n\t\tcontext.save();\n\t\tghostContext.save();\n\t\tthis._prerender(layer, true, this._ignoreFontWeight());\n\n\t\t// Get default font metrix\n\t\tconst refText = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\n\n\t\t// Split up text into lines\n\t\tconst lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n\t\tlet styleRestored = true;\n\t\tlet minX = 0;\n\t\tlet maxX = 0;\n\n\t\t// Iterate through the lines\n\t\tlet offsetY = 0;\n\t\tlet currentStyle: string | undefined;\n\t\t$array.each(lines, (line, _index) => {\n\n\t\t\t// Split up line into format/value chunks\n\t\t\tlet chunks: ITextChunk[];\n\t\t\tif (line == \"\") {\n\t\t\t\tchunks = [{\n\t\t\t\t\ttype: \"value\",\n\t\t\t\t\ttext: \"\"\n\t\t\t\t}];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n\t\t\t}\n\n\t\t\twhile (chunks.length > 0) {\n\n\t\t\t\t// Init line object\n\t\t\t\tlet lineInfo: ILine = {\n\t\t\t\t\toffsetY: offsetY,\n\t\t\t\t\tascent: 0,\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttextChunks: []\n\t\t\t\t};\n\n\t\t\t\t// Measure reference text\n\t\t\t\tconst metrics = this._measureText(refText, context);\n\n\t\t\t\tconst height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\t\t\t\tlineInfo.height = height;\n\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\n\t\t\t\tlet currentFormat: string;\n\t\t\t\tlet currentDecoration: string | undefined = this.style.textDecoration;\n\t\t\t\tlet currentFill: Color | undefined;\n\t\t\t\tlet currentChunkWidth: number | undefined;\n\t\t\t\tlet skipFurtherText = false;\n\t\t\t\tlet firstTextChunk = true;\n\t\t\t\tlet leftoverChunks: Array<ITextChunk> = [];\n\t\t\t\tlet currentVerticalAlign: \"baseline\" | \"sub\" | \"super\" | undefined;\n\t\t\t\t//let offsetX = 0;\n\t\t\t\t//let chunk;\n\n\t\t\t\t//while(chunk = chunks.shift()) {\n\t\t\t\t$array.eachContinue(chunks, (chunk, index) => {\n\n\t\t\t\t\t// Format chunk\n\t\t\t\t\tif (chunk.type == \"format\") {\n\t\t\t\t\t\tif (chunk.text == \"[/]\") {\n\t\t\t\t\t\t\tif (!styleRestored) {\n\t\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t\t\t\tstyleRestored = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrentFill = undefined;\n\t\t\t\t\t\t\tcurrentStyle = undefined;\n\t\t\t\t\t\t\tcurrentChunkWidth = undefined;\n\t\t\t\t\t\t\tcurrentDecoration = this.style.textDecoration;\n\t\t\t\t\t\t\tcurrentVerticalAlign = undefined\n\t\t\t\t\t\t\tcurrentFormat = chunk.text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\tif (!styleRestored) {\n\t\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet format = TextFormatter.getTextStyle(chunk.text);\n\t\t\t\t\t\t\tconst fontStyle = this._getFontStyle(format);\n\t\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\t\tghostContext.save();\n\t\t\t\t\t\t\tcontext.font = fontStyle;\n\t\t\t\t\t\t\tcurrentStyle = fontStyle;\n\t\t\t\t\t\t\tcurrentFormat = chunk.text;\n\t\t\t\t\t\t\tif (format.textDecoration) {\n\t\t\t\t\t\t\t\tcurrentDecoration = format.textDecoration;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (format.fill) {\n\t\t\t\t\t\t\t\tcurrentFill = <Color>format.fill;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((<any>format).width) {\n\t\t\t\t\t\t\t\tcurrentChunkWidth = $type.toNumber((<any>format).width);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (format.verticalAlign) {\n\t\t\t\t\t\t\t\tcurrentVerticalAlign = format.verticalAlign;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstyleRestored = false;\n\n\t\t\t\t\t\t\t// Measure reference text after change of format\n\t\t\t\t\t\t\tconst metrics = this._measureText(refText, context);\n\t\t\t\t\t\t\tconst height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\t\t\t\t\t\t\tif (height > lineInfo.height) {\n\t\t\t\t\t\t\t\tlineInfo.height = height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n\t\t\t\t\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Text chunk\n\t\t\t\t\telse if (chunk.type == \"value\" && !skipFurtherText) {\n\n\t\t\t\t\t\t// Measure\n\t\t\t\t\t\tconst metrics = this._measureText(chunk.text, context);\n\t\t\t\t\t\tlet chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n\n\t\t\t\t\t\t// Check for fit\n\t\t\t\t\t\tif (truncate) {\n\n\t\t\t\t\t\t\t// Break words?\n\t\t\t\t\t\t\tlet breakWords = firstTextChunk || this.style.breakWords || false;\n\n\t\t\t\t\t\t\t// Measure ellipsis and check if it fits\n\t\t\t\t\t\t\tconst ellipsis = this.style.ellipsis || \"\";\n\t\t\t\t\t\t\tconst ellipsisMetrics = this._measureText(ellipsis, context);\n\t\t\t\t\t\t\tconst ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n\n\t\t\t\t\t\t\t// Check fit\n\t\t\t\t\t\t\tif ((lineInfo.width + chunkWidth) > maxWidth) {\n\t\t\t\t\t\t\t\tconst excessWidth = maxWidth - lineInfo.width - ellipsisWidth;\n\t\t\t\t\t\t\t\tchunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);\n\t\t\t\t\t\t\t\tchunk.text += ellipsis;\n\t\t\t\t\t\t\t\tskipFurtherText = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (wrap) {\n\t\t\t\t\t\t\t// Check fit\n\t\t\t\t\t\t\tif ((lineInfo.width + chunkWidth) > maxWidth) {\n\t\t\t\t\t\t\t\tconst excessWidth = maxWidth - lineInfo.width;\n\t\t\t\t\t\t\t\tconst tmpText = this._truncateText(\n\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\tchunk.text,\n\t\t\t\t\t\t\t\t\texcessWidth,\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t(firstTextChunk && this.style.oversizedBehavior != \"wrap-no-break\")\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (tmpText == \"\") {\n\t\t\t\t\t\t\t\t\t// Unable to fit a single letter - hide the whole label\n\t\t\t\t\t\t\t\t\tthis.textVisible = true;\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//skipFurtherText = true;\n\n\t\t\t\t\t\t\t\t//Add remaining chunks for the next line\n\t\t\t\t\t\t\t\tleftoverChunks = chunks.slice(index + 1);\n\n\t\t\t\t\t\t\t\t//Add remaining text of current chunk if it was forced-cut\n\t\t\t\t\t\t\t\tif ($utils.trim(tmpText) != $utils.trim(chunk.text)) {\n\t\t\t\t\t\t\t\t\tleftoverChunks.unshift({\n\t\t\t\t\t\t\t\t\t\ttype: \"value\",\n\t\t\t\t\t\t\t\t\t\ttext: chunk.text.substr(tmpText.length)\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (currentFormat) {\n\t\t\t\t\t\t\t\t\t\tleftoverChunks.unshift({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"format\",\n\t\t\t\t\t\t\t\t\t\t\ttext: currentFormat\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set current chunk (truncated)\n\t\t\t\t\t\t\t\tchunk.text = $utils.trim(tmpText);\n\n\t\t\t\t\t\t\t\tchunks = [];\n\t\t\t\t\t\t\t\tskipFurtherText = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Chunk width?\n\t\t\t\t\t\tlet leftBoundMod = 1;\n\t\t\t\t\t\tlet rightBoundMod = 1;\n\t\t\t\t\t\tif (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {\n\t\t\t\t\t\t\t// increase horizontal bounding boxes accordingly\n\t\t\t\t\t\t\tconst boundsMod = chunkWidth / currentChunkWidth\n\t\t\t\t\t\t\tswitch (this.style.textAlign) {\n\t\t\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\t\t\tleftBoundMod = boundsMod;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\t\t\tleftBoundMod = boundsMod;\n\t\t\t\t\t\t\t\t\trightBoundMod = boundsMod;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\trightBoundMod = boundsMod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkWidth = currentChunkWidth;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\n\n\t\t\t\t\t\tif (chunkHeight > lineInfo.height) {\n\t\t\t\t\t\t\tlineInfo.height = chunkHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n\t\t\t\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlineInfo.width += chunkWidth;\n\t\t\t\t\t\tlineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;\n\t\t\t\t\t\tlineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;\n\t\t\t\t\t\tlineInfo.textChunks.push({\n\t\t\t\t\t\t\tstyle: currentStyle,\n\t\t\t\t\t\t\tfill: currentFill,\n\t\t\t\t\t\t\ttext: chunk.text,\n\t\t\t\t\t\t\twidth: chunkWidth,\n\t\t\t\t\t\t\theight: chunkHeight,\n\t\t\t\t\t\t\tleft: metrics.actualBoundingBoxLeft,\n\t\t\t\t\t\t\tright: metrics.actualBoundingBoxRight,\n\t\t\t\t\t\t\tascent: metrics.actualBoundingBoxAscent,\n\t\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\t\toffsetY: 0,\n\t\t\t\t\t\t\ttextDecoration: currentDecoration,\n\t\t\t\t\t\t\tverticalAlign: currentVerticalAlign\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t//offsetX += chunkWidth;\n\n\t\t\t\t\t\tfirstTextChunk = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (leftoverChunks) {\n\t\t\t\t\t\t//return false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t\t//}\n\t\t\t\t});\n\n\t\t\t\tif (this.style.lineHeight instanceof Percent) {\n\t\t\t\t\tlineInfo.height *= this.style.lineHeight.value;\n\t\t\t\t\tlineInfo.ascent *= this.style.lineHeight.value;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlineInfo.height *= this.style.lineHeight || 1.2;\n\t\t\t\t\tlineInfo.ascent *= this.style.lineHeight || 1.2;\n\t\t\t\t}\n\n\t\t\t\tif (minX < lineInfo.left) {\n\t\t\t\t\tminX = lineInfo.left;\n\t\t\t\t}\n\n\t\t\t\tif (maxX < lineInfo.right) {\n\t\t\t\t\tmaxX = lineInfo.right;\n\t\t\t\t}\n\n\t\t\t\tthis._textInfo!.push(lineInfo);\n\n\t\t\t\t//lineInfo.offsetY += lineInfo.ascent;\n\t\t\t\toffsetY += lineInfo.height;\n\n\t\t\t\t// Reset chunks so that it can proceed to the next line\n\t\t\t\tchunks = leftoverChunks || [];\n\t\t\t}\n\n\t\t});\n\n\t\tif (!styleRestored) {\n\t\t\tcontext.restore();\n\t\t\tghostContext.restore();\n\t\t}\n\n\t\t// Adjust chunk internal offsets\n\t\t$array.each(this._textInfo, (lineInfo, _index: number) => {\n\t\t\tlet currentChunkOffset = 0\n\t\t\t$array.each(lineInfo.textChunks, (chunk) => {\n\t\t\t\tchunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;\n\t\t\t\tchunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);\n\t\t\t\tcurrentChunkOffset += chunk.width;\n\n\t\t\t\tif (chunk.verticalAlign) {\n\t\t\t\t\tswitch (chunk.verticalAlign) {\n\t\t\t\t\t\tcase \"super\":\n\t\t\t\t\t\t\tchunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"sub\":\n\t\t\t\t\t\t\tchunk.offsetY += chunk.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tconst bounds = {\n\t\t\tleft: rtl ? -maxX : -minX,\n\t\t\ttop: 0,\n\t\t\tright: rtl ? minX : maxX,\n\t\t\tbottom: offsetY,\n\t\t};\n\n\n\t\t// We need to fit?\n\t\tif (oversizedBehavior !== \"none\") {\n\t\t\tconst ratio = this._fitRatio(bounds);\n\t\t\tif (ratio < 1) {\n\t\t\t\tif (oversizedBehavior == \"fit\") {\n\t\t\t\t\tif ($type.isNumber(this.style.minScale) && (ratio < this.style.minScale)) {\n\t\t\t\t\t\tthis.textVisible = false;\n\t\t\t\t\t\tbounds.left = 0;\n\t\t\t\t\t\tbounds.top = 0;\n\t\t\t\t\t\tbounds.right = 0;\n\t\t\t\t\t\tbounds.bottom = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this._originalScale || this._originalScale == 1) {\n\t\t\t\t\t\t\tthis._originalScale = this.scale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.scale = ratio;\n\t\t\t\t\t\tthis.textVisible = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (oversizedBehavior == \"hide\") {\n\t\t\t\t\tthis.textVisible = false;\n\t\t\t\t\tbounds.left = 0;\n\t\t\t\t\tbounds.top = 0;\n\t\t\t\t\tbounds.right = 0;\n\t\t\t\t\tbounds.bottom = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tswitch (this.style.textAlign) {\n\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\t\tbounds.left = -maxWidth;\n\t\t\t\t\t\t\tbounds.right = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\t\tbounds.left = -maxWidth / 2;\n\t\t\t\t\t\t\tbounds.right = maxWidth / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbounds.left = 0;\n\t\t\t\t\t\t\tbounds.right = maxWidth;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.scale = this._originalScale || 1;\n\t\t\t\t\tthis._originalScale = undefined;\n\t\t\t\t\tthis.textVisible = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.scale = this._originalScale || 1;\n\t\t\t\tthis._originalScale = undefined;\n\t\t\t\tthis.textVisible = true;\n\t\t\t}\n\t\t}\n\n\t\tcontext.restore();\n\t\tghostContext.restore();\n\n\t\treturn bounds;\n\t}\n\n\tprotected _fitRatio(bounds: IBounds): number {\n\t\tconst maxW = this.style.maxWidth;\n\t\tconst maxH = this.style.maxHeight;\n\t\tif (!$type.isNumber(maxW) && !$type.isNumber(maxH)) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst w = bounds.right - bounds.left;\n\t\tconst h = bounds.bottom - bounds.top;\n\t\treturn Math.min(maxW! / w || 1, maxH! / h || 1);\n\t}\n\n\tprotected _truncateText(context: CanvasRenderingContext2D, text: string, maxWidth: number, breakWords: boolean = false, fallbackBreakWords: boolean = true): string {\n\t\tlet width: number;\n\t\tdo {\n\t\t\tif (breakWords) {\n\t\t\t\ttext = text.slice(0, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet tmp = text.replace(/[^,;:!?\\\\\\/\\s]+[,;:!?\\\\\\/\\s]*$/g, \"\");\n\t\t\t\tif (tmp == \"\" && fallbackBreakWords) {\n\t\t\t\t\tbreakWords = true;\n\t\t\t\t}\n\t\t\t\telse if (tmp == \"\") {\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttext = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst metrics = this._measureText(text, context);\n\t\t\twidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n\t\t} while ((width > maxWidth) && text != \"\");\n\t\treturn text;\n\t}\n\n\tprotected _measureText(text: string, context: CanvasRenderingContext2D): TextMetrics {\n\t\tlet metrics = context.measureText(text);\n\t\tlet fakeMetrics: any = {};\n\t\tif (metrics.actualBoundingBoxAscent == null) {\n\t\t\tconst div = document.createElement(\"div\");\n\t\t\tdiv.innerText = text;\n\t\t\tdiv.style.visibility = \"hidden\";\n\t\t\tdiv.style.position = \"absolute\";\n\t\t\tdiv.style.top = \"-1000000px;\"\n\t\t\tdiv.style.fontFamily = this.style.fontFamily || \"\";\n\t\t\tdiv.style.fontSize = this.style.fontSize + \"\";\n\t\t\tdocument.body.appendChild(div);\n\t\t\tconst bbox = div.getBoundingClientRect();\n\t\t\tdocument.body.removeChild(div);\n\t\t\tconst h = bbox.height;\n\t\t\tconst w = metrics.width;\n\t\t\tlet left = 0;\n\t\t\tlet right = w;\n\n\t\t\tfakeMetrics = {\n\t\t\t\tactualBoundingBoxAscent: h,\n\t\t\t\tactualBoundingBoxDescent: 0,\n\t\t\t\tactualBoundingBoxLeft: left,\n\t\t\t\tactualBoundingBoxRight: right,\n\t\t\t\tfontBoundingBoxAscent: h,\n\t\t\t\tfontBoundingBoxDescent: 0,\n\t\t\t\twidth: w\n\t\t\t}\n\t\t\t//return fake;\n\t\t}\n\t\telse {\n\t\t\tfakeMetrics = {\n\t\t\t\tactualBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n\t\t\t\tactualBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n\t\t\t\tactualBoundingBoxLeft: metrics.actualBoundingBoxLeft,\n\t\t\t\tactualBoundingBoxRight: metrics.actualBoundingBoxRight,\n\t\t\t\tfontBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n\t\t\t\tfontBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n\t\t\t\twidth: metrics.width\n\t\t\t}\n\t\t}\n\n\t\tconst w = metrics.width;\n\t\tswitch (this.style.textAlign) {\n\t\t\tcase \"right\":\n\t\t\tcase \"end\":\n\t\t\t\tfakeMetrics.actualBoundingBoxLeft = w;\n\t\t\t\tfakeMetrics.actualBoundingBoxRight = 0;\n\t\t\t\tbreak;\n\t\t\tcase \"center\":\n\t\t\t\tfakeMetrics.actualBoundingBoxLeft = w / 2;\n\t\t\t\tfakeMetrics.actualBoundingBoxRight = w / 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfakeMetrics.actualBoundingBoxLeft = 0;\n\t\t\t\tfakeMetrics.actualBoundingBoxRight = w;\n\t\t}\n\n\t\treturn fakeMetrics;\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasTextStyle implements ITextStyle {\n\t//public wordWrapWidth: number = 100;\n\tpublic fill?: Color | CanvasGradient | CanvasPattern;\n\tpublic fillOpacity?: number;\n\tpublic textAlign?: \"start\" | \"end\" | \"left\" | \"right\" | \"center\";\n\tpublic fontFamily?: string;\n\tpublic fontSize?: string | number;\n\tpublic fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'\n\tpublic fontStyle?: 'normal' | 'italic' | 'oblique';\n\tpublic fontVariant?: \"normal\" | \"small-caps\";\n\tpublic textDecoration?: \"underline\" | \"line-through\";\n\tpublic shadowColor?: Color | null;\n\tpublic shadowBlur?: number;\n\tpublic shadowOffsetX?: number;\n\tpublic shadowOffsetY?: number;\n\tpublic shadowOpacity?: number;\n\t// leading?: number;\n\t// letterSpacing?: number;\n\tpublic lineHeight?: number | Percent = percent(120);\n\tpublic baselineRatio?: number = 0.19;\n\t// padding?: number;\n\t// stroke?: number;\n\t// strokeThickness?: number;\n\t// trim?: number;\n\t// wordWrap?: boolean;\n\tpublic direction?: \"ltr\" | \"rtl\";\n\tpublic textBaseline?: \"top\" | \"hanging\" | \"middle\" | \"alphabetic\" | \"ideographic\" | \"bottom\";\n\tpublic oversizedBehavior?: \"none\" | \"hide\" | \"fit\" | \"wrap\" | \"wrap-no-break\" | \"truncate\" = \"none\";\n\tpublic breakWords?: boolean = false;\n\tpublic ellipsis?: string = \"…\";\n\tpublic maxWidth?: number;\n\tpublic maxHeight?: number;\n\tpublic minScale?: number;\n\tpublic ignoreFormatting?: boolean = false;\n}\n\n/**\n * @ignore\n */\nexport class CanvasRadialText extends CanvasText implements IRadialText {\n\tpublic textType?: \"regular\" | \"circular\" | \"radial\" | \"aligned\" | \"adjusted\" = \"circular\";\n\tpublic radius?: number;\n\tpublic startAngle?: number;\n\tpublic inside?: boolean = false;\n\tpublic orientation?: \"inward\" | \"outward\" | \"auto\" = \"auto\";\n\tpublic kerning?: number = 0;\n\n\tprivate _textReversed: boolean = false;\n\n\tpublic _render(parentLayer: CanvasLayer): void {\n\t\tswitch (this.textType) {\n\t\t\tcase \"circular\":\n\t\t\t\tthis._renderCircular(parentLayer);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsuper._render(parentLayer);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic _renderCircular(parentLayer: CanvasLayer): void {\n\t\tif (this.textVisible) {\n\t\t\tconst layer = this._layer || parentLayer;\n\n\t\t\tthis._prerender(layer);\n\n\t\t\tconst interactive = this._isInteractive();\n\t\t\tconst context = layer.context;\n\t\t\tconst layerDirty = layer.dirty;\n\t\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\n\t\t\t// Savepoint\n\t\t\tcontext.save();\n\t\t\tif (interactive) {\n\t\t\t\tghostContext.save();\n\t\t\t}\n\n\t\t\t// We need measurements in order to properly position text for alignment\n\t\t\tif (!this._textInfo) {\n\t\t\t\tthis._measure(layer);\n\t\t\t}\n\n\t\t\t// Init\n\t\t\tlet radius = (this.radius || 0);\n\t\t\tlet startAngle = (this.startAngle || 0);\n\t\t\tlet deltaAngle = 0;\n\t\t\tlet orientation = this.orientation;\n\t\t\tlet inward = orientation == \"auto\" ? \"auto\" : orientation == \"inward\";\n\t\t\tconst inside = this.inside;\n\t\t\tconst align = this.style.textAlign || \"left\";\n\t\t\tconst kerning = this.kerning || 0;\n\t\t\tlet clockwise = align == \"left\" ? 1 : -1;\n\t\t\tconst shouldReverse = !this._textReversed;\n\n\t\t\t// Check if we need to invert the whole stuff\n\t\t\tif (inward == \"auto\") {\n\t\t\t\t// Calc max angle so we know whether we need to flip it\n\t\t\t\tlet maxAngle = 0;\n\t\t\t\tlet midAngle = 0;\n\t\t\t\t$array.each(this._textInfo!, (line, _index) => {\n\t\t\t\t\tconst deltaAngle = startAngle + (line.width / (radius - line.height)) / 2 * -clockwise;\n\t\t\t\t\tif (deltaAngle > maxAngle) {\n\t\t\t\t\t\tmaxAngle = deltaAngle;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (align == \"left\") {\n\t\t\t\t\tmidAngle = (maxAngle + deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t}\n\t\t\t\telse if (align == \"right\") {\n\t\t\t\t\tmidAngle = (maxAngle - deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmidAngle = startAngle * $math.DEGREES;\n\t\t\t\t}\n\t\t\t\tmidAngle = $math.normalizeAngle(midAngle);\n\t\t\t\tinward = (midAngle >= 270) || (midAngle <= 90);\n\t\t\t}\n\n\t\t\tif (inward == true && shouldReverse) {\n\t\t\t\tthis._textInfo!.reverse();\n\t\t\t\tthis._textReversed = true;\n\t\t\t}\n\n\t\t\t// if ((inward == false && align == \"left\") || (inward == true && align == \"right\")) {\n\t\t\t// \tclockwise *= -1;\n\t\t\t// }\n\n\t\t\t// Process text info produced by _measure()\n\t\t\t$array.each(this._textInfo!, (line, _index) => {\n\n\t\t\t\tconst textHeight = line.height;\n\n\t\t\t\t// Adjust radius (for `inside = false`)\n\t\t\t\t// Radius adjustment for `inside = false` is below the line calculation\n\t\t\t\tif (!inside) {\n\t\t\t\t\tradius += textHeight;\n\t\t\t\t}\n\n\t\t\t\t// Reverse letters if we're painting them counter-clockwise\n\t\t\t\tif (((clockwise == -1 && inward) || (clockwise == 1 && !inward)) && shouldReverse) {\n\t\t\t\t\tline.textChunks.reverse();\n\t\t\t\t}\n\n\t\t\t\t// Init angles\n\t\t\t\tlet lineStartAngle = startAngle;\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t\t// Adjust for center-align\n\t\t\t\tif (align == \"center\") {\n\t\t\t\t\tlineStartAngle += (line.width / (radius - textHeight)) / 2 * -clockwise;\n\t\t\t\t\tdeltaAngle = lineStartAngle - startAngle;\n\t\t\t\t}\n\n\t\t\t\t// if (inward == \"auto\") {\n\t\t\t\t// \tlet midAngle;\n\t\t\t\t// \tif (align == \"left\") {\n\t\t\t\t// \t\tmidAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t// \t}\n\t\t\t\t// \telse if () {\n\t\t\t\t// \t\tmidAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;\n\t\t\t\t// \t}\n\t\t\t\t// \tinward = (midAngle >= 270) || (midAngle <= 90);\n\t\t\t\t// }\n\n\t\t\t\t// Rotate letters if they are facing outward\n\t\t\t\tlineStartAngle += (Math.PI * (inward ? 0 : 1)); // Rotate 180 if outward\n\n\t\t\t\t// Savepoint\n\t\t\t\tcontext.save();\n\t\t\t\tif (interactive) {\n\t\t\t\t\tghostContext.save();\n\t\t\t\t}\n\n\t\t\t\t// Assume starting angle\n\t\t\t\tcontext.rotate(lineStartAngle);\n\t\t\t\tif (interactive) {\n\t\t\t\t\tghostContext.rotate(lineStartAngle);\n\t\t\t\t}\n\n\t\t\t\tlet angleShift = 0;\n\t\t\t\t$array.each(line.textChunks, (chunk, _index) => {\n\n\t\t\t\t\t// Draw the letter\n\t\t\t\t\tconst char = chunk.text;\n\t\t\t\t\tconst charWidth = chunk.width;\n\n\t\t\t\t\t// Rotate half a letter\n\t\t\t\t\tangleShift = (charWidth / 2) / (radius - textHeight) * clockwise;\n\t\t\t\t\tcontext.rotate(angleShift);\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.rotate(angleShift);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tghostContext.save();\n\n\t\t\t\t\t\tcontext.font = chunk.style;\n\t\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\t\tghostContext.font = chunk.style;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.fillStyle = chunk.fill.toCSS();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Center letters\n\t\t\t\t\tcontext.textBaseline = \"middle\";\n\t\t\t\t\tcontext.textAlign = \"center\";\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.textBaseline = \"middle\";\n\t\t\t\t\t\tghostContext.textAlign = \"center\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Plop the letter\n\t\t\t\t\tif (layerDirty) {\n\t\t\t\t\t\tcontext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n\t\t\t\t\t}\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.fill) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t// Color does not affect ghostContext so we not set it\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset style\n\t\t\t\t\tif (chunk.style) {\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Rotate half a letter and add spacing\n\t\t\t\t\tangleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;\n\t\t\t\t\tcontext.rotate(angleShift);\n\t\t\t\t\tif (interactive) {\n\t\t\t\t\t\tghostContext.rotate(angleShift);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\t// Restore angle\n\t\t\t\tcontext.restore();\n\t\t\t\tif (interactive) {\n\t\t\t\t\tghostContext.restore();\n\t\t\t\t}\n\n\t\t\t\t// Adjust radius (for `inside = true`)\n\t\t\t\tif (inside) {\n\t\t\t\t\tradius -= textHeight;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// Restore\n\t\t\tcontext.restore();\n\t\t\tif (interactive) {\n\t\t\t\tghostContext.restore();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _measure(layer: CanvasLayer): IBounds {\n\t\tswitch (this.textType) {\n\t\t\tcase \"circular\":\n\t\t\t\treturn this._measureCircular(layer);\n\t\t\tdefault:\n\t\t\t\treturn super._measure(layer);\n\t\t}\n\t}\n\n\tpublic _measureCircular(layer: CanvasLayer): IBounds {\n\t\tconst context = layer.context;\n\t\tconst ghostContext = this._renderer._ghostLayer.context;\n\t\tconst rtl = this.style.direction == \"rtl\";\n\n\t\tconst oversizedBehavior = this.style.oversizedBehavior;\n\t\tconst maxWidth = this.style.maxWidth!;\n\n\t\tconst truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n\t\tconst ellipsis = this.style.ellipsis || \"\";\n\t\tlet ellipsisMetrics: TextMetrics;\n\t\t//const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n\n\n\t\t// Reset text info\n\t\tthis.textVisible = true;\n\t\tthis._textInfo = [];\n\t\tthis._textReversed = false;\n\n\t\t// Pre-render\n\t\tcontext.save();\n\t\tghostContext.save();\n\t\tthis._prerender(layer, true);\n\n\t\t// Split up text into lines\n\t\tconst lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n\t\tlet styleRestored = true;\n\t\tlet totalWidth = 0;\n\n\t\t// Iterate through the lines\n\t\tlet offsetY = 0;\n\t\t$array.each(lines, (line, _index) => {\n\n\t\t\t// Split up line into format/value chunks\n\t\t\tlet chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n\n\t\t\t// Init line object\n\t\t\tlet lineInfo: ILine = {\n\t\t\t\toffsetY: offsetY,\n\t\t\t\tascent: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttextChunks: []\n\t\t\t};\n\n\t\t\tlet currentStyle: string | undefined;\n\t\t\tlet currentFill: Color | undefined;\n\t\t\tlet currentChunkWidth: number | undefined;\n\n\t\t\t//while(chunk = chunks.shift()) {\n\t\t\t$array.each(chunks, (chunk, _index) => {\n\n\t\t\t\t// Format chunk\n\t\t\t\tif (chunk.type == \"format\") {\n\t\t\t\t\tif (chunk.text == \"[/]\") {\n\t\t\t\t\t\tif (!styleRestored) {\n\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\tghostContext.restore();\n\t\t\t\t\t\t\tstyleRestored = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentFill = undefined;\n\t\t\t\t\t\tcurrentStyle = undefined;\n\t\t\t\t\t\tcurrentChunkWidth = undefined;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet format = TextFormatter.getTextStyle(chunk.text);\n\t\t\t\t\t\tconst fontStyle = this._getFontStyle(format);\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tghostContext.save();\n\t\t\t\t\t\tcontext.font = fontStyle;\n\t\t\t\t\t\tcurrentStyle = fontStyle;\n\t\t\t\t\t\tif (format.fill) {\n\t\t\t\t\t\t\tcurrentFill = <Color>format.fill;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((<any>format).width) {\n\t\t\t\t\t\t\tcurrentChunkWidth = $type.toNumber((<any>format).width);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyleRestored = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (truncate) {\n\t\t\t\t\t\tellipsisMetrics = this._measureText(ellipsis, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Text format\n\t\t\t\telse if (chunk.type == \"value\") {\n\n\t\t\t\t\t// Measure each letter\n\t\t\t\t\tconst chars = chunk.text.match(/./ug) || [];\n\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\tchars.reverse();\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < chars.length; i++) {\n\n\t\t\t\t\t\tconst char = chars[i];\n\n\t\t\t\t\t\t// Measure\n\t\t\t\t\t\tconst metrics = this._measureText(char, context);\n\t\t\t\t\t\tlet chunkWidth = metrics.width;\n\n\t\t\t\t\t\t// Chunk width?\n\t\t\t\t\t\tif (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {\n\t\t\t\t\t\t\tchunkWidth = currentChunkWidth;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\t\t\t\t\t\tif (chunkHeight > lineInfo.height) {\n\t\t\t\t\t\t\tlineInfo.height = chunkHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n\t\t\t\t\t\t\tlineInfo.ascent = metrics.actualBoundingBoxAscent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlineInfo.width += chunkWidth;\n\t\t\t\t\t\tlineInfo.left += metrics.actualBoundingBoxLeft;\n\t\t\t\t\t\tlineInfo.right += metrics.actualBoundingBoxRight;\n\t\t\t\t\t\tlineInfo.textChunks.push({\n\t\t\t\t\t\t\tstyle: currentStyle,\n\t\t\t\t\t\t\tfill: currentFill,\n\t\t\t\t\t\t\ttext: char,\n\t\t\t\t\t\t\twidth: chunkWidth,\n\t\t\t\t\t\t\theight: chunkHeight + metrics.actualBoundingBoxDescent,\n\t\t\t\t\t\t\tleft: metrics.actualBoundingBoxLeft,\n\t\t\t\t\t\t\tright: metrics.actualBoundingBoxRight,\n\t\t\t\t\t\t\tascent: metrics.actualBoundingBoxAscent,\n\t\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\t\toffsetY: chunkHeight,\n\t\t\t\t\t\t\ttextDecoration: undefined\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\ttotalWidth += chunkWidth;\n\n\t\t\t\t\t\t// Handle oversized behavior\n\t\t\t\t\t\tif (truncate) {\n\t\t\t\t\t\t\t// Measure ellipsis and check if it fits\n\t\t\t\t\t\t\tif (!ellipsisMetrics) {\n\t\t\t\t\t\t\t\tellipsisMetrics = this._measureText(ellipsis, context);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n\t\t\t\t\t\t\ttotalWidth += ellipsisWidth;\n\t\t\t\t\t\t\tif ((totalWidth + ellipsisWidth) > maxWidth) {\n\t\t\t\t\t\t\t\tif (lineInfo.textChunks.length == 1) {\n\t\t\t\t\t\t\t\t\tthis.textVisible = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tlineInfo.width += ellipsisWidth;\n\t\t\t\t\t\t\t\t\tlineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;\n\t\t\t\t\t\t\t\t\tlineInfo.right += ellipsisMetrics.actualBoundingBoxRight;\n\t\t\t\t\t\t\t\t\tlineInfo.textChunks.push({\n\t\t\t\t\t\t\t\t\t\tstyle: currentStyle,\n\t\t\t\t\t\t\t\t\t\tfill: currentFill,\n\t\t\t\t\t\t\t\t\t\ttext: ellipsis,\n\t\t\t\t\t\t\t\t\t\twidth: ellipsisWidth,\n\t\t\t\t\t\t\t\t\t\theight: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,\n\t\t\t\t\t\t\t\t\t\tleft: ellipsisMetrics.actualBoundingBoxLeft,\n\t\t\t\t\t\t\t\t\t\tright: ellipsisMetrics.actualBoundingBoxRight,\n\t\t\t\t\t\t\t\t\t\tascent: ellipsisMetrics.actualBoundingBoxAscent,\n\t\t\t\t\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\t\t\t\t\toffsetY: chunkHeight,\n\t\t\t\t\t\t\t\t\t\ttextDecoration: undefined\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (this.style.lineHeight instanceof Percent) {\n\t\t\t\tlineInfo.height *= this.style.lineHeight.value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlineInfo.height *= this.style.lineHeight || 1.2;\n\t\t\t}\n\n\t\t\tthis._textInfo!.push(lineInfo);\n\n\t\t\t//lineInfo.offsetY += lineInfo.ascent;\n\t\t\toffsetY += lineInfo.height;\n\n\n\t\t});\n\n\t\tif (!styleRestored) {\n\t\t\tcontext.restore();\n\t\t\tghostContext.restore();\n\t\t}\n\n\n\t\tif (oversizedBehavior == \"hide\" && (totalWidth > maxWidth)) {\n\t\t\tthis.textVisible = false;\n\t\t}\n\n\t\t// Adjust chunk internal offsets\n\t\t$array.each(this._textInfo, (lineInfo) => {\n\t\t\t$array.each(lineInfo.textChunks, (chunk) => {\n\t\t\t\tchunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);\n\t\t\t});\n\t\t});\n\n\t\tcontext.restore();\n\t\tghostContext.restore();\n\n\t\treturn {\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t};\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasImage extends CanvasDisplayObject implements IPicture {\n\tpublic width: number | undefined;\n\tpublic height: number | undefined;\n\tpublic image: HTMLImageElement | undefined;\n\tpublic tainted?: boolean;\n\n\tpublic shadowColor?: Color;\n\tpublic shadowBlur?: number;\n\tpublic shadowOffsetX?: number;\n\tpublic shadowOffsetY?: number;\n\tpublic shadowOpacity?: number;\n\n\tprotected _imageMask: HTMLCanvasElement | undefined;\n\n\tconstructor(renderer: CanvasRenderer, image: HTMLImageElement | undefined) {\n\t\tsuper(renderer);\n\t\tthis.image = image;\n\t}\n\n\tprotected _dispose(): void {\n\t\tsuper._dispose();\n\n\t\tif (this._imageMask) {\n\t\t\tclearCanvas(this._imageMask);\n\t\t}\n\t}\n\n\tgetLocalBounds(): IBounds {\n\t\tif (!this._localBounds) {\n\n\n\t\t\tlet w = 0;\n\t\t\tlet h = 0;\n\n\t\t\tif (this.width) {\n\t\t\t\tw = this.width;\n\t\t\t}\n\t\t\tif (this.height) {\n\t\t\t\th = this.height;\n\t\t\t}\n\n\t\t\tthis._localBounds = {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tright: w,\n\t\t\t\tbottom: h\n\t\t\t};\n\n\t\t\tthis._addBounds(this._localBounds);\n\t\t}\n\t\treturn this._localBounds;\n\t}\n\n\tprotected _render(parentLayer: CanvasLayer): void {\n\t\tsuper._render(parentLayer);\n\n\t\tif (this.image) {\n\t\t\tconst layer = this._layer || parentLayer;\n\n\t\t\tif (this.tainted === undefined) {\n\t\t\t\tthis.tainted = isTainted(this.image);\n\t\t\t\tlayer.tainted = true;\n\t\t\t}\n\n\t\t\tif (this.tainted && this._renderer._omitTainted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (layer.dirty) {\n\n\t\t\t\tif (this.shadowColor) {\n\t\t\t\t\tlayer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);\n\t\t\t\t}\n\t\t\t\tif (this.shadowBlur) {\n\t\t\t\t\tlayer.context.shadowBlur = this.shadowBlur;\n\t\t\t\t}\n\t\t\t\tif (this.shadowOffsetX) {\n\t\t\t\t\tlayer.context.shadowOffsetX = this.shadowOffsetX;\n\t\t\t\t}\n\t\t\t\tif (this.shadowOffsetY) {\n\t\t\t\t\tlayer.context.shadowOffsetY = this.shadowOffsetY;\n\t\t\t\t}\n\n\t\t\t\t// TODO should this round ?\n\t\t\t\tconst width = this.width || this.image.naturalWidth;\n\t\t\t\tconst height = this.height || this.image.naturalHeight;\n\n\t\t\t\tlayer.context.drawImage(this.image, 0, 0, width, height);\n\t\t\t}\n\n\t\t\tif (this.interactive && this._isInteractive()) {\n\t\t\t\tconst mask = this._getMask(this.image);\n\n\t\t\t\tthis._renderer._ghostLayer.context.drawImage(mask, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic clear(): void {\n\t\tsuper.clear();\n\t\tthis.image = undefined;\n\t\tthis._imageMask = undefined;\n\t}\n\n\tprotected _getMask(image: HTMLImageElement): HTMLCanvasElement {\n\t\tif (this._imageMask === undefined) {\n\t\t\t// TODO should this round ?\n\t\t\tconst width = this.width || image.naturalWidth;\n\t\t\tconst height = this.height || image.naturalHeight;\n\n\t\t\t// We need to create a second canvas because destination-in clears out the entire canvas\n\t\t\tconst canvas = document.createElement(\"canvas\");\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext(\"2d\")!;\n\n\t\t\tcontext.imageSmoothingEnabled = false;\n\n\t\t\tcontext.fillStyle = this._getColorId();\n\t\t\tcontext.fillRect(0, 0, width, height);\n\n\t\t\tif (!isTainted(image)) {\n\t\t\t\tcontext.globalCompositeOperation = \"destination-in\";\n\t\t\t\tcontext.drawImage(image, 0, 0, width, height);\n\t\t\t}\n\n\t\t\tthis._imageMask = canvas;\n\t\t}\n\n\t\treturn this._imageMask;\n\t}\n\n}\n\n/**\n * @ignore\n */\nexport class CanvasRendererEvent<A> implements IRendererEvent<A> {\n\tpublic id: Id;\n\tpublic simulated: boolean = false;\n\tpublic native: boolean = true;\n\n\tconstructor(public event: A, public originalPoint: IPoint, public point: IPoint, public bbox: DOMRect) {\n\t\tif ($utils.supports(\"touchevents\") && event instanceof Touch) {\n\t\t\tthis.id = event.identifier;\n\n\t\t} else {\n\t\t\tthis.id = null;\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\ninterface IEvent<Key extends keyof IRendererEvents> {\n\tobject: CanvasDisplayObject;\n\tcontext: unknown;\n\tcallback: (event: IRendererEvents[Key]) => void;\n\tdisposed: boolean;\n}\n\n/**\n * @ignore\n */\ninterface IEvents<Key extends keyof IRendererEvents> {\n\tdisposer: IDisposer;\n\tcallbacks: Array<IEvent<Key>>;\n\tdispatching: boolean;\n\tcleanup: boolean;\n}\n\n/**\n * @ignore\n */\nexport class CanvasRenderer extends ArrayDisposer implements IRenderer, IDisposer {\n\tpublic view: HTMLElement = document.createElement(\"div\");\n\tprotected _layerDom: HTMLElement = document.createElement(\"div\");\n\n\tpublic layers: Array<CanvasLayer> = [];\n\tpublic _dirtyLayers: Array<CanvasLayer> = [];\n\tpublic defaultLayer: CanvasLayer = this.getLayer(0);\n\n\tpublic _ghostLayer: GhostLayer = new GhostLayer();\n\n\tprotected _patternCanvas: HTMLCanvasElement = document.createElement(\"canvas\");\n\tprotected _patternContext: CanvasRenderingContext2D = this._patternCanvas.getContext(\"2d\")!;\n\n\tprotected _domWidth: number = 0;\n\tprotected _domHeight: number = 0;\n\n\tprotected _canvasWidth: number = 0;\n\tprotected _canvasHeight: number = 0;\n\n\tpublic resolution: number;\n\tpublic interactionsEnabled: boolean = true;\n\n\tprotected _listeners: { [key: string]: CounterDisposer } = {};\n\tprotected _events: { [Key in keyof IRendererEvents]?: IEvents<Key> } = {};\n\n\tprotected _colorId: number = 0;\n\tprotected _colorMap: { [color: string]: CanvasDisplayObject } = {};\n\n\tpublic _forceInteractive: number = 0;\n\tpublic _omitTainted: boolean = false;\n\n\t// TODO this should store the Id as well\n\tpublic _hovering: Set<CanvasDisplayObject> = new Set();\n\tpublic _dragging: Array<{ id: Id, value: CanvasDisplayObject }> = [];\n\tpublic _mousedown: Array<{ id: Id, value: CanvasDisplayObject }> = [];\n\n\tprotected _lastPointerMoveEvent: { events: Array<IPointerEvent>, target: Node | null, native: boolean } | undefined;\n\n\tpublic tapToActivate: boolean = false;\n\tpublic tapToActivateTimeout: number = 3000;\n\tpublic _touchActive: boolean = false;\n\tprotected _touchActiveTimeout?: number;\n\n\t/*protected _mouseMoveThrottler: Throttler = new Throttler(() => {\n\t\tthis._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);\n\t});\n\t*/\n\n\tconstructor(resolution?: number) {\n\t\tsuper();\n\n\t\tif (resolution == null) {\n\t\t\tthis.resolution = window.devicePixelRatio;\n\t\t} else {\n\t\t\tthis.resolution = resolution;\n\t\t}\n\n\t\tthis.view.style.position = \"absolute\";\n\t\tthis.view.appendChild(this._layerDom);\n\n\t\tthis._disposers.push(new Disposer(() => {\n\t\t\t$object.each(this._events, (_key, events) => {\n\t\t\t\tevents.disposer.dispose();\n\t\t\t});\n\n\t\t\t$array.each(this.layers, (layer) => {\n\t\t\t\tclearCanvas(layer.view);\n\n\t\t\t\tif (layer.exportableView) {\n\t\t\t\t\tclearCanvas(layer.exportableView);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tclearCanvas(this._ghostLayer.view);\n\t\t\tclearCanvas(this._patternCanvas);\n\t\t}));\n\n\t\t/*\n\t\tthis._disposers.push($utils.addEventListener(this._ghostLayer.view, \"click\", (originalEvent: MouseEvent) => {\n\t\t\tconst event = this.getEvent(originalEvent);\n\t\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox);\n\t\t\tconsole.debug(target);\n\t\t}));\n\t\t*/\n\n\t\t// Monitor for possible pixel ratio changes (when page is zoomed)\n\t\tthis._disposers.push($utils.onZoom(() => {\n\t\t\tif (resolution == null) {\n\t\t\t\tthis.resolution = window.devicePixelRatio;\n\t\t\t}\n\t\t}));\n\n\t\t// We need this in order top prevent default touch gestures when dragging\n\t\t// draggable elements\n\t\tif ($utils.supports(\"touchevents\")) {\n\t\t\tconst listener = (ev: any) => {\n\t\t\t\tif (this._dragging.length !== 0) {\n\t\t\t\t\t$array.eachContinue(this._dragging, (item) => {\n\t\t\t\t\t\tif (item.value.shouldCancelTouch()) {\n\t\t\t\t\t\t\tev.preventDefault();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If touch down happends, delay touch out\n\t\t\t\tif (this._touchActiveTimeout) {\n\t\t\t\t\tthis._delayTouchDeactivate();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._disposers.push($utils.addEventListener(window, \"touchstart\", listener, { passive: false }));\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"touchstart\", listener, { passive: false }));\n\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"touchmove\", () => {\n\t\t\t\t// If touch is moving, delay touch out\n\t\t\t\tif (this._touchActiveTimeout) {\n\t\t\t\t\tthis._delayTouchDeactivate();\n\t\t\t\t}\n\t\t\t}, { passive: true }));\n\n\t\t\tthis._disposers.push($utils.addEventListener(window, \"click\", (_ev: any) => {\n\t\t\t\tthis._touchActive = false;\n\t\t\t}, { passive: true }));\n\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"click\", (_ev: any) => {\n\t\t\t\twindow.setTimeout(() => {\n\t\t\t\t\tthis._touchActive = true;\n\t\t\t\t\tthis._delayTouchDeactivate();\n\t\t\t\t}, 100);\n\t\t\t}, { passive: true }));\n\n\t\t}\n\n\t\t// Prevent scrolling of the window when hovering on \"wheelable\" object\n\t\tif ($utils.supports(\"wheelevents\")) {\n\t\t\tthis._disposers.push($utils.addEventListener(this.view, \"wheel\", (ev) => {\n\t\t\t\tlet prevent = false;\n\t\t\t\tthis._hovering.forEach((obj) => {\n\t\t\t\t\tif (obj.wheelable) {\n\t\t\t\t\t\tprevent = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (prevent) {\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t}\n\t\t\t}, { passive: false }));\n\t\t}\n\n\t}\n\n\tprotected _delayTouchDeactivate(): void {\n\t\tif (this._touchActiveTimeout) {\n\t\t\tclearTimeout(this._touchActiveTimeout);\n\t\t}\n\t\tif (this.tapToActivateTimeout > 0) {\n\t\t\tthis._touchActiveTimeout = window.setTimeout(() => {\n\t\t\t\tthis._touchActive = false;\n\t\t\t}, this.tapToActivateTimeout);\n\t\t}\n\t}\n\n\tpublic get debugGhostView(): boolean {\n\t\treturn !!this._ghostLayer.view.parentNode;\n\t}\n\n\tpublic set debugGhostView(value: boolean) {\n\t\tif (value) {\n\t\t\tif (!this._ghostLayer.view.parentNode) {\n\t\t\t\tthis.view.appendChild(this._ghostLayer.view);\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (this._ghostLayer.view.parentNode) {\n\t\t\t\tthis._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateLinearGradient(x1: number, y1: number, x2: number, y2: number): CanvasGradient {\n\t\treturn this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);\n\t}\n\n\tcreateRadialGradient(x1: number, y1: number, radius1: number, x2: number, y2: number, radius2: number): CanvasGradient {\n\t\treturn this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);\n\t}\n\n\tcreatePattern(graphics: CanvasGraphics, background: CanvasGraphics, repetition: string, width: number, height: number): CanvasPattern {\n\t\t// const patternCanvas = document.createElement(\"canvas\");\n\t\t// const patternContext = patternCanvas.getContext(\"2d\")!;\n\t\t// patternCanvas.width = width;\n\t\t// patternCanvas.height = height;\n\t\t// if (fill) {\n\t\t// \tpatternContext.fillStyle = fill.toCSS();\n\t\t// \tpatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\n\t\t// }\n\n\t\t// const layer = {\n\t\t// \tview: patternCanvas,\n\t\t// \tcontext: patternContext,\n\t\t// \tvisible: true,\n\t\t// \torder: 0,\n\t\t// \twidth: width,\n\t\t// \theight: height,\n\t\t// \tdirty: true\n\t\t// };\n\n\t\t// // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);\n\t\t// // patternContext.stroke();\n\n\t\t// image.targetLayer = layer;\n\t\t// image.render(layer);\n\n\t\t//this._layerDom.appendChild(patternCanvas);\n\n\t\tthis._patternCanvas.width = width;\n\t\tthis._patternCanvas.height = height;\n\n\t\tthis._patternContext.clearRect(0, 0, width, height);\n\n\t\t// patternCanvas.style.width = width * this.resolution + \"px\";\n\t\t// patternCanvas.style.height = height * this.resolution + \"px\";\n\n\t\tbackground.renderDetached(this._patternContext);\n\t\tgraphics.renderDetached(this._patternContext);\n\n\t\treturn this._patternContext.createPattern(this._patternCanvas, repetition)!;\n\t}\n\n\tmakeContainer(): CanvasContainer {\n\t\treturn new CanvasContainer(this);\n\t}\n\n\tmakeGraphics(): CanvasGraphics {\n\t\treturn new CanvasGraphics(this);\n\t}\n\n\tmakeText(text: string, style: CanvasTextStyle): CanvasText {\n\t\treturn new CanvasText(this, text, style);\n\t}\n\n\tmakeTextStyle(): CanvasTextStyle {\n\t\treturn new CanvasTextStyle();\n\t}\n\n\tmakeRadialText(text: string, style: CanvasTextStyle): CanvasRadialText {\n\t\treturn new CanvasRadialText(this, text, style);\n\t}\n\n\tmakePicture(image: HTMLImageElement | undefined): CanvasImage {\n\t\treturn new CanvasImage(this, image);\n\t}\n\n\tresizeLayer(layer: CanvasLayer) {\n\t\tlayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);\n\t}\n\n\tresizeGhost() {\n\t\tthis._ghostLayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);\n\t}\n\n\tresize(canvasWidth: number, canvasHeight: number, domWidth: number, domHeight: number): void {\n\t\tthis._canvasWidth = canvasWidth;\n\t\tthis._canvasHeight = canvasHeight;\n\n\t\tthis._domWidth = domWidth;\n\t\tthis._domHeight = domHeight;\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer) {\n\t\t\t\tlayer.dirty = true;\n\t\t\t\tthis.resizeLayer(layer);\n\t\t\t}\n\t\t});\n\n\t\tthis.resizeGhost();\n\n\t\tthis.view.style.width = domWidth + \"px\";\n\t\tthis.view.style.height = domHeight + \"px\";\n\t}\n\n\tprivate createDetachedLayer(willReadFrequently: boolean = false): CanvasLayer {\n\t\tconst view = document.createElement(\"canvas\");\n\t\tconst context = view.getContext(\"2d\", { willReadFrequently: willReadFrequently })! as CanvasRenderingContext2D;\n\n\t\tconst layer = new CanvasLayer(view, context);\n\n\t\tview.style.position = \"absolute\";\n\t\tview.style.top = \"0px\";\n\t\tview.style.left = \"0px\";\n\n\t\treturn layer;\n\t}\n\n\tgetLayerByOrder(order: number): CanvasLayer | undefined {\n\t\tconst layers = this.layers;\n\t\tconst length = layers.length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst layer = layers[i];\n\t\t\tif (layer.order == order) {\n\t\t\t\treturn layer;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetLayer(order: number, visible: boolean = true): CanvasLayer {\n\t\tlet existingLayer = this.getLayerByOrder(order);\n\t\tif (existingLayer) {\n\t\t\treturn existingLayer;\n\t\t}\n\n\t\tconst layer = this.createDetachedLayer(order == 99);\n\t\tlayer.order = order;\n\t\tlayer.visible = visible;\n\n\t\tif (layer.visible) {\n\t\t\tthis.resizeLayer(layer);\n\t\t}\n\n\t\tconst layers = this.layers;\n\n\t\tlayers.push(layer);\n\n\t\tlayers.sort((a, b) => {\n\t\t\tif (a.order > b.order) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (a.order < b.order) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tconst length = layers.length;\n\t\tconst layerIndex = $array.indexOf(layers, layer);\n\t\tlet next;\n\n\t\tfor (let i = layerIndex + 1; i < length; i++) {\n\t\t\tif (layers[i].visible) {\n\t\t\t\tnext = layers[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (layer.visible) {\n\t\t\tif (next === undefined) {\n\t\t\t\tthis._layerDom.appendChild(layer.view);\n\n\t\t\t} else {\n\t\t\t\tthis._layerDom.insertBefore(layer.view, next.view);\n\t\t\t}\n\t\t}\n\n\t\treturn layer;\n\t}\n\n\trender(root: CanvasDisplayObject): void {\n\n\t\tthis._dirtyLayers.length = 0;\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer) {\n\t\t\t\tif (layer.dirty && layer.visible) {\n\t\t\t\t\tthis._dirtyLayers.push(layer);\n\t\t\t\t\tlayer.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis._ghostLayer.clear();\n\n\t\troot.render(this.defaultLayer);\n\n\t\tthis._ghostLayer.context.restore();\n\n\t\t//setTimeout(() => {\n\n\t\t// Remove this after the Chrome bug is fixed:\n\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=1279394\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer) {\n\t\t\t\tconst context = layer.context;\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(0, 0);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t});\n\n\t\t$array.each(this._dirtyLayers, (layer) => {\n\t\t\tlayer.context.restore();\n\t\t\tlayer.dirty = false;\n\t\t});\n\t\t//}, 100)\n\n\t\tif (this._hovering.size && this._lastPointerMoveEvent) {\n\t\t\tconst { events, target, native } = this._lastPointerMoveEvent;\n\n\t\t\t//this._mouseMoveThrottler.run();\n\n\t\t\t$array.each(events, (event) => {\n\t\t\t\tthis._dispatchGlobalMousemove(event, target, native);\n\t\t\t});\n\t\t}\n\t}\n\n\tpaintId(obj: CanvasDisplayObject): string {\n\t\tconst id = distributeId(++this._colorId);\n\t\tconst color = Color.fromHex(id).toCSS();\n\t\tthis._colorMap[color] = obj;\n\t\treturn color;\n\t}\n\n\t_removeObject(obj: CanvasDisplayObject): void {\n\t\tif (obj._colorId !== undefined) {\n\t\t\tdelete this._colorMap[obj._colorId];\n\t\t}\n\t}\n\n\t// protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {\n\t// \treturn this._colorMap[colorId];\n\t// }\n\n\tprotected _adjustBoundingBox(bbox: DOMRect): DOMRect {\n\t\tconst margin = this._ghostLayer.margin;\n\n\t\treturn new DOMRect(\n\t\t\tbbox.left - margin.left,\n\t\t\tbbox.top - margin.top,\n\t\t\tbbox.width + margin.left + margin.right,\n\t\t\tbbox.height + margin.top + margin.bottom,\n\t\t);\n\t}\n\n\tpublic getEvent<A extends IPointerEvent>(originalEvent: A, adjustPoint: boolean = true): CanvasRendererEvent<A> {\n\t\tconst bbox = this.view.getBoundingClientRect();\n\n\t\tconst originalPoint: IPoint = {\n\t\t\tx: originalEvent.clientX || 0,\n\t\t\ty: originalEvent.clientY || 0,\n\t\t};\n\n\t\tconst point: IPoint = {\n\t\t\tx: originalPoint.x - (adjustPoint ? bbox.left : 0),\n\t\t\ty: originalPoint.y - (adjustPoint ? bbox.top : 0),\n\t\t};\n\n\t\treturn new CanvasRendererEvent(\n\t\t\toriginalEvent,\n\t\t\toriginalPoint,\n\t\t\tpoint,\n\t\t\tthis._adjustBoundingBox(bbox),\n\t\t);\n\t}\n\n\t_getHitTarget(point: IPoint, bbox: DOMRect, target: Node | null): CanvasDisplayObject | undefined | false {\n\t\tif (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target || !this._layerDom.contains(target)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pixel = this._ghostLayer.getImageData(point, bbox);\n\n\t\tif (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();\n\t\tconst hit = this._colorMap[colorId];\n\n\t\treturn hit;\n\t}\n\n\t_withEvents<Key extends keyof IRendererEvents>(key: Key, f: (events: IEvents<Key>) => void): void {\n\t\tconst events = this._events[key] as IEvents<Key> | undefined;\n\n\t\tif (events !== undefined) {\n\t\t\tevents.dispatching = true;\n\n\t\t\ttry {\n\t\t\t\tf(events);\n\n\t\t\t} finally {\n\t\t\t\tevents.dispatching = false;\n\n\t\t\t\tif (events.cleanup) {\n\t\t\t\t\tevents.cleanup = false;\n\n\t\t\t\t\t$array.keepIf(events.callbacks, (callback) => {\n\t\t\t\t\t\treturn !callback.disposed;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (events.callbacks.length === 0) {\n\t\t\t\t\t\tevents.disposer.dispose();\n\t\t\t\t\t\tdelete this._events[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_dispatchEventAll<Key extends keyof IRendererEvents>(key: Key, event: IRendererEvents[Key]): void {\n\t\tif (!this.interactionsEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._withEvents(key, (events) => {\n\t\t\t$array.each(events.callbacks, (callback) => {\n\t\t\t\tif (!callback.disposed) {\n\t\t\t\t\tcallback.callback.call(callback.context, event);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t_dispatchEvent<Key extends keyof IRendererEvents>(key: Key, target: CanvasDisplayObject, event: IRendererEvents[Key]): boolean {\n\t\tif (!this.interactionsEnabled) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet dispatched = false;\n\n\t\tthis._withEvents(key, (events) => {\n\t\t\t$array.each(events.callbacks, (callback) => {\n\t\t\t\tif (!callback.disposed && callback.object === target) {\n\t\t\t\t\tcallback.callback.call(callback.context, event);\n\t\t\t\t\tdispatched = true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn dispatched;\n\t}\n\n\t_dispatchMousedown(originalEvent: IPointerEvent, originalTarget: Node | null): void {\n\t\tconst button = (<PointerEvent>originalEvent).button;\n\t\tif (button != 0 && button != 2 && button != 1 && button !== undefined) {\n\t\t\t// Ignore non-primary mouse buttons\n\t\t\treturn;\n\t\t}\n\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\n\t\tif (target) {\n\t\t\tconst id = event.id;\n\n\t\t\tlet dragged = false;\n\n\t\t\teachTargets(target, (obj) => {\n\t\t\t\tconst info = { id: id, value: obj };\n\n\t\t\t\tthis._mousedown.push(info);\n\n\t\t\t\tif (!dragged && this._dispatchEvent(\"pointerdown\", obj, event)) {\n\t\t\t\t\t// Only dispatch the first element which matches\n\t\t\t\t\tdragged = true;\n\n\t\t\t\t\tconst has = this._dragging.some((x) => {\n\t\t\t\t\t\treturn x.value === obj && x.id === id;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!has) {\n\t\t\t\t\t\tthis._dragging.push(info);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\t_dispatchGlobalMousemove(originalEvent: IPointerEvent, originalTarget: Node | null, native: boolean): void {\n\t\tconst event = this.getEvent(originalEvent);\n\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\t\tevent.native = native;\n\n\t\tif (target) {\n\t\t\tthis._hovering.forEach((obj) => {\n\t\t\t\tif (!obj.contains(target)) {\n\t\t\t\t\tthis._hovering.delete(obj);\n\t\t\t\t\tif (obj.cursorOverStyle) {\n\t\t\t\t\t\t$utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle!);\n\t\t\t\t\t}\n\t\t\t\t\tthis._dispatchEvent(\"pointerout\", obj, event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (event.native) {\n\t\t\t\teachTargets(target, (obj) => {\n\t\t\t\t\tif (!this._hovering.has(obj)) {\n\t\t\t\t\t\tthis._hovering.add(obj);\n\t\t\t\t\t\tif (obj.cursorOverStyle) {\n\t\t\t\t\t\t\tobj._replacedCursorStyle = $utils.getStyle(document.body, \"cursor\");\n\t\t\t\t\t\t\t$utils.setStyle(document.body, \"cursor\", obj.cursorOverStyle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._dispatchEvent(\"pointerover\", obj, event);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t//} else if (target === false) {\n\t\t} else {\n\t\t\tthis._hovering.forEach((obj) => {\n\t\t\t\tif (obj.cursorOverStyle) {\n\t\t\t\t\t$utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle!);\n\t\t\t\t}\n\t\t\t\tthis._dispatchEvent(\"pointerout\", obj, event);\n\t\t\t});\n\n\t\t\tthis._hovering.clear();\n\t\t}\n\t\tthis._dispatchEventAll(\"globalpointermove\", event);\n\t}\n\n\t_dispatchGlobalMouseup(originalEvent: IPointerEvent, native: boolean): void {\n\t\tconst event = this.getEvent(originalEvent);\n\t\tevent.native = native;\n\t\t//const target = this._getHitTarget(event.originalPoint);\n\t\tthis._dispatchEventAll(\"globalpointerup\", event);\n\t}\n\n\t_dispatchDragMove(originalEvent: IPointerEvent): void {\n\t\tif (this._dragging.length !== 0) {\n\t\t\tconst event = this.getEvent(originalEvent);\n\t\t\tconst id = event.id;\n\n\t\t\tthis._dragging.forEach((obj) => {\n\t\t\t\tif (obj.id === id) {\n\t\t\t\t\tthis._dispatchEvent(\"pointermove\", obj.value, event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t_dispatchDragEnd(originalEvent: IPointerEvent, originalTarget: Node | null): void {\n\t\tconst button = (<PointerEvent>originalEvent).button;\n\t\tlet clickevent: \"click\" | \"rightclick\" | \"middleclick\";\n\t\tif (button == 0 || button === undefined) {\n\t\t\tclickevent = \"click\";\n\t\t}\n\t\telse if (button == 2) {\n\t\t\tclickevent = \"rightclick\";\n\t\t}\n\t\telse if (button == 1) {\n\t\t\tclickevent = \"middleclick\";\n\t\t}\n\t\telse {\n\t\t\t// Ignore non-primary mouse buttons\n\t\t\treturn;\n\t\t}\n\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst id = event.id;\n\n\t\tif (this._mousedown.length !== 0) {\n\t\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\t\t\tif (target) {\n\t\t\t\tthis._mousedown.forEach((obj) => {\n\t\t\t\t\tif (obj.id === id && obj.value.contains(target)) {\n\t\t\t\t\t\tthis._dispatchEvent(clickevent, obj.value, event);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mousedown.length = 0;\n\t\t}\n\n\t\tif (this._dragging.length !== 0) {\n\t\t\tthis._dragging.forEach((obj) => {\n\t\t\t\tif (obj.id === id) {\n\t\t\t\t\tthis._dispatchEvent(\"pointerup\", obj.value, event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._dragging.length = 0;\n\t\t}\n\t}\n\n\t_dispatchDoubleClick(originalEvent: IPointerEvent, originalTarget: Node | null): void {\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\t\tif (target) {\n\t\t\teachTargets(target, (obj) => {\n\t\t\t\tif (this._dispatchEvent(\"dblclick\", obj, event)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t_dispatchWheel(originalEvent: WheelEvent, originalTarget: Node | null): void {\n\t\tconst event = this.getEvent(originalEvent);\n\t\tconst target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n\n\t\tif (target) {\n\t\t\teachTargets(target, (obj) => {\n\t\t\t\tif (this._dispatchEvent(\"wheel\", obj, event)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t_makeSharedEvent(key: string, f: () => IDisposer): IDisposer {\n\t\tif (this._listeners[key] === undefined) {\n\t\t\tconst listener = f();\n\n\t\t\tthis._listeners[key] = new CounterDisposer(() => {\n\t\t\t\tdelete this._listeners[key];\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn this._listeners[key].increment();\n\t}\n\n\t_onPointerEvent(name: string, f: (event: Array<IPointerEvent>, target: Node | null, native: boolean) => void): IDisposer {\n\t\tlet native = false;\n\t\tlet timer: number | null = null;\n\n\t\tfunction clear() {\n\t\t\ttimer = null;\n\t\t\tnative = false;\n\t\t}\n\n\t\treturn new MultiDisposer([\n\t\t\tnew Disposer(() => {\n\t\t\t\tif (timer !== null) {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t}\n\n\t\t\t\tclear();\n\t\t\t}),\n\n\t\t\t$utils.addEventListener(this.view, $utils.getRendererEvent(name), (_) => {\n\t\t\t\tnative = true;\n\n\t\t\t\tif (timer !== null) {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t}\n\n\t\t\t\ttimer = window.setTimeout(clear, 0);\n\t\t\t}),\n\n\t\t\tonPointerEvent(window, name, (ev, target) => {\n\t\t\t\tif (timer !== null) {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\n\t\t\t\tf(ev, target, native);\n\n\t\t\t\tnative = false;\n\t\t\t}),\n\t\t]);\n\t}\n\n\t// This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)\n\t_initEvent(key: keyof IRendererEvents): IDisposer | undefined {\n\t\tswitch (key) {\n\t\t\tcase \"globalpointermove\":\n\t\t\tcase \"pointerover\":\n\t\t\tcase \"pointerout\":\n\t\t\t\treturn this._makeSharedEvent(\"pointermove\", () => {\n\t\t\t\t\tconst listener = (events: Array<IPointerEvent>, target: Node | null, native: boolean) => {\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { events, target, native };\n\n\t\t\t\t\t\t$array.each(events, (event) => {\n\t\t\t\t\t\t\tthis._dispatchGlobalMousemove(event, target, native);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\treturn new MultiDisposer([\n\t\t\t\t\t\tthis._onPointerEvent(\"pointerdown\", listener),\n\t\t\t\t\t\tthis._onPointerEvent(\"pointermove\", listener),\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\tcase \"globalpointerup\":\n\t\t\t\treturn this._makeSharedEvent(\"pointerup\", () => {\n\t\t\t\t\tconst mouseup = this._onPointerEvent(\"pointerup\", (events, target, native) => {\n\t\t\t\t\t\t$array.each(events, (event) => {\n\t\t\t\t\t\t\tthis._dispatchGlobalMouseup(event, native);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { events, target, native };\n\t\t\t\t\t});\n\n\t\t\t\t\tconst pointercancel = this._onPointerEvent(\"pointercancel\", (events, target, native) => {\n\t\t\t\t\t\t$array.each(events, (event) => {\n\t\t\t\t\t\t\tthis._dispatchGlobalMouseup(event, native);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { events, target, native };\n\t\t\t\t\t});\n\n\t\t\t\t\treturn new Disposer(() => {\n\t\t\t\t\t\tmouseup.dispose();\n\t\t\t\t\t\tpointercancel.dispose();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"click\":\n\t\t\tcase \"rightclick\":\n\t\t\tcase \"middleclick\":\n\t\t\tcase \"pointerdown\":\n\t\t\t/*\n\t\t\t\treturn this._makeSharedEvent(\"pointerdown\", () => {\n\t\t\t\t\treturn this._onPointerEvent(\"pointerdown\", (event, target, native) => {\n\t\t\t\t\t\tthis._lastPointerMoveEvent = { event, target, native };\n\t\t\t\t\t\tthis._dispatchMousedown(event)\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t*/\n\t\t\tcase \"pointermove\":\n\t\t\tcase \"pointerup\":\n\t\t\t\treturn this._makeSharedEvent(\"pointerdown\", () => {\n\t\t\t\t\t//const throttler = new Throttler();\n\n\t\t\t\t\tconst mousedown = this._onPointerEvent(\"pointerdown\", (events, target) => {\n\t\t\t\t\t\t$array.each(events, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchMousedown(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// TODO handle throttling properly for multitouch\n\t\t\t\t\tconst mousemove = this._onPointerEvent(\"pointermove\", (ev: Array<IPointerEvent>) => {\n\t\t\t\t\t\t//throttler.throttle(() => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDragMove(ev);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//});\n\t\t\t\t\t});\n\n\t\t\t\t\tconst mouseup = this._onPointerEvent(\"pointerup\", (ev: Array<IPointerEvent>, target) => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDragEnd(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tconst pointercancel = this._onPointerEvent(\"pointercancel\", (ev: Array<IPointerEvent>, target) => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDragEnd(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\treturn new Disposer(() => {\n\t\t\t\t\t\tmousedown.dispose();\n\t\t\t\t\t\tmousemove.dispose();\n\t\t\t\t\t\tmouseup.dispose();\n\t\t\t\t\t\tpointercancel.dispose();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"dblclick\":\n\t\t\t\treturn this._makeSharedEvent(\"dblclick\", () => {\n\t\t\t\t\treturn this._onPointerEvent(\"dblclick\", (ev, target) => {\n\t\t\t\t\t\t$array.each(ev, (ev) => {\n\t\t\t\t\t\t\tthis._dispatchDoubleClick(ev, target);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"wheel\":\n\t\t\t\treturn this._makeSharedEvent(\"wheel\", () => {\n\t\t\t\t\treturn $utils.addEventListener(window, $utils.getRendererEvent(\"wheel\"), (event: WheelEvent) => {\n\t\t\t\t\t\tthis._dispatchWheel(event, $utils.getEventTarget(event));\n\t\t\t\t\t}, { passive: false });\n\t\t\t\t});\n\t\t}\n\t}\n\n\t_addEvent<C, Key extends keyof IRendererEvents>(object: CanvasDisplayObject, key: Key, callback: (this: C, event: IRendererEvents[Key]) => void, context?: C): IDisposer {\n\t\tlet events: IEvents<Key> | undefined = this._events[key] as any;\n\n\t\tif (events === undefined) {\n\t\t\tevents = this._events[key] = {\n\t\t\t\tdisposer: this._initEvent(key)!,\n\t\t\t\tcallbacks: [],\n\t\t\t\tdispatching: false,\n\t\t\t\tcleanup: false,\n\t\t\t};\n\t\t}\n\n\t\tconst listener = { object, context, callback, disposed: false };\n\n\t\tevents!.callbacks.push(listener);\n\n\t\treturn new Disposer(() => {\n\t\t\tlistener.disposed = true;\n\n\t\t\tif (events!.dispatching) {\n\t\t\t\tevents!.cleanup = true;\n\n\t\t\t} else {\n\t\t\t\t$array.removeFirst(events!.callbacks, listener);\n\n\t\t\t\tif (events!.callbacks.length === 0) {\n\t\t\t\t\tevents!.disposer.dispose();\n\t\t\t\t\tdelete this._events[key];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getCanvas(root: CanvasDisplayObject, options?: ICanvasOptions): HTMLCanvasElement {\n\n\t\t// Make sure everything is rendered\n\t\tthis.render(root);\n\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\n\t\tlet scale: number = this.resolution;\n\n\t\tlet canvasWidth = Math.floor(this._canvasWidth * this.resolution);\n\t\tlet canvasHeight = Math.floor(this._canvasHeight * this.resolution);\n\n\t\t// Check if we need to scale\n\t\tif (options.minWidth && (options.minWidth > canvasWidth)) {\n\t\t\tlet minScale = options.minWidth / canvasWidth;\n\t\t\tif (minScale > scale) {\n\t\t\t\tscale = minScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\tif (options.minHeight && (options.minHeight > canvasHeight)) {\n\t\t\tlet minScale = options.minHeight / canvasHeight;\n\t\t\tif (minScale > scale) {\n\t\t\t\tscale = minScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\tif (options.maxWidth && (options.maxWidth < canvasWidth)) {\n\t\t\tlet maxScale = options.maxWidth / canvasWidth;\n\t\t\tif (maxScale < scale) {\n\t\t\t\tscale = maxScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\tif (options.maxHeight && (options.maxHeight > canvasHeight)) {\n\t\t\tlet maxScale = options.maxHeight / canvasHeight;\n\t\t\tif (maxScale < scale) {\n\t\t\t\tscale = maxScale * this.resolution;\n\t\t\t}\n\t\t}\n\n\t\t// Check if we need to compensate for pixel ratio\n\t\tif (options.maintainPixelRatio) {\n\t\t\tscale /= this.resolution;\n\t\t}\n\n\t\t// Init list canvases to remove from DOM after export\n\t\tconst canvases: HTMLCanvasElement[] = [];\n\n\t\t// Set up new canvas for export\n\t\tlet forceRender = false;\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tif (scale != this.resolution) {\n\t\t\tforceRender = true;\n\t\t\tcanvasWidth = canvasWidth * scale / this.resolution;\n\t\t\tcanvasHeight = canvasHeight * scale / this.resolution;\n\t\t}\n\n\t\tcanvas.width = canvasWidth;\n\t\tcanvas.height = canvasHeight;\n\n\t\t// Add to DOM so it inherits CSS\n\t\tcanvas.style.position = \"fixed\";\n\t\tcanvas.style.top = \"-10000px\";\n\t\tthis.view.appendChild(canvas);\n\t\tcanvases.push(canvas);\n\n\t\t// Context\n\t\tconst context = canvas.getContext(\"2d\")!;\n\n\t\tlet width = 0;\n\t\tlet height = 0;\n\t\tlet needRerender = false;\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer && layer.visible) {\n\t\t\t\tif (layer.tainted || forceRender) {\n\t\t\t\t\tneedRerender = true;\n\n\t\t\t\t\tlayer.exportableView = layer.view;\n\t\t\t\t\tlayer.exportableContext = layer.context;\n\n\t\t\t\t\tlayer.view = document.createElement(\"canvas\");\n\n\t\t\t\t\t// Add to DOM so it inherits CSS\n\t\t\t\t\tlayer.view.style.position = \"fixed\";\n\t\t\t\t\tlayer.view.style.top = \"-10000px\";\n\t\t\t\t\tthis.view.appendChild(layer.view);\n\t\t\t\t\tcanvases.push(layer.view);\n\n\t\t\t\t\tlet extraX = 0;\n\t\t\t\t\tlet extraY = 0;\n\t\t\t\t\tif (layer.margin) {\n\t\t\t\t\t\textraX += layer.margin.left || 0 + layer.margin.right || 0;\n\t\t\t\t\t\textraY += layer.margin.top || 0 + layer.margin.bottom || 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer.view.width = canvasWidth + extraX;\n\t\t\t\t\tlayer.view.height = canvasHeight + extraY;\n\n\t\t\t\t\tlayer.context = layer.view.getContext(\"2d\")!;\n\n\t\t\t\t\tlayer.dirty = true;\n\t\t\t\t\tlayer.scale = scale;\n\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (needRerender) {\n\t\t\tthis._omitTainted = true;\n\t\t\tthis.render(root);\n\t\t\tthis._omitTainted = false;\n\t\t}\n\n\t\t$array.each(this.layers, (layer) => {\n\t\t\tif (layer && layer.visible) {\n\n\t\t\t\t// Layer is fine. Just plop it into our target canvas\n\t\t\t\tlet x = 0;\n\t\t\t\tlet y = 0;\n\t\t\t\tif (layer.margin) {\n\t\t\t\t\tx = -(layer.margin.left || 0) * this.resolution;\n\t\t\t\t\ty = -(layer.margin.top || 0) * this.resolution;\n\t\t\t\t}\n\t\t\t\tcontext.drawImage(layer.view, x, y);\n\n\t\t\t\t// Restore layer original canvas\n\t\t\t\tif (layer.exportableView) {\n\t\t\t\t\tlayer.view = layer.exportableView;\n\t\t\t\t\tlayer.exportableView = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (layer.exportableContext) {\n\t\t\t\t\tlayer.context = layer.exportableContext;\n\t\t\t\t\tlayer.exportableContext = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (width < layer.view.clientWidth) {\n\t\t\t\t\twidth = layer.view.clientWidth;\n\t\t\t\t}\n\t\t\t\tif (height < layer.view.clientHeight) {\n\t\t\t\t\theight = layer.view.clientHeight;\n\t\t\t\t}\n\n\t\t\t\tlayer.scale = undefined;\n\t\t\t}\n\t\t});\n\n\t\tcanvas.style.width = width + \"px\";\n\t\tcanvas.style.height = height + \"px\";\n\n\t\t$array.each(canvases, (canvas) => {\n\t\t\tcanvas.style.position = \"\";\n\t\t\tcanvas.style.top = \"\";\n\t\t\tthis.view.removeChild(canvas);\n\t\t})\n\n\t\treturn canvas;\n\t}\n\n}\n\n\nclass GhostLayer {\n\tpublic view: HTMLCanvasElement;\n\tpublic context: CanvasRenderingContext2D;\n\tpublic margin: IMargin = {\n\t\tleft: 0,\n\t\tright: 0,\n\t\ttop: 0,\n\t\tbottom: 0,\n\t};\n\n\tprivate _width: number = 0;\n\tprivate _height: number = 0;\n\n\tconstructor() {\n\t\tthis.view = document.createElement(\"canvas\");\n\t\tthis.context = this.view.getContext(\"2d\", { alpha: false, willReadFrequently: true })! as CanvasRenderingContext2D;\n\t\tthis.context.imageSmoothingEnabled = false;\n\n\t\tthis.view.style.position = \"absolute\";\n\t\tthis.view.style.top = \"0px\";\n\t\tthis.view.style.left = \"0px\";\n\t}\n\n\tresize(canvasWidth: number, canvasHeight: number, domWidth: number, domHeight: number, resolution: number) {\n\t\tcanvasWidth += (this.margin.left + this.margin.right);\n\t\tcanvasHeight += (this.margin.top + this.margin.bottom);\n\n\t\t// TODO this should take into account calculateSize\n\t\tdomWidth += (this.margin.left + this.margin.right);\n\t\tdomHeight += (this.margin.top + this.margin.bottom);\n\n\t\tthis.view.style.left = -this.margin.left + \"px\";\n\t\tthis.view.style.top = -this.margin.top + \"px\";\n\n\t\tthis._width = Math.floor(canvasWidth * resolution);\n\t\tthis._height = Math.floor(canvasHeight * resolution);\n\n\t\tthis.view.width = this._width;\n\t\tthis.view.style.width = domWidth + \"px\";\n\n\t\tthis.view.height = this._height;\n\t\tthis.view.style.height = domHeight + \"px\";\n\t}\n\n\tgetImageData(point: IPoint, bbox: DOMRect): ImageData {\n\t\treturn this.context.getImageData(\n\t\t\t// TODO should this round ?\n\t\t\tMath.round(((point.x - bbox.left) / bbox.width) * this._width),\n\t\t\tMath.round(((point.y - bbox.top) / bbox.height) * this._height),\n\t\t\t1,\n\t\t\t1,\n\t\t);\n\t}\n\n\tsetMargin(layers: Array<CanvasLayer>): void {\n\t\tthis.margin.left = 0;\n\t\tthis.margin.right = 0;\n\t\tthis.margin.top = 0;\n\t\tthis.margin.bottom = 0;\n\n\t\t$array.each(layers, (layer) => {\n\t\t\tif (layer.margin) {\n\t\t\t\tthis.margin.left = Math.max(this.margin.left, layer.margin.left);\n\t\t\t\tthis.margin.right = Math.max(this.margin.right, layer.margin.right);\n\t\t\t\tthis.margin.top = Math.max(this.margin.top, layer.margin.top);\n\t\t\t\tthis.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);\n\t\t\t}\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis.context.save();\n\t\tthis.context.fillStyle = '#000';\n\t\tthis.context.fillRect(0, 0, this._width, this._height);\n\t}\n}\n\n\n/**\n * @ignore\n */\nexport class CanvasLayer implements ILayer {\n\tpublic view: HTMLCanvasElement;\n\tpublic context: CanvasRenderingContext2D;\n\tpublic tainted: boolean = true;\n\tpublic margin: IMargin | undefined;\n\tpublic order: number = 0;\n\tpublic visible: boolean = true;\n\tpublic width: number | undefined;\n\tpublic height: number | undefined;\n\tpublic scale: number | undefined;\n\tpublic dirty: boolean = true;\n\tpublic exportableView: HTMLCanvasElement | undefined;\n\tpublic exportableContext: CanvasRenderingContext2D | undefined;\n\n\tprivate _width: number = 0;\n\tprivate _height: number = 0;\n\n\tconstructor(view: HTMLCanvasElement, context: CanvasRenderingContext2D) {\n\t\tthis.view = view;\n\t\tthis.context = context;\n\t}\n\n\tresize(canvasWidth: number, canvasHeight: number, domWidth: number, domHeight: number, resolution: number) {\n\t\t// TODO should this take into account calculateSize ?\n\t\tif (this.width != null) {\n\t\t\tcanvasWidth = this.width;\n\t\t\tdomWidth = this.width;\n\t\t}\n\n\t\t// TODO should this take into account calculateSize ?\n\t\tif (this.height != null) {\n\t\t\tcanvasHeight = this.height;\n\t\t\tdomHeight = this.height;\n\t\t}\n\n\t\tif (this.margin) {\n\t\t\tcanvasWidth += (this.margin.left + this.margin.right);\n\t\t\tcanvasHeight += (this.margin.top + this.margin.bottom);\n\n\t\t\t// TODO this should take into account calculateSize\n\t\t\tdomWidth += (this.margin.left + this.margin.right);\n\t\t\tdomHeight += (this.margin.top + this.margin.bottom);\n\n\t\t\tthis.view.style.left = -this.margin.left + \"px\";\n\t\t\tthis.view.style.top = -this.margin.top + \"px\";\n\n\t\t} else {\n\t\t\tthis.view.style.left = \"0px\";\n\t\t\tthis.view.style.top = \"0px\";\n\t\t}\n\n\t\tthis._width = Math.floor(canvasWidth * resolution);\n\t\tthis._height = Math.floor(canvasHeight * resolution);\n\n\t\tthis.view.width = this._width;\n\t\tthis.view.style.width = domWidth + \"px\";\n\n\t\tthis.view.height = this._height;\n\t\tthis.view.style.height = domHeight + \"px\";\n\t}\n\n\tclear() {\n\t\tthis.context.save();\n\t\tthis.context.clearRect(0, 0, this._width, this._height);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}