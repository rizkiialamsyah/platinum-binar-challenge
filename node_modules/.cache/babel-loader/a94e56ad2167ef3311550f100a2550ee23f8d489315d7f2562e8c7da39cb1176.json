{"ast":null,"code":"import { Pattern } from \"./Pattern\";\n/**\r\n * A pattern that uses an SVG path.\r\n *\r\n * @since 5.2.33\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\nexport class PathPattern extends Pattern {\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty(\"svgPath\")) {\n      this._clear = true;\n    }\n  }\n  _draw() {\n    super._draw();\n    // const checkered = this.get(\"checkered\", false);\n    // const centered = this.get(\"centered\", true);\n    // const gap = this.get(\"gap\", 0);\n    // const rotation = this.get(\"rotation\", 0);\n    // let w = this.get(\"width\", 100);\n    // let h = this.get(\"height\", 100);\n    // let rectW = this.get(\"maxWidth\", 5);\n    // let rectH = this.get(\"maxHeight\", 5);\n    // let cellW = rectW + gap;\n    // let cellH = rectH + gap;\n    // let cols = Math.round(w / cellW);\n    // let rows = Math.round(h / cellH);\n    // cellW = w / cols;\n    // cellH = h / rows;\n    // if (rotation != 0) {\n    // \t// @todo this is probably not right\n    // \tthis._display.x = cellW / 2 * $math.cos(rotation);\n    // \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n    // }\n    // for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n    // \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n    // \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n    // \t\t\tlet x = c * cellW;\n    // \t\t\tlet y = r * cellH;\n    // \t\t\tif (centered) {\n    // \t\t\t\tx += (cellW - rectW) / 2;\n    // \t\t\t\ty += (cellH - rectH) / 2;\n    // \t\t\t}\n    // \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n    // \t\t}\n    // \t}\n    // }\n    // if (checkered) {\n    // \tw = w / 2 - gap * 2;\n    // \th = h / 2 - gap * 2;\n    // }\n    // else {\n    // \tw -= gap;\n    // \th -= gap;\n    // }\n    const svgPath = this.get(\"svgPath\");\n    if (svgPath != null) {\n      this._display.svgPath(svgPath);\n    }\n    const color = this.get(\"color\");\n    const colorOpacity = this.get(\"colorOpacity\");\n    if (color || colorOpacity) {\n      // this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n      // this._display.endStroke();\n      this._display.beginFill(color, colorOpacity);\n      this._display.endFill();\n    }\n  }\n}\nObject.defineProperty(PathPattern, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"PathPattern\"\n});\nObject.defineProperty(PathPattern, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Pattern.classNames.concat([PathPattern.className])\n});","map":{"version":3,"names":["Pattern","PathPattern","_beforeChanged","isDirty","_clear","_draw","svgPath","get","_display","color","colorOpacity","beginFill","endFill","Object","defineProperty","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\render\\patterns\\PathPattern.ts"],"sourcesContent":["import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\n\n//import * as $math from \"../../util/Math\";\n\nexport interface IPathPatternSettings extends IPatternSettings {\n\n\t// /**\n\t//  * Gap between Paths, in pixels.\n\t//  *\n\t//  * @default 6\n\t//  */\n\t// gap?: number;\n\n\t// /**\n\t//  * Maximum width of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxWidth?: number;\n\n\t// /**\n\t//  * Maximum height of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxHeight?: number;\n\n\t// /**\n\t//  * If set to `true`, will place every second Path, creating checkered\n\t//  * pattern.\n\t//  *\n\t//  * @default false\n\t//  */\n\t// checkered?: boolean;\n\n\t// /**\n\t//  * Center image.\n\t//  *\n\t//  * @default true\n\t//  */\n\t// centered?: boolean;\n\n\t/**\n\t * Use an SVG path as pattern.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n}\n\nexport interface IPathPatternPrivate extends IPatternPrivate {\n}\n\n/**\n * A pattern that uses an SVG path.\n *\n * @since 5.2.33\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class PathPattern extends Pattern {\n\tdeclare public _settings: IPathPatternSettings;\n\tdeclare public _privateSettings: IPathPatternPrivate;\n\n\tpublic static className: string = \"PathPattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([PathPattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"svgPath\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\t// const checkered = this.get(\"checkered\", false);\n\t\t// const centered = this.get(\"centered\", true);\n\t\t// const gap = this.get(\"gap\", 0);\n\t\t// const rotation = this.get(\"rotation\", 0);\n\t\t// let w = this.get(\"width\", 100);\n\t\t// let h = this.get(\"height\", 100);\n\t\t// let rectW = this.get(\"maxWidth\", 5);\n\t\t// let rectH = this.get(\"maxHeight\", 5);\n\n\n\t\t// let cellW = rectW + gap;\n\t\t// let cellH = rectH + gap;\n\n\t\t// let cols = Math.round(w / cellW);\n\t\t// let rows = Math.round(h / cellH);\n\n\t\t// cellW = w / cols;\n\t\t// cellH = h / rows;\n\n\t\t// if (rotation != 0) {\n\t\t// \t// @todo this is probably not right\n\t\t// \tthis._display.x = cellW / 2 * $math.cos(rotation);\n\t\t// \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n\t\t// }\n\n\t\t// for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n\t\t// \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n\t\t// \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n\t\t// \t\t\tlet x = c * cellW;\n\t\t// \t\t\tlet y = r * cellH;\n\t\t// \t\t\tif (centered) {\n\t\t// \t\t\t\tx += (cellW - rectW) / 2;\n\t\t// \t\t\t\ty += (cellH - rectH) / 2;\n\t\t// \t\t\t}\n\t\t// \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// if (checkered) {\n\t\t// \tw = w / 2 - gap * 2;\n\t\t// \th = h / 2 - gap * 2;\n\t\t// }\n\t\t// else {\n\t\t// \tw -= gap;\n\t\t// \th -= gap;\n\t\t// }\n\n\t\tconst svgPath = this.get(\"svgPath\");\n\t\tif (svgPath != null) {\n\t\t\tthis._display.svgPath(svgPath!);\n\t\t}\n\n\t\tconst color = this.get(\"color\");\n\t\tconst colorOpacity = this.get(\"colorOpacity\");\n\t\tif (color || colorOpacity) {\n\t\t\t// this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n\t\t\t// this._display.endStroke();\n\t\t\tthis._display.beginFill(color, colorOpacity);\n\t\t\tthis._display.endFill();\n\t\t}\n\n\t}\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAA2C,WAAW;AAsDtE;;;;;;AAMA,OAAM,MAAOC,WAAY,SAAQD,OAAO;EAOhCE,cAAcA,CAAA;IACpB,KAAK,CAACA,cAAc,EAAE;IAEtB,IAAI,IAAI,CAACC,OAAO,CAAC,SAAS,CAAC,EAAE;MAC5B,IAAI,CAACC,MAAM,GAAG,IAAI;;EAEpB;EAEUC,KAAKA,CAAA;IACd,KAAK,CAACA,KAAK,EAAE;IAEb;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAGA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA,MAAMC,OAAO,GAAG,IAAI,CAACC,GAAG,CAAC,SAAS,CAAC;IACnC,IAAID,OAAO,IAAI,IAAI,EAAE;MACpB,IAAI,CAACE,QAAQ,CAACF,OAAO,CAACA,OAAQ,CAAC;;IAGhC,MAAMG,KAAK,GAAG,IAAI,CAACF,GAAG,CAAC,OAAO,CAAC;IAC/B,MAAMG,YAAY,GAAG,IAAI,CAACH,GAAG,CAAC,cAAc,CAAC;IAC7C,IAAIE,KAAK,IAAIC,YAAY,EAAE;MAC1B;MACA;MACA,IAAI,CAACF,QAAQ,CAACG,SAAS,CAACF,KAAK,EAAEC,YAAY,CAAC;MAC5C,IAAI,CAACF,QAAQ,CAACI,OAAO,EAAE;;EAGzB;;AA5EAC,MAAA,CAAAC,cAAA,CAAAb,WAAA;;;;SAAkC;;AAClCY,MAAA,CAAAC,cAAA,CAAAb,WAAA;;;;SAA0CD,OAAO,CAACe,UAAU,CAACC,MAAM,CAAC,CAACf,WAAW,CAACgB,SAAS,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}