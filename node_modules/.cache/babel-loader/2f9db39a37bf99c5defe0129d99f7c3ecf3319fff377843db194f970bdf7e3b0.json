{"ast":null,"code":"import { DataItem } from \"../../../core/render/Component\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\n/**\r\n * Creates a date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\r\n * @important\r\n */\nexport class DateAxis extends ValueAxis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_seriesDataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_baseDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, \"_intervalMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_intervalMin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n    super._afterNew();\n    this._setBaseInterval(this.get(\"baseInterval\"));\n    this.on(\"baseInterval\", () => {\n      this._setBaseInterval(this.get(\"baseInterval\"));\n    });\n  }\n  _setBaseInterval(interval) {\n    this.setPrivateRaw(\"baseInterval\", interval);\n    this._baseDuration = $time.getIntervalDuration(interval);\n  }\n  _fixZoomFactor() {\n    const maxZoomFactor = this.get(\"maxZoomFactor\");\n    if (maxZoomFactor != null && maxZoomFactor != Infinity) {\n      this.setPrivateRaw(\"maxZoomFactor\", maxZoomFactor);\n    } else {\n      this.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n    }\n  }\n  _groupData() {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      this._fixZoomFactor();\n      const groupInterval = this.getPrivate(\"groupInterval\");\n      if (groupInterval) {\n        this._setBaseInterval(groupInterval);\n      } else {\n        this._setBaseInterval(this.get(\"baseInterval\"));\n      }\n      if (this.isDirty(\"groupInterval\")) {\n        let groupInterval = this.get(\"groupInterval\");\n        if (groupInterval) {\n          this.setRaw(\"groupIntervals\", [groupInterval]);\n        }\n      }\n      if (this.isDirty(\"groupData\")) {\n        if (!this._dataGrouped) {\n          if (this.get(\"groupData\")) {\n            $array.each(this.series, series => {\n              this._groupSeriesData(series);\n            });\n            this._handleRangeChange();\n          } else {\n            let baseInterval = this.get(\"baseInterval\");\n            let mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n            $array.each(this.series, series => {\n              series.setDataSet(mainDataSetId);\n            });\n            this._setBaseInterval(baseInterval);\n            this.setPrivateRaw(\"groupInterval\", undefined);\n            this.markDirtyExtremes();\n          }\n          this._dataGrouped = true;\n        }\n      }\n    }\n  }\n  _groupSeriesData(series) {\n    if (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n      this._dataGrouped = true; // helps to avoid double grouping\n      this._seriesDataGrouped = true;\n      // make array of intervals which will be used;\n      let intervals = [];\n      let baseDuration = this.baseMainDuration();\n      let groupIntervals = this.get(\"groupIntervals\");\n      if (groupIntervals) {}\n      $array.each(groupIntervals, interval => {\n        let intervalDuration = $time.getIntervalDuration(interval);\n        if (intervalDuration > baseDuration) {\n          intervals.push(interval);\n        }\n      });\n      series._dataSets = {};\n      const key = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      let fields;\n      const baseAxis = series.get(\"baseAxis\");\n      if (series.get(\"xAxis\") === baseAxis) {\n        fields = series._valueYFields;\n      } else if (series.get(\"yAxis\") === baseAxis) {\n        fields = series._valueXFields;\n      }\n      let dataItems = series._mainDataItems;\n      let baseInterval = this.get(\"baseInterval\");\n      let mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n      series._dataSets[mainDataSetId] = dataItems;\n      const groupCallback = series.get(\"groupDataCallback\");\n      let groupOriginals = series.get(\"groupDataWithOriginals\", false);\n      if (groupCallback) {\n        groupOriginals = true;\n      }\n      const firstDay = this._root.locale.firstDayOfWeek;\n      const utc = this._root.utc;\n      const timezone = this._root.timezone;\n      $array.each(intervals, interval => {\n        let previousTime = -Infinity;\n        let dataSetId = interval.timeUnit + interval.count;\n        series._dataSets[dataSetId] = [];\n        let newDataItem;\n        let sum = {};\n        let count = {};\n        let groupFieldValues = {};\n        let workingFields = {};\n        $array.each(fields, field => {\n          sum[field] = 0;\n          count[field] = 0;\n          groupFieldValues[field] = series.get(field + \"Grouped\");\n          workingFields[field] = field + \"Working\";\n        });\n        let intervalDuration = $time.getDuration(interval.timeUnit);\n        let firstItem = dataItems[0];\n        let firstDate;\n        if (firstItem) {\n          firstDate = new Date(dataItems[0].get(key));\n        }\n        let prevNewDataItem;\n        $array.each(dataItems, dataItem => {\n          let time = dataItem.get(key);\n          let roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, firstDay, utc, firstDate, timezone).getTime();\n          let dataContext;\n          if (previousTime < roundedTime - intervalDuration / 24) {\n            dataContext = $object.copy(dataItem.dataContext);\n            newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n            newDataItem.setRaw(key, roundedTime);\n            series._dataSets[dataSetId].push(newDataItem);\n            $array.each(fields, field => {\n              let value = dataItem.get(field);\n              if ($type.isNumber(value)) {\n                newDataItem.setRaw(field, value);\n                newDataItem.setRaw(workingFields[field], value);\n                count[field] = 1;\n                sum[field] = value;\n              } else {\n                sum[field] = 0;\n                count[field] = 0;\n              }\n            });\n            if (groupOriginals) {\n              newDataItem.set(\"originals\", [dataItem]);\n            }\n            if (groupCallback && prevNewDataItem) {\n              groupCallback(prevNewDataItem, interval);\n            }\n            prevNewDataItem = newDataItem;\n          } else {\n            $array.each(fields, field => {\n              let groupKey = groupFieldValues[field];\n              let value = dataItem.get(field);\n              if (value !== undefined) {\n                let currentValue = newDataItem.get(field);\n                switch (groupKey) {\n                  case \"close\":\n                    newDataItem.setRaw(field, value);\n                    break;\n                  case \"sum\":\n                    if (value != null) {\n                      newDataItem.setRaw(field, currentValue + value);\n                    }\n                    break;\n                  case \"open\":\n                    break;\n                  case \"low\":\n                    if (value < currentValue) {\n                      newDataItem.setRaw(field, value);\n                    }\n                    break;\n                  case \"high\":\n                    if (value > currentValue) {\n                      newDataItem.setRaw(field, value);\n                    }\n                    break;\n                  case \"average\":\n                    count[field]++;\n                    sum[field] += value;\n                    let average = sum[field] / count[field];\n                    newDataItem.setRaw(field, average);\n                    break;\n                  case \"extreme\":\n                    if (Math.abs(value) > Math.abs(currentValue)) {\n                      newDataItem.setRaw(field, value);\n                    }\n                    break;\n                }\n                newDataItem.setRaw(workingFields[field], newDataItem.get(field));\n                let dataContext = $object.copy(dataItem.dataContext);\n                dataContext[key] = roundedTime;\n                newDataItem.dataContext = dataContext;\n              }\n            });\n            if (groupOriginals) {\n              newDataItem.get(\"originals\").push(dataItem);\n            }\n          }\n          previousTime = roundedTime;\n        });\n        if (groupCallback && prevNewDataItem) {\n          groupCallback(prevNewDataItem, interval);\n        }\n      });\n      if (series._dataSetId) {\n        series.setDataSet(series._dataSetId);\n      }\n      this.markDirtySize();\n    }\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._groupingCalculated = false;\n    this._dataGrouped = false;\n  }\n  /**\r\n   * Returns a time interval axis would group data to for a specified duration.\r\n   *\r\n   * @since 5.2.1\r\n   */\n  getGroupInterval(duration) {\n    let baseInterval = this.get(\"baseInterval\");\n    let groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\"));\n    if ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n      groupInterval = Object.assign({}, baseInterval);\n    }\n    return groupInterval;\n  }\n  /**\r\n   * Return `max` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Max\r\n   */\n  getIntervalMax(interval) {\n    return this._intervalMax[interval.timeUnit + interval.count];\n  }\n  /**\r\n   * Return `min` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Min\r\n   */\n  getIntervalMin(interval) {\n    return this._intervalMin[interval.timeUnit + interval.count];\n  }\n  _handleRangeChange() {\n    super._handleRangeChange();\n    let selectionMin = Math.round(this.getPrivate(\"selectionMin\"));\n    let selectionMax = Math.round(this.getPrivate(\"selectionMax\"));\n    if ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n      if (this.get(\"endLocation\") == 0) {\n        selectionMax += 1;\n      }\n      if (this.get(\"groupData\") && !this._groupingCalculated) {\n        this._groupingCalculated = true;\n        let modifiedDifference = selectionMax - selectionMin + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n        let groupInterval = this.get(\"groupInterval\");\n        if (!groupInterval) {\n          groupInterval = this.getGroupInterval(modifiedDifference);\n        }\n        let current = this.getPrivate(\"groupInterval\");\n        if (groupInterval && (!current || current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count || this._seriesDataGrouped)) {\n          this._seriesDataGrouped = false;\n          this.setPrivateRaw(\"groupInterval\", groupInterval);\n          this._setBaseInterval(groupInterval);\n          let newId = groupInterval.timeUnit + groupInterval.count;\n          $array.each(this.series, series => {\n            if (series.get(\"baseAxis\") === this) {\n              series.setDataSet(newId);\n            }\n          });\n          this.markDirtyExtremes();\n          this._root.events.once(\"frameended\", () => {\n            this._root.events.once(\"frameended\", () => {\n              const type = \"groupintervalchanged\";\n              if (this.events.isEnabled(type)) {\n                this.events.dispatch(type, {\n                  type: type,\n                  target: this\n                });\n              }\n            });\n          });\n        }\n      }\n      $array.each(this.series, series => {\n        if (series.get(\"baseAxis\") === this) {\n          let fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n          const start = $array.getSortedIndex(series.dataItems, dataItem => {\n            return $order.compare(dataItem.get(fieldName), selectionMin);\n          });\n          let startIndex = start.index;\n          if (startIndex > 0) {\n            startIndex -= 1;\n          }\n          selectionMax += this.baseDuration() * (1 - this.get(\"endLocation\", 1));\n          const end = $array.getSortedIndex(series.dataItems, dataItem => {\n            return $order.compare(dataItem.get(fieldName), selectionMax);\n          });\n          let endIndex = end.index;\n          let endIndex2 = endIndex;\n          if (endIndex2 > 0) {\n            endIndex2--;\n          }\n          const firstDataItem = series.dataItems[startIndex];\n          const lastDataItem = series.dataItems[endIndex2];\n          let lastDate;\n          let firstDate;\n          if (firstDataItem) {\n            firstDate = firstDataItem.get(fieldName);\n          }\n          if (lastDataItem) {\n            lastDate = lastDataItem.get(fieldName);\n          }\n          let outOfSelection = false;\n          if (lastDate != null && firstDate != null) {\n            if (lastDate < selectionMin || firstDate > selectionMax) {\n              outOfSelection = true;\n            }\n          }\n          series.setPrivate(\"outOfSelection\", outOfSelection);\n          series.setPrivate(\"startIndex\", startIndex);\n          series.setPrivate(\"endIndex\", endIndex);\n        }\n      });\n    }\n  }\n  _adjustMinMax(min, max, gridCount, _strictMode) {\n    return {\n      min: min,\n      max: max,\n      step: (max - min) / gridCount\n    };\n  }\n  /**\r\n   * @ignore\r\n   */\n  intervalDuration() {\n    return this._intervalDuration;\n  }\n  _saveMinMax(min, max) {\n    let groupInterval = this.getPrivate(\"groupInterval\");\n    if (!groupInterval) {\n      groupInterval = this.get(\"baseInterval\");\n    }\n    let id = groupInterval.timeUnit + groupInterval.count;\n    this._intervalMin[id] = min;\n    this._intervalMax[id] = max;\n  }\n  _getM(timeUnit) {\n    if (timeUnit == \"month\" || timeUnit == \"year\" || timeUnit == \"day\") {\n      return 1.05;\n    }\n    return 1.01;\n  }\n  _prepareAxisItems() {\n    const min = this.getPrivate(\"min\");\n    const max = this.getPrivate(\"max\");\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      const selectionMin = Math.round(this.getPrivate(\"selectionMin\"));\n      const selectionMax = Math.round(this.getPrivate(\"selectionMax\"));\n      const renderer = this.get(\"renderer\");\n      const baseInterval = this.getPrivate(\"baseInterval\");\n      let value = selectionMin;\n      let i = 0;\n      const intervals = this.get(\"gridIntervals\");\n      let gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n      if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n        gridInterval = Object.assign({}, baseInterval);\n      }\n      const intervalDuration = $time.getIntervalDuration(gridInterval);\n      this._intervalDuration = intervalDuration;\n      const nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n      const firstDay = this._root.locale.firstDayOfWeek;\n      const utc = this._root.utc;\n      const timezone = this._root.timezone;\n      value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, firstDay, utc, new Date(min), timezone).getTime();\n      let previousValue = value - intervalDuration;\n      let format;\n      const formats = this.get(\"dateFormats\");\n      this.setPrivateRaw(\"gridInterval\", gridInterval);\n      while (value < selectionMax + intervalDuration) {\n        let dataItem;\n        if (this.dataItems.length < i + 1) {\n          dataItem = new DataItem(this, undefined, {});\n          this._dataItems.push(dataItem);\n          this.processDataItem(dataItem);\n        } else {\n          dataItem = this.dataItems[i];\n        }\n        this._createAssets(dataItem, []);\n        if (dataItem.isHidden()) {\n          dataItem.show();\n        }\n        dataItem.setRaw(\"value\", value);\n        let endValue = value + $time.getDuration(gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));\n        endValue = $time.round(new Date(endValue), gridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n        dataItem.setRaw(\"endValue\", endValue);\n        let date = new Date(value);\n        format = formats[gridInterval.timeUnit];\n        if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n          if (gridInterval.timeUnit != \"year\") {\n            if ($time.checkChange(value, previousValue, nextGridUnit, utc, timezone)) {\n              format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n            }\n          }\n        }\n        const label = dataItem.get(\"label\");\n        if (label) {\n          label.set(\"text\", this._root.dateFormatter.format(date, format));\n        }\n        this._prepareDataItem(dataItem, gridInterval.count);\n        previousValue = value;\n        value = endValue;\n        if (value == previousValue) {\n          break;\n        }\n        i++;\n      }\n      for (let j = i; j < this.dataItems.length; j++) {\n        this.dataItems[j].hide();\n      }\n      $array.each(this.series, series => {\n        if (series.inited) {\n          series._markDirtyAxes();\n        }\n      });\n    }\n    this._updateGhost();\n  }\n  _updateFinals(start, end) {\n    this.setPrivateRaw(\"selectionMinFinal\", this.positionToValue(start));\n    this.setPrivateRaw(\"selectionMaxFinal\", this.positionToValue(end));\n  }\n  _getDelta() {\n    this._deltaMinMax = this.baseDuration() / 2;\n  }\n  _fixMin(min) {\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    const firstDay = this._root.locale.firstDayOfWeek;\n    const timezone = this._root.timezone;\n    const utc = this._root.utc;\n    const timeUnit = baseInterval.timeUnit;\n    let startTime = $time.round(new Date(min), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n    let endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit));\n    endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n    return startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n  }\n  _fixMax(max) {\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    const firstDay = this._root.locale.firstDayOfWeek;\n    const timezone = this._root.timezone;\n    const utc = this._root.utc;\n    const timeUnit = baseInterval.timeUnit;\n    let startTime = $time.round(new Date(max), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n    let endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit));\n    endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n    return startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n  }\n  _updateDates(_date) {}\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  baseDuration() {\n    return this._baseDuration;\n    //return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n  }\n  /**\r\n   * Returns a duration of user-defined `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  baseMainDuration() {\n    return $time.getIntervalDuration(this.get(\"baseInterval\"));\n  }\n  /**\r\n   * @ignore\r\n   */\n  processSeriesDataItem(dataItem, fields) {\n    const baseInterval = this.getPrivate(\"baseInterval\");\n    if (!dataItem.open) {\n      dataItem.open = {};\n    }\n    if (!dataItem.close) {\n      dataItem.close = {};\n    }\n    $array.each(fields, field => {\n      let value = dataItem.get(field);\n      if ($type.isNumber(value)) {\n        let startTime = dataItem.open[field];\n        let endTime = dataItem.close[field];\n        // this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n        // if value is between prev start and end, it means it didn't change, all is fine.\n        if (value >= startTime && value <= endTime) {} else {\n          const firstDay = this._root.locale.firstDayOfWeek;\n          const utc = this._root.utc;\n          const timezone = this._root.timezone;\n          const timeUnit = baseInterval.timeUnit;\n          const count = baseInterval.count;\n          startTime = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n          endTime = startTime + $time.getDuration(timeUnit, count * this._getM(timeUnit));\n          endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n          dataItem.open[field] = startTime;\n          dataItem.close[field] = endTime;\n        }\n        this._updateDates(startTime);\n      }\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionX(dataItem, field, cellLocation, axisLocation) {\n    let openValue;\n    let closeValue;\n    if (dataItem.open && dataItem.close) {\n      openValue = dataItem.open[field];\n      closeValue = dataItem.close[field];\n    } else {\n      openValue = dataItem.get(field);\n      closeValue = openValue;\n    }\n    let value = openValue + (closeValue - openValue) * cellLocation;\n    value = this._baseValue + (value - this._baseValue) * axisLocation;\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateX(dataItem, field, cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionY(dataItem, field, cellLocation, axisLocation) {\n    let openValue;\n    let closeValue;\n    if (dataItem.open && dataItem.close) {\n      openValue = dataItem.open[field];\n      closeValue = dataItem.close[field];\n    } else {\n      openValue = dataItem.get(field);\n      closeValue = openValue;\n    }\n    let value = openValue + (closeValue - openValue) * cellLocation;\n    value = this._baseValue + (value - this._baseValue) * axisLocation;\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateY(dataItem, field, cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  roundAxisPosition(position, location) {\n    let value = this.positionToValue(position);\n    value = value - (location - 0.5) * this.baseDuration();\n    let baseInterval = this.getPrivate(\"baseInterval\");\n    if (!$type.isNaN(value)) {\n      const firstDay = this._root.locale.firstDayOfWeek;\n      const timeUnit = baseInterval.timeUnit;\n      const utc = this._root.utc;\n      const timezone = this._root.timezone;\n      const count = baseInterval.count;\n      value = $time.round(new Date(value), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n      let duration = $time.getDateIntervalDuration(baseInterval, new Date(value), firstDay, utc, timezone);\n      if (timezone) {\n        value = $time.round(new Date(value + this.baseDuration() * 0.05), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n        duration = $time.getDateIntervalDuration(baseInterval, new Date(value + duration * location), firstDay, utc, timezone);\n      }\n      return this.valueToPosition(value + duration * location);\n    }\n    return NaN;\n  }\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  getTooltipText(position) {\n    //@todo number formatter + tag\n    if (this.getPrivate(\"min\") != null) {\n      let format = this.get(\"tooltipDateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n      let value = this.positionToValue(position);\n      let date = new Date(value);\n      let baseInterval = this.getPrivate(\"baseInterval\");\n      let duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n      return this._root.dateFormatter.format(new Date(value + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration), this.get(\"tooltipDateFormat\", format));\n    }\n    return \"\";\n  }\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  getSeriesItem(series, position, location) {\n    let fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n    let value = this.positionToValue(position);\n    if (location == null) {\n      location = 0.5;\n    }\n    value = value - (location - 0.5) * this.baseDuration();\n    const result = $array.getSortedIndex(series.dataItems, dataItem => {\n      let diValue = 0;\n      if (dataItem.open) {\n        diValue = dataItem.open[fieldName];\n      }\n      return $order.compare(diValue, value);\n    });\n    if (series.get(\"snapTooltip\")) {\n      let first = series.dataItems[result.index - 1];\n      let second = series.dataItems[result.index];\n      if (first && second) {\n        if (first.open && second.close) {\n          let open = first.open[fieldName];\n          let close = second.close[fieldName];\n          if (Math.abs(value - open) > Math.abs(value - close)) {\n            return second;\n          }\n        }\n      }\n      if (first) {\n        return first;\n      }\n      if (second) {\n        return second;\n      }\n    } else {\n      // @todo check if is in range\n      const dataItem = series.dataItems[result.index - 1];\n      if (dataItem) {\n        if (dataItem.open && dataItem.close) {\n          let open = dataItem.open[fieldName];\n          let close = dataItem.close[fieldName];\n          if (value >= open && value <= close) {\n            return dataItem;\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  shouldGap(dataItem, nextItem, autoGapCount, fieldName) {\n    const value1 = dataItem.get(fieldName);\n    const value2 = nextItem.get(fieldName);\n    if (value2 - value1 > this.baseDuration() * autoGapCount) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToDates(start, end, duration) {\n    this.zoomToValues(start.getTime(), end.getTime(), duration);\n  }\n  /**\r\n   * Returns a `Date` object corresponding to specific position within plot\r\n   * area.\r\n   *\r\n   * @param   position  Pposition\r\n   * @return            Date\r\n   */\n  positionToDate(position) {\n    return new Date(this.positionToValue(position));\n  }\n  /**\r\n   * Returns a relative position within plot area that corresponds to specific\r\n   * date.\r\n   *\r\n   * @param   date  Date\r\n   * @return        Position\r\n   */\n  dateToPosition(date) {\n    return this.valueToPosition(date.getTime());\n  }\n  /**\r\n   * Returns relative position between two grid lines of the axis.\r\n   *\r\n   * @since 5.2.30\r\n   * @return Position\r\n   */\n  getCellWidthPosition() {\n    let max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n    let min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n    if ($type.isNumber(max) && $type.isNumber(min)) {\n      return this._intervalDuration / (max - min);\n    }\n    return 0.05;\n  }\n}\nObject.defineProperty(DateAxis, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"DateAxis\"\n});\nObject.defineProperty(DateAxis, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: ValueAxis.classNames.concat([DateAxis.className])\n});","map":{"version":3,"names":["DataItem","ValueAxis","$type","$order","$array","$object","$utils","$time","DateAxis","constructor","Object","defineProperty","_afterNew","_settings","themeTags","mergeTags","_setBaseInterval","get","on","interval","setPrivateRaw","_baseDuration","getIntervalDuration","_fixZoomFactor","maxZoomFactor","Infinity","Math","round","getPrivate","baseMainDuration","_groupData","min","max","isNumber","groupInterval","isDirty","setRaw","_dataGrouped","each","series","_groupSeriesData","_handleRangeChange","baseInterval","mainDataSetId","timeUnit","count","setDataSet","undefined","markDirtyExtremes","_seriesDataGrouped","intervals","baseDuration","groupIntervals","intervalDuration","push","_dataSets","key","fields","baseAxis","_valueYFields","_valueXFields","dataItems","_mainDataItems","groupCallback","groupOriginals","firstDay","_root","locale","firstDayOfWeek","utc","timezone","previousTime","dataSetId","newDataItem","sum","groupFieldValues","workingFields","field","getDuration","firstItem","firstDate","Date","prevNewDataItem","dataItem","time","roundedTime","getTime","dataContext","copy","_makeDataItem","value","set","groupKey","currentValue","average","abs","_dataSetId","markDirtySize","_clearDirty","_groupingCalculated","getGroupInterval","duration","chooseInterval","assign","getIntervalMax","_intervalMax","getIntervalMin","_intervalMin","selectionMin","selectionMax","modifiedDifference","current","newId","events","once","type","isEnabled","dispatch","target","fieldName","start","getSortedIndex","compare","startIndex","index","end","endIndex","endIndex2","firstDataItem","lastDataItem","lastDate","outOfSelection","setPrivate","_adjustMinMax","gridCount","_strictMode","step","_intervalDuration","_saveMinMax","id","_getM","_prepareAxisItems","renderer","i","gridInterval","nextGridUnit","getNextUnit","previousValue","format","formats","length","_dataItems","processDataItem","_createAssets","isHidden","show","endValue","date","checkChange","label","dateFormatter","_prepareDataItem","j","hide","inited","_markDirtyAxes","_updateGhost","_updateFinals","positionToValue","_getDelta","_deltaMinMax","_fixMin","startTime","endTime","_fixMax","_updateDates","_date","processSeriesDataItem","open","close","getDataItemPositionX","cellLocation","axisLocation","openValue","closeValue","_baseValue","valueToPosition","getDataItemCoordinateX","positionToCoordinate","getDataItemPositionY","getDataItemCoordinateY","roundAxisPosition","position","location","isNaN","getDateIntervalDuration","NaN","getTooltipText","getSeriesItem","result","diValue","first","second","shouldGap","nextItem","autoGapCount","value1","value2","zoomToDates","zoomToValues","positionToDate","dateToPosition","getCellWidthPosition","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\charts\\xy\\axes\\DateAxis.ts"],"sourcesContent":["import { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { XYSeries, IXYSeriesDataItem } from \"../series/XYSeries\";\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IMinMaxStep, IValueAxisEvents } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\nimport type { TimeUnit } from \"../../../core/util/Time\";\n\nexport interface IDateAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * IMPORTANT: `startLocation` is not supported by [[GaplessDateAxis]].\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * IMPORTANT: `endLocation` is not supported by [[GaplessDateAxis]].\n\t * \n\t * @default 1\n\t */\n\tendLocation?: number;\n\n\t/**\n\t * Should axis group data items togeter dynamically?\n\t *\n\t * @default false\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupData?: boolean;\n\n\t/**\n\t * Maximum number of data items in the view before data grouping kicks in.\n\t *\n\t * @default 500\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupCount?: number;\n\n\t/**\n\t * Force data item grouping to specific interval.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to group data items into.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t */\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\n\n\t/**\n\t * Time unit-specific formats to use for axis tooltip.\n\t * \n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t * @since 5.1.4\n\t */\n\ttooltipDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A value which indicates relative position within axis cell to get timestamp\n\t * for the tooltip from.\n\t *\n\t * Values are from `0` (zero) to `1` (one), meaning start and end of the cell.\n\t *\n\t * If not set, it will use cell's start tiemstamp.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t * @since 5.1.4\n\t */\n\ttooltipIntervalOffset?: number;\n}\n\nexport interface IDateAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDateAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * Current group interval.\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Current grid interval.\n\t */\n\tgridInterval: ITimeInterval;\n}\n\nexport interface IDateAxisEvents extends IValueAxisEvents {\n\n\t/**\n\t * Kicks in when data grouping is on, and current group interval changes, e.g. via zooming the chart.\n\t *\n\t * @since 5.2.43\n\t */\n\tgroupintervalchanged: {}\n\n}\n\n/**\n * Creates a date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\n * @important\n */\nexport class DateAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DateAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DateAxis.className]);\n\n\tdeclare public _settings: IDateAxisSettings<R>;\n\tdeclare public _privateSettings: IDateAxisPrivate;\n\tdeclare public _dataItemSettings: IDateAxisDataItem;\n\tdeclare public _events: IDateAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _seriesDataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\tprotected _baseDuration: number = 1;\n\n\tprotected _intervalMax: { [index: string]: number } = {};\n\tprotected _intervalMin: { [index: string]: number } = {};\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\tthis.on(\"baseInterval\", () => {\n\t\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\t})\n\t}\n\n\tprotected _setBaseInterval(interval: ITimeInterval) {\n\t\tthis.setPrivateRaw(\"baseInterval\", interval);\n\t\tthis._baseDuration = $time.getIntervalDuration(interval);\n\t}\n\n\tprotected _fixZoomFactor() {\n\t\tconst maxZoomFactor = this.get(\"maxZoomFactor\");\n\t\tif (maxZoomFactor != null && maxZoomFactor != Infinity) {\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", maxZoomFactor);\n\t\t}\n\t\telse {\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n\t\t}\n\t}\n\n\tprotected _groupData() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif (($type.isNumber(min) && $type.isNumber(max))) {\n\n\t\t\tthis._fixZoomFactor();\n\n\t\t\tconst groupInterval = this.getPrivate(\"groupInterval\")!;\n\t\t\tif (groupInterval) {\n\t\t\t\tthis._setBaseInterval(groupInterval);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\t\t}\n\n\n\t\t\tif (this.isDirty(\"groupInterval\")) {\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\")!;\n\t\t\t\tif (groupInterval) {\n\t\t\t\t\tthis.setRaw(\"groupIntervals\", [groupInterval]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isDirty(\"groupData\")) {\n\t\t\t\tif (!this._dataGrouped) {\n\t\t\t\t\tif (this.get(\"groupData\")) {\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tthis._groupSeriesData(series);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis._handleRangeChange();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\t\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tseries.setDataSet(mainDataSetId);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis._setBaseInterval(baseInterval);\n\t\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", undefined);\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t\tthis._dataGrouped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _groupSeriesData(series: XYSeries) {\n\t\tif (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n\n\t\t\tthis._dataGrouped = true; // helps to avoid double grouping\n\n\t\t\tthis._seriesDataGrouped = true;\n\n\t\t\t// make array of intervals which will be used;\n\t\t\tlet intervals: ITimeInterval[] = [];\n\t\t\tlet baseDuration = this.baseMainDuration();\n\n\t\t\tlet groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\tif (groupIntervals) { }\n\t\t\t$array.each(groupIntervals, (interval) => {\n\t\t\t\tlet intervalDuration = $time.getIntervalDuration(interval);\n\t\t\t\tif (intervalDuration > baseDuration) {\n\t\t\t\t\tintervals.push(interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tseries._dataSets = {};\n\n\t\t\tconst key = this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!;\n\t\t\tlet fields: Array<string>;\n\n\t\t\tconst baseAxis = series.get(\"baseAxis\");\n\n\t\t\tif (series.get(\"xAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueYFields;\n\t\t\t}\n\t\t\telse if (series.get(\"yAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueXFields;\n\t\t\t}\n\n\t\t\tlet dataItems = series._mainDataItems;\n\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\tseries._dataSets[mainDataSetId] = dataItems;\n\n\t\t\tconst groupCallback = series.get(\"groupDataCallback\");\n\t\t\tlet groupOriginals = series.get(\"groupDataWithOriginals\", false);\n\t\t\tif (groupCallback) {\n\t\t\t\tgroupOriginals = true;\n\t\t\t}\n\n\t\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\t\tconst utc = this._root.utc;\n\t\t\tconst timezone = this._root.timezone;\n\n\t\t\t$array.each(intervals, (interval) => {\n\n\t\t\t\tlet previousTime = -Infinity;\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\n\t\t\t\tseries._dataSets[dataSetId] = [];\n\n\t\t\t\tlet newDataItem: DataItem<IXYSeriesDataItem>;\n\n\t\t\t\tlet sum: { [index: string]: number } = {};\n\t\t\t\tlet count: { [index: string]: number } = {};\n\n\t\t\t\tlet groupFieldValues: { [index: string]: string } = {};\n\t\t\t\tlet workingFields: { [index: string]: string } = {};\n\n\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\tgroupFieldValues[field] = series.get((field + \"Grouped\") as any);\n\t\t\t\t\tworkingFields[field] = field + \"Working\";\n\t\t\t\t})\n\n\t\t\t\tlet intervalDuration = $time.getDuration(interval.timeUnit);\n\n\t\t\t\tlet firstItem = dataItems[0];\n\t\t\t\tlet firstDate: Date;\n\t\t\t\tif (firstItem) {\n\t\t\t\t\tfirstDate = new Date(dataItems[0].get(key as any));\n\t\t\t\t}\n\n\t\t\t\tlet prevNewDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\t\tlet time = dataItem.get(key as any);\n\t\t\t\t\tlet roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, firstDay, utc, firstDate, timezone).getTime();\n\t\t\t\t\tlet dataContext: any;\n\n\t\t\t\t\tif (previousTime < roundedTime - intervalDuration / 24) {\n\t\t\t\t\t\tdataContext = $object.copy(dataItem.dataContext);\n\n\t\t\t\t\t\tnewDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n\t\t\t\t\t\tnewDataItem.setRaw(key as any, roundedTime);\n\n\t\t\t\t\t\tseries._dataSets[dataSetId].push(newDataItem);\n\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif ($type.isNumber(value)) {\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, value);\n\t\t\t\t\t\t\t\tcount[field] = 1;\n\t\t\t\t\t\t\t\tsum[field] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (groupOriginals) {\n\t\t\t\t\t\t\tnewDataItem.set(\"originals\", [dataItem]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (groupCallback && prevNewDataItem) {\n\t\t\t\t\t\t\tgroupCallback(prevNewDataItem, interval);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprevNewDataItem = newDataItem;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet groupKey = groupFieldValues[field];\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\n\t\t\t\t\t\t\tif (value !== undefined) {\n\n\t\t\t\t\t\t\t\tlet currentValue = newDataItem.get(field as any);\n\n\t\t\t\t\t\t\t\tswitch (groupKey) {\n\t\t\t\t\t\t\t\t\tcase \"close\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, currentValue + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"open\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"low\":\n\t\t\t\t\t\t\t\t\t\tif (value < currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"high\":\n\t\t\t\t\t\t\t\t\t\tif (value > currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"average\":\n\t\t\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t\t\t\tlet average = sum[field] / count[field];\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, average);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"extreme\":\n\t\t\t\t\t\t\t\t\t\tif (Math.abs(value) > Math.abs(currentValue)) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, newDataItem.get(field as any));\n\t\t\t\t\t\t\t\tlet dataContext: any = $object.copy(dataItem.dataContext);\n\t\t\t\t\t\t\t\tdataContext[key as any] = roundedTime;\n\t\t\t\t\t\t\t\tnewDataItem.dataContext = dataContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (groupOriginals) {\n\t\t\t\t\t\t\tnewDataItem.get(\"originals\")!.push(dataItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousTime = roundedTime;\n\t\t\t\t})\n\n\t\t\t\tif (groupCallback && prevNewDataItem) {\n\t\t\t\t\tgroupCallback(prevNewDataItem, interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (series._dataSetId) {\n\t\t\t\tseries.setDataSet(series._dataSetId);\n\t\t\t}\n\t\t\tthis.markDirtySize();\n\t\t}\n\t}\n\n\tpublic _clearDirty() {\n\t\tsuper._clearDirty();\n\t\tthis._groupingCalculated = false;\n\t\tthis._dataGrouped = false;\n\t}\n\n\t/**\n\t * Returns a time interval axis would group data to for a specified duration.\n\t *\n\t * @since 5.2.1\n\t */\n\tpublic getGroupInterval(duration: number): ITimeInterval {\n\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\tlet groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\")!);\n\t\tif ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n\t\t\tgroupInterval = { ...baseInterval };\n\t\t}\n\t\treturn groupInterval;\n\t}\n\n\t/**\n\t * Return `max` of a specified time interval.\n\t * \n\t * Will work only if the axis was grouped to this interval at least once.\n\t * \n\t * @since 5.2.1\n\t * @param   interval  Interval\n\t * @return            Max\n\t */\n\tpublic getIntervalMax(interval: ITimeInterval): number {\n\t\treturn this._intervalMax[interval.timeUnit + interval.count];\n\t}\n\n\t/**\n\t * Return `min` of a specified time interval.\n\t * \n\t * Will work only if the axis was grouped to this interval at least once.\n\t * \n\t * @since 5.2.1\n\t * @param   interval  Interval\n\t * @return            Min\n\t */\n\tpublic getIntervalMin(interval: ITimeInterval): number {\n\t\treturn this._intervalMin[interval.timeUnit + interval.count];\n\t}\n\n\tprotected _handleRangeChange() {\n\t\tsuper._handleRangeChange();\n\n\t\tlet selectionMin = Math.round(this.getPrivate(\"selectionMin\")! as number);\n\t\tlet selectionMax = Math.round(this.getPrivate(\"selectionMax\")! as number);\n\n\t\tif ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n\n\t\t\tif (this.get(\"endLocation\") == 0) {\n\t\t\t\tselectionMax += 1;\n\t\t\t}\n\n\t\t\tif (this.get(\"groupData\") && !this._groupingCalculated) {\n\t\t\t\tthis._groupingCalculated = true;\n\n\t\t\t\tlet modifiedDifference = (selectionMax - selectionMin) + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\");\n\n\t\t\t\tif (!groupInterval) {\n\t\t\t\t\tgroupInterval = this.getGroupInterval(modifiedDifference);\n\t\t\t\t}\n\n\t\t\t\tlet current = this.getPrivate(\"groupInterval\");\n\n\t\t\t\tif (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count) || this._seriesDataGrouped)) {\n\t\t\t\t\tthis._seriesDataGrouped = false;\n\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", groupInterval);\n\t\t\t\t\tthis._setBaseInterval(groupInterval)\n\n\n\t\t\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\n\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\t\t\tseries.setDataSet(newId);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tthis.markDirtyExtremes();\n\n\t\t\t\t\tthis._root.events.once(\"frameended\", () => {\n\t\t\t\t\t\tthis._root.events.once(\"frameended\", () => {\n\t\t\t\t\t\t\tconst type = \"groupintervalchanged\";\n\t\t\t\t\t\t\tif (this.events.isEnabled(type)) {\n\t\t\t\t\t\t\t\tthis.events.dispatch(type, { type: type, target: this });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\n\t\t\t\t\tconst start = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMin);\n\t\t\t\t\t});\n\n\t\t\t\t\tlet startIndex = start.index;\n\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tstartIndex -= 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tselectionMax += this.baseDuration() * (1 - this.get(\"endLocation\", 1));\n\n\t\t\t\t\tconst end = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMax);\n\t\t\t\t\t});\n\n\t\t\t\t\tlet endIndex = end.index;\n\n\t\t\t\t\tlet endIndex2 = endIndex;\n\t\t\t\t\tif (endIndex2 > 0) {\n\t\t\t\t\t\tendIndex2--;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst firstDataItem = series.dataItems[startIndex];\n\t\t\t\t\tconst lastDataItem = series.dataItems[endIndex2];\n\n\t\t\t\t\tlet lastDate: number | undefined;\n\t\t\t\t\tlet firstDate: number | undefined;\n\t\t\t\t\tif (firstDataItem) {\n\t\t\t\t\t\tfirstDate = firstDataItem.get(fieldName);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lastDataItem) {\n\t\t\t\t\t\tlastDate = lastDataItem.get(fieldName);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet outOfSelection = false;\n\t\t\t\t\tif (lastDate != null && firstDate != null) {\n\t\t\t\t\t\tif (lastDate < selectionMin || firstDate > selectionMax) {\n\t\t\t\t\t\t\toutOfSelection = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tseries.setPrivate(\"outOfSelection\", outOfSelection);\n\t\t\t\t\tseries.setPrivate(\"startIndex\", startIndex);\n\t\t\t\t\tseries.setPrivate(\"endIndex\", endIndex);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, _strictMode?: boolean): IMinMaxStep {\n\t\treturn { min: min, max: max, step: (max - min) / gridCount };\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic intervalDuration(): number {\n\t\treturn this._intervalDuration;\n\t}\n\n\tprotected _saveMinMax(min: number, max: number) {\n\t\tlet groupInterval = this.getPrivate(\"groupInterval\");\n\n\t\tif (!groupInterval) {\n\t\t\tgroupInterval = this.get(\"baseInterval\");\n\t\t}\n\n\t\tlet id = groupInterval.timeUnit + groupInterval.count;\n\t\tthis._intervalMin[id] = min;\n\t\tthis._intervalMax[id] = max;\n\t}\n\n\tprotected _getM(timeUnit: TimeUnit) {\n\t\tif (timeUnit == \"month\" || timeUnit == \"year\" || timeUnit == \"day\") {\n\t\t\treturn 1.05;\n\t\t}\n\t\treturn 1.01;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tconst selectionMin = Math.round(this.getPrivate(\"selectionMin\")! as number);\n\t\t\tconst selectionMax = Math.round(this.getPrivate(\"selectionMax\")! as number);\n\t\t\tconst renderer = this.get(\"renderer\");\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\t\tlet value = selectionMin;\n\t\t\tlet i = 0;\n\n\t\t\tconst intervals = this.get(\"gridIntervals\")!;\n\t\t\tlet gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n\t\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\t\tgridInterval = { ...baseInterval };\n\t\t\t}\n\n\t\t\tconst intervalDuration = $time.getIntervalDuration(gridInterval);\n\t\t\tthis._intervalDuration = intervalDuration;\n\n\t\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\t\tconst utc = this._root.utc;\n\t\t\tconst timezone = this._root.timezone;\n\n\t\t\tvalue = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, firstDay, utc, new Date(min), timezone).getTime();\n\t\t\tlet previousValue = value - intervalDuration;\n\t\t\tlet format: string | Intl.DateTimeFormatOptions;\n\t\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\t\tthis.setPrivateRaw(\"gridInterval\", gridInterval);\n\n\t\t\twhile (value < selectionMax + intervalDuration) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\n\n\n\t\t\t\tlet endValue = value + $time.getDuration(gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));\n\t\t\t\tendValue = $time.round(new Date(endValue), gridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\n\t\t\t\tdataItem.setRaw(\"endValue\", endValue);\n\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tformat = formats[gridInterval.timeUnit];\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\t\t\t\t\tif (gridInterval.timeUnit != \"year\") {\n\t\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, utc, timezone)) {\n\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem, gridInterval.count);\n\n\t\t\t\tpreviousValue = value;\n\t\t\t\tvalue = endValue;\n\n\t\t\t\tif (value == previousValue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis.dataItems[j].hide();\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\tprotected _updateFinals(start: number, end: number) {\n\t\tthis.setPrivateRaw(\"selectionMinFinal\", this.positionToValue(start));\n\t\tthis.setPrivateRaw(\"selectionMaxFinal\", this.positionToValue(end));\n\t}\n\n\tprotected _getDelta() {\n\t\tthis._deltaMinMax = this.baseDuration() / 2;\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\tconst timezone = this._root.timezone;\n\t\tconst utc = this._root.utc;\n\t\tconst timeUnit = baseInterval.timeUnit;\n\t\tlet startTime = $time.round(new Date(min), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n\t\tlet endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit))\n\t\tendTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\t\treturn startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n\t}\n\n\tprotected _fixMax(max: number) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\tconst timezone = this._root.timezone;\n\t\tconst utc = this._root.utc;\n\t\tconst timeUnit = baseInterval.timeUnit;\n\t\tlet startTime = $time.round(new Date(max), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();\n\t\tlet endTime = startTime + $time.getDuration(timeUnit, baseInterval.count * this._getM(timeUnit))\n\t\tendTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n\t}\n\n\tprotected _updateDates(_date: number) {\n\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t * \n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn this._baseDuration;\n\t\t//return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\t/**\n\t * Returns a duration of user-defined `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseMainDuration(): number {\n\t\treturn $time.getIntervalDuration(this.get(\"baseInterval\"));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic processSeriesDataItem(dataItem: DataItem<IXYSeriesDataItem>, fields: Array<string>) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tif (!dataItem.open) {\n\t\t\tdataItem.open = {};\n\t\t}\n\t\tif (!dataItem.close) {\n\t\t\tdataItem.close = {};\n\t\t}\n\n\t\t$array.each(fields, (field) => {\n\t\t\tlet value = dataItem.get(field as any);\n\t\t\tif ($type.isNumber(value)) {\n\t\t\t\tlet startTime = dataItem.open![field];\n\t\t\t\tlet endTime = dataItem.close![field];\n\t\t\t\t// this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n\t\t\t\t// if value is between prev start and end, it means it didn't change, all is fine.\n\t\t\t\tif (value >= startTime && value <= endTime) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\t\t\t\tconst utc = this._root.utc;\n\t\t\t\t\tconst timezone = this._root.timezone\n\t\t\t\t\tconst timeUnit = baseInterval.timeUnit;\n\t\t\t\t\tconst count = baseInterval.count;\n\t\t\t\t\tstartTime = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();\n\t\t\t\t\tendTime = startTime + $time.getDuration(timeUnit, count * this._getM(timeUnit));\n\t\t\t\t\tendTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();\n\n\t\t\t\t\tdataItem.open![field] = startTime;\n\t\t\t\t\tdataItem.close![field] = endTime;\n\t\t\t\t}\n\n\t\t\t\tthis._updateDates(startTime);\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tlet value = this.positionToValue(position);\n\t\tvalue = value - (location - 0.5) * this.baseDuration();\n\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tif (!$type.isNaN(value)) {\n\t\t\tconst firstDay = this._root.locale.firstDayOfWeek;\n\t\t\tconst timeUnit = baseInterval.timeUnit;\n\t\t\tconst utc = this._root.utc;\n\t\t\tconst timezone = this._root.timezone;\n\t\t\tconst count = baseInterval.count;\n\n\t\t\tvalue = $time.round(new Date(value), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n\n\t\t\tlet duration = $time.getDateIntervalDuration(baseInterval, new Date(value), firstDay, utc, timezone);\n\t\t\tif (timezone) {\n\t\t\t\tvalue = $time.round(new Date(value + this.baseDuration() * 0.05), timeUnit, count, firstDay, utc, new Date(this.getPrivate(\"min\", 0)), timezone).getTime();\n\t\t\t\tduration = $time.getDateIntervalDuration(baseInterval, new Date(value + duration * location), firstDay, utc, timezone);\n\t\t\t}\n\n\t\t\treturn this.valueToPosition(value + duration * location);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tif (this.getPrivate(\"min\") != null) {\n\t\t\tlet format = this.get(\"tooltipDateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\t\tlet value = this.positionToValue(position);\n\t\t\tlet date = new Date(value);\n\n\t\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\t\tlet duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n\t\t\treturn this._root.dateFormatter.format(new Date(value + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration), this.get(\"tooltipDateFormat\", format));\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number, location?: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\n\t\tif (location == null) {\n\t\t\tlocation = 0.5;\n\t\t}\n\n\t\tvalue = value - (location - 0.5) * this.baseDuration();\n\n\t\tconst result = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\tlet diValue = 0;\n\t\t\tif (dataItem.open) {\n\t\t\t\tdiValue = dataItem.open[fieldName];\n\t\t\t}\n\n\t\t\treturn $order.compare(diValue, value);\n\t\t});\n\n\t\tif (series.get(\"snapTooltip\")) {\n\t\t\tlet first = series.dataItems[result.index - 1];\n\t\t\tlet second = series.dataItems[result.index];\n\n\t\t\tif (first && second) {\n\t\t\t\tif (first.open && second.close) {\n\t\t\t\t\tlet open = first.open[fieldName];\n\t\t\t\t\tlet close = second.close[fieldName];\n\n\t\t\t\t\tif (Math.abs(value - open) > Math.abs(value - close)) {\n\t\t\t\t\t\treturn second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (first) {\n\t\t\t\treturn first;\n\t\t\t}\n\n\t\t\tif (second) {\n\t\t\t\treturn second;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// @todo check if is in range\n\t\t\tconst dataItem = series.dataItems[result.index - 1];\n\n\t\t\tif (dataItem) {\n\t\t\t\tif (dataItem.open && dataItem.close) {\n\t\t\t\t\tlet open = dataItem.open[fieldName];\n\t\t\t\t\tlet close = dataItem.close[fieldName];\n\n\t\t\t\t\tif (value >= open && value <= close) {\n\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic shouldGap(dataItem: DataItem<IXYSeriesDataItem>, nextItem: DataItem<IXYSeriesDataItem>, autoGapCount: number, fieldName: string): boolean {\n\t\tconst value1 = dataItem.get(fieldName as any);\n\t\tconst value2 = nextItem.get(fieldName as any);\n\n\t\tif (value2 - value1 > this.baseDuration() * autoGapCount) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` dates.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start Date\n\t * @param  end       End Date\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToDates(start: Date, end: Date, duration?: number) {\n\t\tthis.zoomToValues(start.getTime(), end.getTime(), duration);\n\t}\n\n\t/**\n\t * Returns a `Date` object corresponding to specific position within plot\n\t * area.\n\t *\n\t * @param   position  Pposition\n\t * @return            Date\n\t */\n\tpublic positionToDate(position: number): Date {\n\t\treturn new Date(this.positionToValue(position));\n\t}\n\n\t/**\n\t * Returns a relative position within plot area that corresponds to specific\n\t * date.\n\t *\n\t * @param   date  Date\n\t * @return        Position\n\t */\n\tpublic dateToPosition(date: Date): number {\n\t\treturn this.valueToPosition(date.getTime());\n\t}\n\n\t/**\n\t * Returns relative position between two grid lines of the axis.\n\t *\n\t * @since 5.2.30\n\t * @return Position\n\t */\n\tpublic getCellWidthPosition(): number {\n\t\tlet max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n\t\tlet min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n\n\t\tif ($type.isNumber(max) && $type.isNumber(min)) {\n\t\t\treturn this._intervalDuration / (max - min);\n\t\t}\n\t\treturn 0.05;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}