{"ast":null,"code":"import { XYSeries } from \"./XYSeries\";\nimport { Graphics } from \"../../../core/render/Graphics\";\nimport { line, area } from \"d3-shape\";\nimport { Template } from \"../../../core/util/Template\";\nimport { ListTemplate } from \"../../../core/util/List\";\nimport { color } from \"../../../core/util/Color\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Rectangle } from \"../../../core/render/Rectangle\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Used to plot line and/or area series.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info\r\n * @important\r\n */\nexport class LineSeries extends XYSeries {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_endIndex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_strokeGenerator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: line()\n    });\n    Object.defineProperty(this, \"_fillGenerator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: area()\n    });\n    Object.defineProperty(this, \"_legendStroke\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_legendFill\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A [[TemplateList]] of all line segments in series.\r\n     *\r\n     * `strokes.template` can be used to set default settings for all line\r\n     * segments, or to change on existing ones.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n    Object.defineProperty(this, \"strokes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n        themeTags: $utils.mergeTags(this.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"stroke\"])\n      }, [this.strokes.template]))\n    });\n    /**\r\n     * A [[TemplateList]] of all segment fills in series.\r\n     *\r\n     * `fills.template` can be used to set default settings for all segment\r\n     * fills, or to change on existing ones.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n    Object.defineProperty(this, \"fills\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n        themeTags: $utils.mergeTags(this.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"fill\"])\n      }, [this.fills.template]))\n    });\n    // custom set from data\n    Object.defineProperty(this, \"_fillTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_strokeTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_previousPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [0, 0, 0, 0]\n    });\n    Object.defineProperty(this, \"_dindex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_sindex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  _afterNew() {\n    this._fillGenerator.y0(function (p) {\n      return p[3];\n    });\n    this._fillGenerator.x0(function (p) {\n      return p[2];\n    });\n    this._fillGenerator.y1(function (p) {\n      return p[1];\n    });\n    this._fillGenerator.x1(function (p) {\n      return p[0];\n    });\n    super._afterNew();\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeStroke(strokes) {\n    const stroke = this.mainContainer.children.push(strokes.make());\n    strokes.push(stroke);\n    return stroke;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeFill(fills) {\n    const fill = this.mainContainer.children.push(fills.make());\n    fills.push(fill);\n    return fill;\n  }\n  _updateChildren() {\n    this._strokeTemplate = undefined;\n    this._fillTemplate = undefined;\n    let xAxis = this.get(\"xAxis\");\n    let yAxis = this.get(\"yAxis\");\n    if (this.isDirty(\"stroke\")) {\n      const stroke = this.get(\"stroke\");\n      this.strokes.template.set(\"stroke\", stroke);\n      const legendStroke = this._legendStroke;\n      if (legendStroke) {\n        legendStroke.states.lookup(\"default\").set(\"stroke\", stroke);\n      }\n    }\n    if (this.isDirty(\"fill\")) {\n      const fill = this.get(\"fill\");\n      this.fills.template.set(\"fill\", fill);\n      const legendFill = this._legendFill;\n      if (legendFill) {\n        legendFill.states.lookup(\"default\").set(\"fill\", fill);\n      }\n    }\n    if (this.isDirty(\"curveFactory\")) {\n      const curveFactory = this.get(\"curveFactory\");\n      if (curveFactory) {\n        this._strokeGenerator.curve(curveFactory);\n        this._fillGenerator.curve(curveFactory);\n      }\n    }\n    if (xAxis.inited && yAxis.inited) {\n      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty(\"vcx\") || this.isDirty(\"vcy\") || this._sizeDirty || this.isDirty(\"connect\") || this.isDirty(\"curveFactory\")) {\n        this.fills.each(fill => {\n          fill.setPrivate(\"visible\", false);\n        });\n        this.strokes.each(fill => {\n          fill.setPrivate(\"visible\", false);\n        });\n        this.axisRanges.each(axisRange => {\n          let fills = axisRange.fills;\n          if (fills) {\n            fills.each(fill => {\n              fill.setPrivate(\"visible\", false);\n            });\n          }\n          let strokes = axisRange.strokes;\n          if (strokes) {\n            strokes.each(stroke => {\n              stroke.setPrivate(\"visible\", false);\n            });\n          }\n        });\n        let startIndex = this.startIndex();\n        let strokeTemplateField = this.strokes.template.get(\"templateField\");\n        let fillTemplateField = this.fills.template.get(\"templateField\");\n        let strokeTemplateFound = true;\n        let fillTemplateFound = true;\n        if (strokeTemplateField) {\n          strokeTemplateFound = false;\n        }\n        if (fillTemplateField) {\n          fillTemplateFound = false;\n        }\n        for (let i = startIndex - 1; i >= 0; i--) {\n          let dataItem = this.dataItems[i];\n          let hasValues = true;\n          let dataContext = dataItem.dataContext;\n          if (strokeTemplateField) {\n            if (dataContext[strokeTemplateField]) {\n              strokeTemplateFound = true;\n            }\n          }\n          if (fillTemplateField) {\n            if (dataContext[fillTemplateField]) {\n              fillTemplateFound = true;\n            }\n          }\n          $array.each(this._valueFields, field => {\n            if (!$type.isNumber(dataItem.get(field))) {\n              hasValues = false;\n            }\n          });\n          if (hasValues && strokeTemplateFound && fillTemplateFound) {\n            startIndex = i;\n            break;\n          }\n        }\n        let len = this.dataItems.length;\n        let endIndex = this.endIndex();\n        if (endIndex < len) {\n          endIndex++;\n          for (let i = endIndex; i < len; i++) {\n            let dataItem = this.dataItems[i];\n            let hasValues = true;\n            $array.each(this._valueFields, field => {\n              if (!$type.isNumber(dataItem.get(field))) {\n                hasValues = false;\n              }\n            });\n            if (hasValues) {\n              endIndex = i + 1;\n              break;\n            }\n          }\n        }\n        if (startIndex > 0) {\n          startIndex--;\n        }\n        this._endIndex = endIndex;\n        this._clearGraphics();\n        this._sindex = 0;\n        this._dindex = startIndex;\n        if (this.dataItems.length == 1) {\n          this._startSegment(0);\n        } else {\n          // this is done to avoid recursion with a lot of segments \n          while (this._dindex < endIndex - 1) {\n            this._startSegment(this._dindex);\n            this._sindex++;\n          }\n        }\n      }\n    } else {\n      this._skipped = true;\n    }\n    super._updateChildren();\n  }\n  _clearGraphics() {\n    this.strokes.clear();\n    this.fills.clear();\n  }\n  _startSegment(dataItemIndex) {\n    let endIndex = this._endIndex;\n    let currentEndIndex = endIndex;\n    const autoGapCount = this.get(\"autoGapCount\");\n    const connect = this.get(\"connect\");\n    const fill = this.makeFill(this.fills);\n    const fillTemplate = this._fillTemplate;\n    const originalTemplate = this.fills.template;\n    if (fillTemplate && fillTemplate != originalTemplate) {\n      fill.template = fillTemplate;\n    }\n    fill.setPrivate(\"visible\", true);\n    const stroke = this.makeStroke(this.strokes);\n    const strokeTemplate = this._strokeTemplate;\n    if (strokeTemplate && strokeTemplate != this.strokes.template) {\n      stroke.template = strokeTemplate;\n    }\n    stroke.setPrivate(\"visible\", true);\n    let xAxis = this.get(\"xAxis\");\n    let yAxis = this.get(\"yAxis\");\n    let baseAxis = this.get(\"baseAxis\");\n    let vcx = this.get(\"vcx\", 1);\n    let vcy = this.get(\"vcy\", 1);\n    let xField = this._xField;\n    let yField = this._yField;\n    let xOpenField = this._xOpenField;\n    let yOpenField = this._yOpenField;\n    const xOpenFieldValue = this.get(\"openValueXField\");\n    const yOpenFieldValue = this.get(\"openValueYField\");\n    if (!xOpenFieldValue) {\n      xOpenField = this._xField;\n    }\n    if (!yOpenFieldValue) {\n      yOpenField = this._yField;\n    }\n    const stacked = this.get(\"stacked\");\n    const basePosX = xAxis.basePosition();\n    const basePosY = yAxis.basePosition();\n    let baseField;\n    if (baseAxis === yAxis) {\n      baseField = this._yField;\n    } else {\n      baseField = this._xField;\n    }\n    const segments = [];\n    let points = [];\n    segments.push(points);\n    const strokeTemplateField = this.strokes.template.get(\"templateField\");\n    const fillTemplateField = this.fills.template.get(\"templateField\");\n    let locationX = this.get(\"locationX\", 0.5);\n    let locationY = this.get(\"locationY\", 0.5);\n    let openLocationX = this.get(\"openLocationX\", locationX);\n    let openLocationY = this.get(\"openLocationY\", locationY);\n    const minDistance = this.get(\"minDistance\", 0);\n    let i;\n    let fillVisible = this.fills.template.get(\"visible\");\n    if (this.axisRanges.length > 0) {\n      fillVisible = true;\n    }\n    let getOpen = false;\n    if (stacked || xOpenFieldValue || yOpenFieldValue) {\n      getOpen = true;\n    }\n    const o = {\n      points,\n      segments,\n      stacked,\n      getOpen,\n      basePosX,\n      basePosY,\n      fillVisible,\n      xField,\n      yField,\n      xOpenField,\n      yOpenField,\n      vcx,\n      vcy,\n      baseAxis,\n      xAxis,\n      yAxis,\n      locationX,\n      locationY,\n      openLocationX,\n      openLocationY,\n      minDistance\n    };\n    for (i = dataItemIndex; i < currentEndIndex; i++) {\n      this._dindex = i;\n      const dataItem = this._dataItems[i];\n      let valueX = dataItem.get(xField);\n      let valueY = dataItem.get(yField);\n      if (valueX == null || valueY == null) {\n        if (!connect) {\n          points = [];\n          segments.push(points);\n          o.points = points;\n        }\n      } else {\n        this._getPoints(dataItem, o);\n      }\n      if (strokeTemplateField) {\n        let strokeTemplate = dataItem.dataContext[strokeTemplateField];\n        if (strokeTemplate) {\n          if (!(strokeTemplate instanceof Template)) {\n            strokeTemplate = Template.new(strokeTemplate);\n          }\n          this._strokeTemplate = strokeTemplate;\n          if (i > dataItemIndex) {\n            currentEndIndex = i;\n            break;\n          } else {\n            stroke.template = strokeTemplate;\n          }\n        }\n      }\n      if (fillTemplateField) {\n        let fillTemplate = dataItem.dataContext[fillTemplateField];\n        if (fillTemplate) {\n          if (!(fillTemplate instanceof Template)) {\n            fillTemplate = Template.new(fillTemplate);\n          }\n          this._fillTemplate = fillTemplate;\n          if (i > dataItemIndex) {\n            currentEndIndex = i;\n            break;\n          } else {\n            fill.template = fillTemplate;\n          }\n        }\n      }\n      if (!connect) {\n        let nextItem = this.dataItems[i + 1];\n        if (nextItem) {\n          if (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {\n            points = [];\n            segments.push(points);\n            o.points = points;\n          }\n        }\n      }\n    }\n    fill.setRaw(\"userData\", [dataItemIndex, i]);\n    stroke.setRaw(\"userData\", [dataItemIndex, i]);\n    if (i === endIndex) {\n      this._endLine(points, segments[0][0]);\n    }\n    if (stroke) {\n      this._drawStroke(stroke, segments);\n    }\n    if (fill) {\n      this._drawFill(fill, segments);\n    }\n    this.axisRanges.each(axisRange => {\n      const container = axisRange.container;\n      const fills = axisRange.fills;\n      const fill = this.makeFill(fills);\n      if (container) {\n        container.children.push(fill);\n      }\n      fill.setPrivate(\"visible\", true);\n      this._drawFill(fill, segments);\n      const strokes = axisRange.strokes;\n      const stroke = this.makeStroke(strokes);\n      if (container) {\n        container.children.push(stroke);\n      }\n      stroke.setPrivate(\"visible\", true);\n      this._drawStroke(stroke, segments);\n      fill.setRaw(\"userData\", [dataItemIndex, i]);\n      stroke.setRaw(\"userData\", [dataItemIndex, i]);\n    });\n  }\n  _getPoints(dataItem, o) {\n    let points = o.points;\n    let itemLocationX = dataItem.get(\"locationX\", o.locationX);\n    let itemLocationY = dataItem.get(\"locationY\", o.locationY);\n    let xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);\n    let yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);\n    if (this._shouldInclude(xPos)) {\n      const iPoint = this.getPoint(xPos, yPos);\n      const point = [iPoint.x, iPoint.y];\n      iPoint.x += this._x;\n      iPoint.y += this._y;\n      dataItem.set(\"point\", iPoint);\n      if (o.fillVisible) {\n        let xPos0 = xPos;\n        let yPos0 = yPos;\n        if (o.baseAxis === o.xAxis) {\n          yPos0 = o.basePosY;\n        } else if (o.baseAxis === o.yAxis) {\n          xPos0 = o.basePosX;\n        }\n        if (o.getOpen) {\n          let valueX = dataItem.get(o.xOpenField);\n          let valueY = dataItem.get(o.yOpenField);\n          if (valueX != null && valueY != null) {\n            let itemLocationX = dataItem.get(\"openLocationX\", o.openLocationX);\n            let itemLocationY = dataItem.get(\"openLocationY\", o.openLocationY);\n            if (o.stacked) {\n              let stackToItemX = dataItem.get(\"stackToItemX\");\n              let stackToItemY = dataItem.get(\"stackToItemY\");\n              if (stackToItemX) {\n                xPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX, stackToItemX.component.get(\"vcx\"));\n                if ($type.isNaN(xPos0)) {\n                  xPos0 = o.basePosX;\n                }\n              } else {\n                if (o.yAxis === o.baseAxis) {\n                  xPos0 = o.basePosX;\n                } else {\n                  xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);\n                }\n              }\n              if (stackToItemY) {\n                yPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY, stackToItemY.component.get(\"vcy\"));\n                if ($type.isNaN(yPos0)) {\n                  yPos0 = o.basePosY;\n                }\n              } else {\n                if (o.xAxis === o.baseAxis) {\n                  yPos0 = o.basePosY;\n                } else {\n                  yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);\n                }\n              }\n            } else {\n              xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);\n              yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);\n            }\n          }\n        }\n        let closeIPoint = this.getPoint(xPos0, yPos0);\n        point[2] = closeIPoint.x;\n        point[3] = closeIPoint.y;\n      }\n      if (o.minDistance > 0) {\n        const p0 = point[0];\n        const p1 = point[1];\n        const p2 = point[2];\n        const p3 = point[3];\n        const prev = this._previousPoint;\n        const pp0 = prev[0];\n        const pp1 = prev[1];\n        const pp2 = prev[2];\n        const pp3 = prev[3];\n        if (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance) {\n          points.push(point);\n          this._previousPoint = point;\n        }\n      } else {\n        points.push(point);\n      }\n    }\n  }\n  _endLine(_points, _firstPoint) {}\n  _drawStroke(graphics, segments) {\n    if (graphics.get(\"visible\") && !graphics.get(\"forceHidden\")) {\n      graphics.set(\"draw\", display => {\n        $array.each(segments, segment => {\n          this._strokeGenerator.context(display);\n          this._strokeGenerator(segment);\n        });\n      });\n    }\n  }\n  _drawFill(graphics, segments) {\n    if (graphics.get(\"visible\") && !graphics.get(\"forceHidden\")) {\n      graphics.set(\"draw\", display => {\n        $array.each(segments, segment => {\n          this._fillGenerator.context(display);\n          this._fillGenerator(segment);\n        });\n      });\n    }\n  }\n  _processAxisRange(axisRange) {\n    super._processAxisRange(axisRange);\n    axisRange.fills = new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n      themeTags: $utils.mergeTags(axisRange.fills.template.get(\"themeTags\", []), [\"line\", \"series\", \"fill\"])\n    }, [this.fills.template, axisRange.fills.template]));\n    axisRange.strokes = new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n      themeTags: $utils.mergeTags(axisRange.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"stroke\"])\n    }, [this.strokes.template, axisRange.strokes.template]));\n  }\n  /**\r\n   * @ignore\r\n   */\n  createLegendMarker(_dataItem) {\n    const legendDataItem = this.get(\"legendDataItem\");\n    if (legendDataItem) {\n      const marker = legendDataItem.get(\"marker\");\n      const markerRectangle = legendDataItem.get(\"markerRectangle\");\n      if (markerRectangle) {\n        markerRectangle.setPrivate(\"visible\", false);\n      }\n      marker.set(\"background\", Rectangle.new(marker._root, {\n        fillOpacity: 0,\n        fill: color(0x000000)\n      }));\n      const legendStroke = marker.children.push(Graphics._new(marker._root, {\n        themeTags: [\"line\", \"series\", \"legend\", \"marker\", \"stroke\"],\n        interactive: false\n      }, [this.strokes.template]));\n      this._legendStroke = legendStroke;\n      const legendFill = marker.children.push(Graphics._new(marker._root, {\n        themeTags: [\"line\", \"series\", \"legend\", \"marker\", \"fill\"]\n      }, [this.fills.template]));\n      this._legendFill = legendFill;\n      const disabledColor = this._root.interfaceColors.get(\"disabled\");\n      legendStroke.states.create(\"disabled\", {\n        fill: disabledColor,\n        stroke: disabledColor\n      });\n      legendFill.states.create(\"disabled\", {\n        fill: disabledColor,\n        stroke: disabledColor\n      });\n      if (this.bullets.length > 0) {\n        const bulletFunction = this.bullets.getIndex(0);\n        if (bulletFunction) {\n          const bullet = bulletFunction(marker._root, this, new DataItem(this, {}, {}));\n          if (bullet) {\n            const sprite = bullet.get(\"sprite\");\n            if (sprite instanceof Graphics) {\n              sprite.states.create(\"disabled\", {\n                fill: disabledColor,\n                stroke: disabledColor\n              });\n            }\n            if (sprite) {\n              sprite.set(\"tooltipText\", undefined);\n              sprite.set(\"tooltipHTML\", undefined);\n              marker.children.push(sprite);\n              sprite.setAll({\n                x: marker.width() / 2,\n                y: marker.height() / 2\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n}\nObject.defineProperty(LineSeries, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"LineSeries\"\n});\nObject.defineProperty(LineSeries, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: XYSeries.classNames.concat([LineSeries.className])\n});","map":{"version":3,"names":["XYSeries","Graphics","line","area","Template","ListTemplate","color","DataItem","Rectangle","$type","$array","$utils","LineSeries","constructor","Object","defineProperty","new","_new","_root","themeTags","mergeTags","strokes","template","get","fills","_afterNew","_fillGenerator","y0","p","x0","y1","x1","makeStroke","stroke","mainContainer","children","push","make","makeFill","fill","_updateChildren","_strokeTemplate","undefined","_fillTemplate","xAxis","yAxis","isDirty","set","legendStroke","_legendStroke","states","lookup","legendFill","_legendFill","curveFactory","_strokeGenerator","curve","inited","_axesDirty","_valuesDirty","_stackDirty","_sizeDirty","each","setPrivate","axisRanges","axisRange","startIndex","strokeTemplateField","fillTemplateField","strokeTemplateFound","fillTemplateFound","i","dataItem","dataItems","hasValues","dataContext","_valueFields","field","isNumber","len","length","endIndex","_endIndex","_clearGraphics","_sindex","_dindex","_startSegment","_skipped","clear","dataItemIndex","currentEndIndex","autoGapCount","connect","fillTemplate","originalTemplate","strokeTemplate","baseAxis","vcx","vcy","xField","_xField","yField","_yField","xOpenField","_xOpenField","yOpenField","_yOpenField","xOpenFieldValue","yOpenFieldValue","stacked","basePosX","basePosition","basePosY","baseField","segments","points","locationX","locationY","openLocationX","openLocationY","minDistance","fillVisible","getOpen","o","_dataItems","valueX","valueY","_getPoints","nextItem","shouldGap","setRaw","_endLine","_drawStroke","_drawFill","container","itemLocationX","itemLocationY","xPos","getDataItemPositionX","yPos","getDataItemPositionY","_shouldInclude","iPoint","getPoint","point","x","y","_x","_y","xPos0","yPos0","stackToItemX","stackToItemY","component","isNaN","closeIPoint","p0","p1","p2","p3","prev","_previousPoint","pp0","pp1","pp2","pp3","Math","hypot","_points","_firstPoint","graphics","display","segment","context","_processAxisRange","createLegendMarker","_dataItem","legendDataItem","marker","markerRectangle","fillOpacity","interactive","disabledColor","interfaceColors","create","bullets","bulletFunction","getIndex","bullet","sprite","setAll","width","height","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\charts\\xy\\series\\LineSeries.ts"],"sourcesContent":["import type { Axis } from \"../axes/Axis\";\nimport type { AxisRenderer } from \"../axes/AxisRenderer\";\n\nimport { XYSeries, IXYSeriesPrivate, IXYSeriesSettings, IXYSeriesDataItem, IXYSeriesAxisRange } from \"./XYSeries\";\nimport { Graphics } from \"../../../core/render/Graphics\";\nimport { CurveFactory, line, area } from \"d3-shape\";\nimport { Template } from \"../../../core/util/Template\";\nimport { ListTemplate } from \"../../../core/util/List\";\nimport { color } from \"../../../core/util/Color\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Rectangle } from \"../../../core/render/Rectangle\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n\nexport interface IPointOptions {\n}\n\nexport interface ILineSeriesDataItem extends IXYSeriesDataItem {\n}\n\nexport interface ILineSeriesSettings extends IXYSeriesSettings {\n\n\t/**\n\t * If set to `true` the line will connect over \"gaps\" - categories or time\n\t * intervals with no data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/#Gaps} for more info\n\t * @default true\n\t */\n\tconnect?: boolean;\n\n\t/**\n\t * If there are more than `autoGapCount` base time intervals (e.g. days) with\n\t * no data, the line will break and will display gap.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/#Auto_gaps_with_dates} for more info\n\t * @default 1.1\n\t */\n\tautoGapCount?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tcurveFactory?: CurveFactory;\n\n\t/**\n\t * Allows simplifying the line with many points.\n\t *\n\t * If set, the series will skip points that are closer than X pixels to each\n\t * other.\n\t *\n\t * With many data points, this allows having smoother, less cluttered lines.\n\t *\n\t * @default 0\n\t * @since 5.2.7\n\t */\n\tminDistance?: number;\n\n\n}\n\nexport interface ILineSeriesPrivate extends IXYSeriesPrivate {\n}\n\n/**\n * Interface representing a [[LineSeries]] axis range.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/#Series_axis_ranges} for more info\n */\nexport interface ILineSeriesAxisRange extends IXYSeriesAxisRange {\n\n\t/**\n\t * A list template to use when applying line settings to the line segments covered\n\t * by an axis range.\n\t */\n\tstrokes?: ListTemplate<Graphics>;\n\n\t/**\n\t * A list template to use when applying fill settings to the fill segments covered\n\t * by an axis range.\n\t */\n\tfills?: ListTemplate<Graphics>;\n}\n\n/**\n * Used to plot line and/or area series.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info\n * @important\n */\nexport class LineSeries extends XYSeries {\n\n\tdeclare public _settings: ILineSeriesSettings;\n\tdeclare public _privateSettings: ILineSeriesPrivate;\n\tdeclare public _dataItemSettings: ILineSeriesDataItem;\n\tdeclare public _axisRangeType: ILineSeriesAxisRange;\n\n\tpublic static className: string = \"LineSeries\";\n\tpublic static classNames: Array<string> = XYSeries.classNames.concat([LineSeries.className]);\n\n\tprotected _endIndex!: number;\n\n\tprotected _strokeGenerator = line();\n\tprotected _fillGenerator = area();\n\n\tprotected _legendStroke?: Graphics;\n\tprotected _legendFill?: Graphics;\n\n\tprotected _afterNew() {\n\t\tthis._fillGenerator.y0(function(p: number[]) {\n\t\t\treturn p[3];\n\t\t});\n\n\t\tthis._fillGenerator.x0(function(p: number[]) {\n\t\t\treturn p[2];\n\t\t});\n\n\t\tthis._fillGenerator.y1(function(p: number[]) {\n\t\t\treturn p[1];\n\t\t});\n\n\t\tthis._fillGenerator.x1(function(p: number[]) {\n\t\t\treturn p[0];\n\t\t});\n\n\t\tsuper._afterNew();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeStroke(strokes: ListTemplate<Graphics>): Graphics {\n\t\tconst stroke = this.mainContainer.children.push(strokes.make());\n\t\tstrokes.push(stroke);\n\t\treturn stroke;\n\t}\n\n\t/**\n\t * A [[TemplateList]] of all line segments in series.\n\t *\n\t * `strokes.template` can be used to set default settings for all line\n\t * segments, or to change on existing ones.\n\t *\n\t * @default new ListTemplate<Graphics>\n\t */\n\tpublic readonly strokes: ListTemplate<Graphics> = new ListTemplate(\n\t\tTemplate.new({}),\n\t\t() => Graphics._new(this._root, {\n\t\t\tthemeTags: $utils.mergeTags(this.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"stroke\"])\n\t\t}, [this.strokes.template]),\n\t);\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeFill(fills: ListTemplate<Graphics>): Graphics {\n\t\tconst fill = this.mainContainer.children.push(fills.make());\n\t\tfills.push(fill);\n\t\treturn fill;\n\t}\n\n\t/**\n\t * A [[TemplateList]] of all segment fills in series.\n\t *\n\t * `fills.template` can be used to set default settings for all segment\n\t * fills, or to change on existing ones.\n\t *\n\t * @default new ListTemplate<Graphics>\n\t */\n\tpublic readonly fills: ListTemplate<Graphics> = new ListTemplate(\n\t\tTemplate.new({}),\n\t\t() => Graphics._new(this._root, {\n\t\t\tthemeTags: $utils.mergeTags(this.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"fill\"])\n\t\t}, [this.fills.template]),\n\t);\n\n\t// custom set from data\n\tprotected _fillTemplate: Template<Graphics> | undefined;\n\tprotected _strokeTemplate: Template<Graphics> | undefined;\n\n\tprotected _previousPoint: Array<number> = [0, 0, 0, 0];\n\n\tprotected _dindex = 0;\n\tprotected _sindex = 0;\n\n\tpublic _updateChildren() {\n\n\t\tthis._strokeTemplate = undefined;\n\t\tthis._fillTemplate = undefined;\t\t\n\n\t\tlet xAxis = this.get(\"xAxis\");\n\t\tlet yAxis = this.get(\"yAxis\");\n\n\t\tif (this.isDirty(\"stroke\")) {\n\t\t\tconst stroke = this.get(\"stroke\");\n\t\t\tthis.strokes.template.set(\"stroke\", stroke);\n\t\t\tconst legendStroke = this._legendStroke;\n\t\t\tif (legendStroke) {\n\t\t\t\tlegendStroke.states.lookup(\"default\")!.set(\"stroke\", stroke);\n\t\t\t}\n\t\t}\n\t\tif (this.isDirty(\"fill\")) {\n\t\t\tconst fill = this.get(\"fill\");\n\t\t\tthis.fills.template.set(\"fill\", fill);\n\t\t\tconst legendFill = this._legendFill;\n\t\t\tif (legendFill) {\n\t\t\t\tlegendFill.states.lookup(\"default\")!.set(\"fill\", fill);\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"curveFactory\")) {\n\t\t\tconst curveFactory = this.get(\"curveFactory\")!;\n\t\t\tif (curveFactory) {\n\t\t\t\tthis._strokeGenerator.curve(curveFactory);\n\t\t\t\tthis._fillGenerator.curve(curveFactory);\n\t\t\t}\n\t\t}\n\n\t\tif (xAxis.inited && yAxis.inited) {\n\t\t\tif (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty(\"vcx\") || this.isDirty(\"vcy\") || this._sizeDirty || this.isDirty(\"connect\") || this.isDirty(\"curveFactory\")) {\n\n\t\t\t\tthis.fills.each((fill) => {\n\t\t\t\t\tfill.setPrivate(\"visible\", false);\n\t\t\t\t})\n\n\t\t\t\tthis.strokes.each((fill) => {\n\t\t\t\t\tfill.setPrivate(\"visible\", false);\n\t\t\t\t})\n\n\t\t\t\tthis.axisRanges.each((axisRange) => {\n\t\t\t\t\tlet fills = axisRange.fills;\n\t\t\t\t\tif (fills) {\n\t\t\t\t\t\tfills.each((fill) => {\n\t\t\t\t\t\t\tfill.setPrivate(\"visible\", false);\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tlet strokes = axisRange.strokes;\n\t\t\t\t\tif (strokes) {\n\t\t\t\t\t\tstrokes.each((stroke) => {\n\t\t\t\t\t\t\tstroke.setPrivate(\"visible\", false);\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tlet startIndex = this.startIndex();\n\n\t\t\t\tlet strokeTemplateField = this.strokes.template.get(\"templateField\");\n\t\t\t\tlet fillTemplateField = this.fills.template.get(\"templateField\");\n\n\t\t\t\tlet strokeTemplateFound = true;\n\t\t\t\tlet fillTemplateFound = true;\n\n\t\t\t\tif (strokeTemplateField) {\n\t\t\t\t\tstrokeTemplateFound = false;\n\t\t\t\t}\n\t\t\t\tif (fillTemplateField) {\n\t\t\t\t\tfillTemplateFound = false;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = startIndex - 1; i >= 0; i--) {\n\t\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\t\tlet hasValues = true;\n\t\t\t\t\tlet dataContext = dataItem.dataContext as any;\n\t\t\t\t\tif (strokeTemplateField) {\n\t\t\t\t\t\tif (dataContext[strokeTemplateField]) {\n\t\t\t\t\t\t\tstrokeTemplateFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fillTemplateField) {\n\t\t\t\t\t\tif (dataContext[fillTemplateField]) {\n\t\t\t\t\t\t\tfillTemplateFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$array.each(this._valueFields, (field) => {\n\t\t\t\t\t\tif (!$type.isNumber(dataItem.get(field as any))) {\n\t\t\t\t\t\t\thasValues = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (hasValues && strokeTemplateFound && fillTemplateFound) {\n\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet len = this.dataItems.length;\n\t\t\t\tlet endIndex = this.endIndex();\n\n\t\t\t\tif (endIndex < len) {\n\t\t\t\t\tendIndex++;\n\t\t\t\t\tfor (let i = endIndex; i < len; i++) {\n\t\t\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\t\t\tlet hasValues = true;\n\t\t\t\t\t\t$array.each(this._valueFields, (field) => {\n\t\t\t\t\t\t\tif (!$type.isNumber(dataItem.get(field as any))) {\n\t\t\t\t\t\t\t\thasValues = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif (hasValues) {\n\t\t\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\tstartIndex--\n\t\t\t\t}\n\n\t\t\t\tthis._endIndex = endIndex;\n\n\t\t\t\tthis._clearGraphics();\n\t\t\t\tthis._sindex = 0;\n\t\t\t\tthis._dindex = startIndex;\n\t\t\t\tif (this.dataItems.length == 1) {\n\t\t\t\t\tthis._startSegment(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// this is done to avoid recursion with a lot of segments \n\t\t\t\t\twhile (this._dindex < endIndex - 1) {\n\t\t\t\t\t\tthis._startSegment(this._dindex);\n\t\t\t\t\t\tthis._sindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._skipped = true;\n\t\t}\n\n\t\tsuper._updateChildren();\n\t}\n\n\tprotected _clearGraphics() {\n\t\tthis.strokes.clear();\n\t\tthis.fills.clear();\n\t}\n\n\tprotected _startSegment(dataItemIndex: number) {\n\t\tlet endIndex = this._endIndex;\n\t\tlet currentEndIndex = endIndex;\n\n\t\tconst autoGapCount = this.get(\"autoGapCount\")!;\n\t\tconst connect = this.get(\"connect\");\n\n\t\tconst fill = this.makeFill(this.fills);\n\n\t\tconst fillTemplate = this._fillTemplate;\n\t\tconst originalTemplate = this.fills.template;\n\t\tif (fillTemplate && fillTemplate != originalTemplate) {\n\t\t\tfill.template = fillTemplate;\n\t\t}\n\n\t\tfill.setPrivate(\"visible\", true);\n\n\t\tconst stroke = this.makeStroke(this.strokes);\n\n\t\tconst strokeTemplate = this._strokeTemplate;\n\t\tif (strokeTemplate && strokeTemplate != this.strokes.template) {\n\t\t\tstroke.template = strokeTemplate;\n\t\t}\n\n\t\tstroke.setPrivate(\"visible\", true);\n\n\t\tlet xAxis = this.get(\"xAxis\");\n\t\tlet yAxis = this.get(\"yAxis\");\n\t\tlet baseAxis = this.get(\"baseAxis\")!;\n\n\t\tlet vcx = this.get(\"vcx\", 1);\n\t\tlet vcy = this.get(\"vcy\", 1);\n\n\t\tlet xField = this._xField;\n\t\tlet yField = this._yField;\n\n\t\tlet xOpenField = this._xOpenField;\n\t\tlet yOpenField = this._yOpenField;\n\n\t\tconst xOpenFieldValue = this.get(\"openValueXField\");\n\t\tconst yOpenFieldValue = this.get(\"openValueYField\");\n\n\t\tif (!xOpenFieldValue) {\n\t\t\txOpenField = this._xField;\n\t\t}\n\n\t\tif (!yOpenFieldValue) {\n\t\t\tyOpenField = this._yField;\n\t\t}\n\n\t\tconst stacked = this.get(\"stacked\");\n\n\t\tconst basePosX = xAxis.basePosition();\n\t\tconst basePosY = yAxis.basePosition();\n\n\t\tlet baseField: string;\n\t\tif (baseAxis === yAxis) {\n\t\t\tbaseField = this._yField;\n\t\t}\n\t\telse {\n\t\t\tbaseField = this._xField;\n\t\t}\n\n\t\tconst segments: Array<Array<Array<number>>> = [];\n\t\tlet points: Array<Array<number>> = [];\n\t\tsegments.push(points);\n\n\t\tconst strokeTemplateField = this.strokes.template.get(\"templateField\");\n\t\tconst fillTemplateField = this.fills.template.get(\"templateField\");\n\n\t\tlet locationX = this.get(\"locationX\", 0.5);\n\t\tlet locationY = this.get(\"locationY\", 0.5);\n\n\t\tlet openLocationX = this.get(\"openLocationX\", locationX);\n\t\tlet openLocationY = this.get(\"openLocationY\", locationY);\n\n\t\tconst minDistance = this.get(\"minDistance\", 0);\n\n\t\tlet i: number;\n\n\t\tlet fillVisible = this.fills.template.get(\"visible\");\n\t\tif (this.axisRanges.length > 0) {\n\t\t\tfillVisible = true;\n\t\t}\n\n\t\tlet getOpen = false;\n\t\tif (stacked || xOpenFieldValue || yOpenFieldValue) {\n\t\t\tgetOpen = true;\n\t\t}\n\n\t\tconst o = {\n\t\t\tpoints, segments, stacked, getOpen, basePosX, basePosY, fillVisible, xField, yField, xOpenField, yOpenField, vcx, vcy, baseAxis, xAxis, yAxis, locationX, locationY, openLocationX, openLocationY, minDistance\n\t\t}\n\n\n\t\tfor (i = dataItemIndex; i < currentEndIndex; i++) {\n\t\t\tthis._dindex = i;\n\t\t\tconst dataItem = this._dataItems[i];\n\n\t\t\tlet valueX = dataItem.get(xField as any);\n\t\t\tlet valueY = dataItem.get(yField as any);\n\n\t\t\tif (valueX == null || valueY == null) {\n\t\t\t\tif (!connect) {\n\t\t\t\t\tpoints = [];\n\t\t\t\t\tsegments.push(points);\n\t\t\t\t\to.points = points;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._getPoints(dataItem, o);\n\t\t\t}\n\n\t\t\tif (strokeTemplateField) {\n\t\t\t\tlet strokeTemplate = (dataItem.dataContext as any)[strokeTemplateField]\n\t\t\t\tif (strokeTemplate) {\n\t\t\t\t\tif (!(strokeTemplate instanceof Template)) {\n\t\t\t\t\t\tstrokeTemplate = Template.new(strokeTemplate);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._strokeTemplate = strokeTemplate;\n\t\t\t\t\tif (i > dataItemIndex) {\n\t\t\t\t\t\tcurrentEndIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tstroke.template = strokeTemplate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fillTemplateField) {\n\t\t\t\tlet fillTemplate = (dataItem.dataContext as any)[fillTemplateField]\n\t\t\t\tif (fillTemplate) {\n\t\t\t\t\tif (!(fillTemplate instanceof Template)) {\n\t\t\t\t\t\tfillTemplate = Template.new(fillTemplate);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._fillTemplate = fillTemplate;\n\t\t\t\t\tif (i > dataItemIndex) {\n\t\t\t\t\t\tcurrentEndIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfill.template = fillTemplate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!connect) {\n\t\t\t\tlet nextItem = this.dataItems[i + 1];\n\t\t\t\tif (nextItem) {\n\t\t\t\t\tif (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {\n\t\t\t\t\t\tpoints = [];\n\t\t\t\t\t\tsegments.push(points);\n\t\t\t\t\t\to.points = points;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill.setRaw(\"userData\", [dataItemIndex, i]);\n\t\tstroke.setRaw(\"userData\", [dataItemIndex, i]);\n\n\t\tif (i === endIndex) {\n\t\t\tthis._endLine(points, segments[0][0]);\n\t\t}\n\n\t\tif (stroke) {\n\t\t\tthis._drawStroke(stroke, segments);\n\t\t}\n\n\t\tif (fill) {\n\t\t\tthis._drawFill(fill, segments);\n\t\t}\n\n\t\tthis.axisRanges.each((axisRange) => {\n\t\t\tconst container = axisRange.container;\n\t\t\tconst fills = axisRange.fills!;\n\t\t\tconst fill = this.makeFill(fills);\n\n\t\t\tif (container) {\n\t\t\t\tcontainer.children.push(fill);\n\t\t\t}\n\n\t\t\tfill.setPrivate(\"visible\", true);\n\t\t\tthis._drawFill(fill, segments);\n\n\t\t\tconst strokes = axisRange.strokes!;\n\t\t\tconst stroke = this.makeStroke(strokes);\n\t\t\tif (container) {\n\t\t\t\tcontainer.children.push(stroke);\n\t\t\t}\n\n\t\t\tstroke.setPrivate(\"visible\", true);\n\t\t\tthis._drawStroke(stroke, segments);\n\n\t\t\tfill.setRaw(\"userData\", [dataItemIndex, i]);\n\t\t\tstroke.setRaw(\"userData\", [dataItemIndex, i]);\n\t\t})\n\t}\n\n\tprotected _getPoints(dataItem: DataItem<this[\"_dataItemSettings\"]>, o: { points: Array<Array<number>>, segments: number[][][], stacked: boolean | undefined, getOpen: boolean, basePosX: number, basePosY: number, fillVisible: boolean | undefined, xField: string, yField: string, xOpenField: string, yOpenField: string, vcx: number, vcy: number, baseAxis: Axis<AxisRenderer>, xAxis: Axis<AxisRenderer>, yAxis: Axis<AxisRenderer>, locationX: number, locationY: number, openLocationX: number, openLocationY: number, minDistance: number }) {\n\t\tlet points = o.points;\n\n\t\tlet itemLocationX = dataItem.get(\"locationX\", o.locationX);\n\t\tlet itemLocationY = dataItem.get(\"locationY\", o.locationY);\n\n\t\tlet xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);\n\t\tlet yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);\n\n\t\tif (this._shouldInclude(xPos)) {\n\n\t\t\tconst iPoint = this.getPoint(xPos, yPos);\n\t\t\tconst point = [iPoint.x, iPoint.y];\n\n\t\t\tiPoint.x += this._x;\n\t\t\tiPoint.y += this._y;\n\n\t\t\tdataItem.set(\"point\", iPoint);\n\n\t\t\tif (o.fillVisible) {\n\t\t\t\tlet xPos0: number = xPos;\n\t\t\t\tlet yPos0: number = yPos;\n\n\t\t\t\tif (o.baseAxis === o.xAxis) {\n\t\t\t\t\tyPos0 = o.basePosY;\n\t\t\t\t}\n\t\t\t\telse if (o.baseAxis === o.yAxis) {\n\t\t\t\t\txPos0 = o.basePosX;\n\t\t\t\t}\n\n\t\t\t\tif (o.getOpen) {\n\t\t\t\t\tlet valueX = dataItem.get(o.xOpenField as any);\n\t\t\t\t\tlet valueY = dataItem.get(o.yOpenField as any);\n\n\t\t\t\t\tif (valueX != null && valueY != null) {\n\t\t\t\t\t\tlet itemLocationX = dataItem.get(\"openLocationX\", o.openLocationX);\n\t\t\t\t\t\tlet itemLocationY = dataItem.get(\"openLocationY\", o.openLocationY);\n\n\t\t\t\t\t\tif (o.stacked) {\n\t\t\t\t\t\t\tlet stackToItemX = dataItem.get(\"stackToItemX\")!;\n\t\t\t\t\t\t\tlet stackToItemY = dataItem.get(\"stackToItemY\")!;\n\n\t\t\t\t\t\t\tif (stackToItemX) {\n\t\t\t\t\t\t\t\txPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX, (stackToItemX.component as XYSeries).get(\"vcx\"));\n\t\t\t\t\t\t\t\tif ($type.isNaN(xPos0)) {\n\t\t\t\t\t\t\t\t\txPos0 = o.basePosX;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (o.yAxis === o.baseAxis) {\n\t\t\t\t\t\t\t\t\txPos0 = o.basePosX;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\txPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stackToItemY) {\n\t\t\t\t\t\t\t\tyPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY, (stackToItemY.component as XYSeries).get(\"vcy\"));\n\t\t\t\t\t\t\t\tif ($type.isNaN(yPos0)) {\n\t\t\t\t\t\t\t\t\tyPos0 = o.basePosY;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (o.xAxis === o.baseAxis) {\n\t\t\t\t\t\t\t\t\tyPos0 = o.basePosY;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tyPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\txPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);\n\t\t\t\t\t\t\tyPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet closeIPoint = this.getPoint(xPos0, yPos0);\n\n\t\t\t\tpoint[2] = closeIPoint.x;\n\t\t\t\tpoint[3] = closeIPoint.y;\n\t\t\t}\n\n\t\t\tif (o.minDistance > 0) {\n\t\t\t\tconst p0 = point[0];\n\t\t\t\tconst p1 = point[1];\n\t\t\t\tconst p2 = point[2];\n\t\t\t\tconst p3 = point[3];\n\n\t\t\t\tconst prev = this._previousPoint;\n\n\t\t\t\tconst pp0 = prev[0];\n\t\t\t\tconst pp1 = prev[1];\n\t\t\t\tconst pp2 = prev[2];\n\t\t\t\tconst pp3 = prev[3];\n\n\t\t\t\tif (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || (p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance)) {\n\t\t\t\t\tpoints.push(point);\n\t\t\t\t\tthis._previousPoint = point;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpoints.push(point);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprotected _endLine(_points: Array<Array<number>>, _firstPoint: Array<number>) {\n\n\t}\n\n\tprotected _drawStroke(graphics: Graphics, segments: number[][][]) {\n\t\tif (graphics.get(\"visible\") && !graphics.get(\"forceHidden\")) {\n\t\t\tgraphics.set(\"draw\", (display) => {\n\t\t\t\t$array.each(segments, (segment) => {\n\t\t\t\t\tthis._strokeGenerator.context(display as any);\n\t\t\t\t\tthis._strokeGenerator(segment as [number, number][]);\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _drawFill(graphics: Graphics, segments: number[][][]) {\n\t\tif (graphics.get(\"visible\") && !graphics.get(\"forceHidden\")) {\n\t\t\tgraphics.set(\"draw\", (display) => {\n\t\t\t\t$array.each(segments, (segment) => {\n\t\t\t\t\tthis._fillGenerator.context(display as any);\n\t\t\t\t\tthis._fillGenerator(segment as [number, number][]);\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _processAxisRange(axisRange: this[\"_axisRangeType\"]) {\n\t\tsuper._processAxisRange(axisRange);\n\t\taxisRange.fills = new ListTemplate(\n\t\t\tTemplate.new({}),\n\t\t\t() => Graphics._new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(axisRange.fills!.template.get(\"themeTags\", []), [\"line\", \"series\", \"fill\"]),\n\t\t\t}, [this.fills.template, axisRange.fills!.template]),\n\t\t);\n\n\t\taxisRange.strokes = new ListTemplate(\n\t\t\tTemplate.new({}),\n\t\t\t() => Graphics._new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(axisRange.strokes!.template.get(\"themeTags\", []), [\"line\", \"series\", \"stroke\"]),\n\t\t\t}, [this.strokes.template, axisRange.strokes!.template])\n\t\t);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic createLegendMarker(_dataItem?: DataItem<this[\"_dataItemSettings\"]>) {\n\n\t\tconst legendDataItem = this.get(\"legendDataItem\");\n\n\t\tif (legendDataItem) {\n\t\t\tconst marker = legendDataItem.get(\"marker\");\n\n\t\t\tconst markerRectangle = legendDataItem.get(\"markerRectangle\");\n\t\t\tif (markerRectangle) {\n\t\t\t\tmarkerRectangle.setPrivate(\"visible\", false);\n\t\t\t}\n\n\t\t\tmarker.set(\"background\", Rectangle.new(marker._root, { fillOpacity: 0, fill: color(0x000000) }))\n\n\t\t\tconst legendStroke = marker.children.push(Graphics._new(marker._root, {\n\t\t\t\tthemeTags: [\"line\", \"series\", \"legend\", \"marker\", \"stroke\"], interactive: false\n\t\t\t}, [this.strokes.template]));\n\n\t\t\tthis._legendStroke = legendStroke;\n\n\t\t\tconst legendFill = marker.children.push(Graphics._new(marker._root, {\n\t\t\t\tthemeTags: [\"line\", \"series\", \"legend\", \"marker\", \"fill\"]\n\t\t\t}, [this.fills.template]));\n\n\t\t\tthis._legendFill = legendFill;\n\n\t\t\tconst disabledColor = this._root.interfaceColors.get(\"disabled\");\n\n\t\t\tlegendStroke.states.create(\"disabled\", { fill: disabledColor, stroke: disabledColor });\n\t\t\tlegendFill.states.create(\"disabled\", { fill: disabledColor, stroke: disabledColor });\n\n\t\t\tif (this.bullets.length > 0) {\n\t\t\t\tconst bulletFunction = this.bullets.getIndex(0);\n\t\t\t\tif (bulletFunction) {\n\t\t\t\t\tconst bullet = bulletFunction(marker._root, this, new DataItem(this, {}, {}));\n\t\t\t\t\tif (bullet) {\n\t\t\t\t\t\tconst sprite = bullet.get(\"sprite\");\n\t\t\t\t\t\tif (sprite instanceof Graphics) {\n\t\t\t\t\t\t\tsprite.states.create(\"disabled\", { fill: disabledColor, stroke: disabledColor });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (sprite) {\n\t\t\t\t\t\t\tsprite.set(\"tooltipText\", undefined);\n\t\t\t\t\t\t\tsprite.set(\"tooltipHTML\", undefined);\n\n\t\t\t\t\t\t\tmarker.children.push(sprite);\n\t\t\t\t\t\t\tsprite.setAll({ x: marker.width() / 2, y: marker.height() / 2 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}