{"ast":null,"code":"/** @ignore */ /** */\nimport * as $array from \"./Array\";\nimport * as $utils from \"./Utils\";\n/**\r\n * @ignore\r\n */\nclass Native {\n  constructor() {\n    Object.defineProperty(this, \"_observer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_targets\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this._observer = new ResizeObserver(entries => {\n      $array.each(entries, entry => {\n        $array.each(this._targets, x => {\n          if (x.target === entry.target) {\n            x.callback();\n          }\n        });\n      });\n    });\n  }\n  addTarget(target, callback) {\n    this._observer.observe(target, {\n      box: \"border-box\"\n    });\n    this._targets.push({\n      target,\n      callback\n    });\n  }\n  removeTarget(target) {\n    this._observer.unobserve(target);\n    $array.keepIf(this._targets, x => {\n      return x.target !== target;\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Raf {\n  constructor() {\n    Object.defineProperty(this, \"_timer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"_targets\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  addTarget(target, callback) {\n    if (this._timer === null) {\n      let lastTime = null;\n      const loop = () => {\n        const currentTime = Date.now();\n        if (lastTime === null || currentTime > lastTime + Raf.delay) {\n          lastTime = currentTime;\n          $array.each(this._targets, x => {\n            let newSize = x.target.getBoundingClientRect();\n            if (newSize.width !== x.size.width || newSize.height !== x.size.height) {\n              x.size = newSize;\n              x.callback();\n            }\n          });\n        }\n        if (this._targets.length === 0) {\n          this._timer = null;\n        } else {\n          this._timer = requestAnimationFrame(loop);\n        }\n      };\n      this._timer = requestAnimationFrame(loop);\n    }\n    // We start off with fake bounds so that sensor always kicks in\n    let size = {\n      width: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n      x: 0,\n      y: 0\n    };\n    this._targets.push({\n      target,\n      callback,\n      size\n    });\n  }\n  removeTarget(target) {\n    $array.keepIf(this._targets, x => {\n      return x.target !== target;\n    });\n    if (this._targets.length === 0) {\n      if (this._timer !== null) {\n        cancelAnimationFrame(this._timer);\n        this._timer = null;\n      }\n    }\n  }\n}\nObject.defineProperty(Raf, \"delay\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 200\n});\n/**\r\n * @ignore\r\n */\nlet observer = null;\n/**\r\n * @ignore\r\n */\nfunction makeSensor() {\n  if (observer === null) {\n    if (typeof ResizeObserver !== \"undefined\") {\n      observer = new Native();\n    } else {\n      observer = new Raf();\n    }\n  }\n  return observer;\n}\n/**\r\n * @ignore\r\n */\nexport class ResizeSensor {\n  constructor(element, callback) {\n    Object.defineProperty(this, \"_sensor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_element\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_listener\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    this._sensor = makeSensor();\n    this._element = element;\n    // This is needed because we need to know when the window is zoomed\n    this._listener = $utils.onZoom(callback);\n    this._sensor.addTarget(element, callback);\n  }\n  isDisposed() {\n    return this._disposed;\n  }\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      this._sensor.removeTarget(this._element);\n      this._listener.dispose();\n    }\n  }\n  get sensor() {\n    return this._sensor;\n  }\n}","map":{"version":3,"names":["$array","$utils","Native","constructor","Object","defineProperty","_observer","ResizeObserver","entries","each","entry","_targets","x","target","callback","addTarget","observe","box","push","removeTarget","unobserve","keepIf","Raf","_timer","lastTime","loop","currentTime","Date","now","delay","newSize","getBoundingClientRect","width","size","height","length","requestAnimationFrame","left","right","top","bottom","y","cancelAnimationFrame","observer","makeSensor","ResizeSensor","element","_sensor","_element","_listener","onZoom","isDisposed","_disposed","dispose","sensor"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\util\\ResizeSensor.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport type { IDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $utils from \"./Utils\";\n\n/**\n * @ignore\n */\ninterface Sensor {\n\taddTarget(target: Element, callback: () => void): void;\n\tremoveTarget(target: Element): void;\n}\n\n/**\n * @ignore\n */\ndeclare const ResizeObserver: any;\n\n/**\n * @ignore\n */\nclass Native implements Sensor {\n\tprivate _observer: any;\n\tprivate _targets: Array<{ target: Element, callback: () => void }> = [];\n\n\tconstructor() {\n\t\tthis._observer = new ResizeObserver((entries: Array<any>) => {\n\t\t\t$array.each(entries, (entry) => {\n\t\t\t\t$array.each(this._targets, (x) => {\n\t\t\t\t\tif (x.target === entry.target) {\n\t\t\t\t\t\tx.callback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\taddTarget(target: Element, callback: () => void) {\n\t\tthis._observer.observe(target, { box: \"border-box\" });\n\t\tthis._targets.push({ target, callback });\n\t}\n\n\tremoveTarget(target: Element) {\n\t\tthis._observer.unobserve(target);\n\n\t\t$array.keepIf(this._targets, (x) => {\n\t\t\treturn x.target !== target;\n\t\t});\n\t}\n}\n\n/**\n * @ignore\n */\ninterface ClientBounds {\n\twidth: number,\n\theight: number,\n\tleft: number,\n\tright: number,\n\ttop: number,\n\tbottom: number,\n\tx: number,\n\ty: number\n}\n\n\n/**\n * @ignore\n */\nclass Raf implements Sensor {\n\tpublic static delay: number = 200;\n\n\tprivate _timer: number | null = null;\n\tprivate _targets: Array<{ target: Element, callback: () => void, size: ClientRect | DOMRect | ClientBounds }> = [];\n\n\taddTarget(target: Element, callback: () => void) {\n\t\tif (this._timer === null) {\n\t\t\tlet lastTime: number | null = null;\n\n\t\t\tconst loop = () => {\n\t\t\t\tconst currentTime = Date.now();\n\n\t\t\t\tif (lastTime === null || currentTime > (lastTime + Raf.delay)) {\n\t\t\t\t\tlastTime = currentTime;\n\n\t\t\t\t\t$array.each(this._targets, (x) => {\n\t\t\t\t\t\tlet newSize = x.target.getBoundingClientRect();\n\n\t\t\t\t\t\tif (newSize.width !== x.size.width || newSize.height !== x.size.height) {\n\t\t\t\t\t\t\tx.size = newSize;\n\t\t\t\t\t\t\tx.callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (this._targets.length === 0) {\n\t\t\t\t\tthis._timer = null;\n\n\t\t\t\t} else {\n\t\t\t\t\tthis._timer = requestAnimationFrame(loop);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._timer = requestAnimationFrame(loop);\n\t\t}\n\n\t\t// We start off with fake bounds so that sensor always kicks in\n\t\tlet size = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };\n\t\tthis._targets.push({ target, callback, size });\n\t}\n\n\tremoveTarget(target: Element) {\n\t\t$array.keepIf(this._targets, (x) => {\n\t\t\treturn x.target !== target;\n\t\t});\n\n\t\tif (this._targets.length === 0) {\n\t\t\tif (this._timer !== null) {\n\t\t\t\tcancelAnimationFrame(this._timer);\n\t\t\t\tthis._timer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * @ignore\n */\nlet observer: Sensor | null = null;\n\n/**\n * @ignore\n */\nfunction makeSensor(): Sensor {\n\tif (observer === null) {\n\t\tif (typeof ResizeObserver !== \"undefined\") {\n\t\t\tobserver = new Native();\n\n\t\t} else {\n\t\t\tobserver = new Raf();\n\t\t}\n\t}\n\n\treturn observer;\n}\n\n/**\n * @ignore\n */\nexport class ResizeSensor implements IDisposer {\n\tprivate _sensor: Sensor;\n\tprivate _element: Element;\n\tprivate _listener: IDisposer;\n\tprivate _disposed: boolean = false;\n\n\tconstructor(element: Element, callback: () => void) {\n\t\tthis._sensor = makeSensor();\n\t\tthis._element = element;\n\n\t\t// This is needed because we need to know when the window is zoomed\n\t\tthis._listener = $utils.onZoom(callback);\n\n\t\tthis._sensor.addTarget(element, callback);\n\t}\n\n\tpublic isDisposed() {\n\t\treturn this._disposed;\n\t}\n\n\tpublic dispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\t\t\tthis._sensor.removeTarget(this._element);\n\t\t\tthis._listener.dispose();\n\t\t}\n\t}\n\n\tpublic get sensor(): Sensor {\n\t\treturn this._sensor;\n\t}\n}\n"],"mappings":"AAAA,eAAc;AAGd,OAAO,KAAKA,MAAM,MAAM,SAAS;AACjC,OAAO,KAAKC,MAAM,MAAM,SAAS;AAejC;;;AAGA,MAAMC,MAAM;EAIXC,YAAA;IAHAC,MAAA,CAAAC,cAAA;;;;;;IACAD,MAAA,CAAAC,cAAA;;;;aAAqE;;IAGpE,IAAI,CAACC,SAAS,GAAG,IAAIC,cAAc,CAAEC,OAAmB,IAAI;MAC3DR,MAAM,CAACS,IAAI,CAACD,OAAO,EAAGE,KAAK,IAAI;QAC9BV,MAAM,CAACS,IAAI,CAAC,IAAI,CAACE,QAAQ,EAAGC,CAAC,IAAI;UAChC,IAAIA,CAAC,CAACC,MAAM,KAAKH,KAAK,CAACG,MAAM,EAAE;YAC9BD,CAAC,CAACE,QAAQ,EAAE;;QAEd,CAAC,CAAC;MACH,CAAC,CAAC;IACH,CAAC,CAAC;EACH;EAEAC,SAASA,CAACF,MAAe,EAAEC,QAAoB;IAC9C,IAAI,CAACR,SAAS,CAACU,OAAO,CAACH,MAAM,EAAE;MAAEI,GAAG,EAAE;IAAY,CAAE,CAAC;IACrD,IAAI,CAACN,QAAQ,CAACO,IAAI,CAAC;MAAEL,MAAM;MAAEC;IAAQ,CAAE,CAAC;EACzC;EAEAK,YAAYA,CAACN,MAAe;IAC3B,IAAI,CAACP,SAAS,CAACc,SAAS,CAACP,MAAM,CAAC;IAEhCb,MAAM,CAACqB,MAAM,CAAC,IAAI,CAACV,QAAQ,EAAGC,CAAC,IAAI;MAClC,OAAOA,CAAC,CAACC,MAAM,KAAKA,MAAM;IAC3B,CAAC,CAAC;EACH;;AAkBD;;;AAGA,MAAMS,GAAG;EAATnB,YAAA;IAGCC,MAAA,CAAAC,cAAA;;;;aAAgC;;IAChCD,MAAA,CAAAC,cAAA;;;;aAAgH;;EAkDjH;EAhDCU,SAASA,CAACF,MAAe,EAAEC,QAAoB;IAC9C,IAAI,IAAI,CAACS,MAAM,KAAK,IAAI,EAAE;MACzB,IAAIC,QAAQ,GAAkB,IAAI;MAElC,MAAMC,IAAI,GAAGA,CAAA,KAAK;QACjB,MAAMC,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;QAE9B,IAAIJ,QAAQ,KAAK,IAAI,IAAIE,WAAW,GAAIF,QAAQ,GAAGF,GAAG,CAACO,KAAM,EAAE;UAC9DL,QAAQ,GAAGE,WAAW;UAEtB1B,MAAM,CAACS,IAAI,CAAC,IAAI,CAACE,QAAQ,EAAGC,CAAC,IAAI;YAChC,IAAIkB,OAAO,GAAGlB,CAAC,CAACC,MAAM,CAACkB,qBAAqB,EAAE;YAE9C,IAAID,OAAO,CAACE,KAAK,KAAKpB,CAAC,CAACqB,IAAI,CAACD,KAAK,IAAIF,OAAO,CAACI,MAAM,KAAKtB,CAAC,CAACqB,IAAI,CAACC,MAAM,EAAE;cACvEtB,CAAC,CAACqB,IAAI,GAAGH,OAAO;cAChBlB,CAAC,CAACE,QAAQ,EAAE;;UAEd,CAAC,CAAC;;QAGH,IAAI,IAAI,CAACH,QAAQ,CAACwB,MAAM,KAAK,CAAC,EAAE;UAC/B,IAAI,CAACZ,MAAM,GAAG,IAAI;SAElB,MAAM;UACN,IAAI,CAACA,MAAM,GAAGa,qBAAqB,CAACX,IAAI,CAAC;;MAE3C,CAAC;MAED,IAAI,CAACF,MAAM,GAAGa,qBAAqB,CAACX,IAAI,CAAC;;IAG1C;IACA,IAAIQ,IAAI,GAAG;MAAED,KAAK,EAAE,CAAC;MAAEE,MAAM,EAAE,CAAC;MAAEG,IAAI,EAAE,CAAC;MAAEC,KAAK,EAAE,CAAC;MAAEC,GAAG,EAAE,CAAC;MAAEC,MAAM,EAAE,CAAC;MAAE5B,CAAC,EAAE,CAAC;MAAE6B,CAAC,EAAE;IAAC,CAAE;IACpF,IAAI,CAAC9B,QAAQ,CAACO,IAAI,CAAC;MAAEL,MAAM;MAAEC,QAAQ;MAAEmB;IAAI,CAAE,CAAC;EAC/C;EAEAd,YAAYA,CAACN,MAAe;IAC3Bb,MAAM,CAACqB,MAAM,CAAC,IAAI,CAACV,QAAQ,EAAGC,CAAC,IAAI;MAClC,OAAOA,CAAC,CAACC,MAAM,KAAKA,MAAM;IAC3B,CAAC,CAAC;IAEF,IAAI,IAAI,CAACF,QAAQ,CAACwB,MAAM,KAAK,CAAC,EAAE;MAC/B,IAAI,IAAI,CAACZ,MAAM,KAAK,IAAI,EAAE;QACzBmB,oBAAoB,CAAC,IAAI,CAACnB,MAAM,CAAC;QACjC,IAAI,CAACA,MAAM,GAAG,IAAI;;;EAGrB;;AApDAnB,MAAA,CAAAC,cAAA,CAAAiB,GAAA;;;;SAA8B;;AAwD/B;;;AAGA,IAAIqB,QAAQ,GAAkB,IAAI;AAElC;;;AAGA,SAASC,UAAUA,CAAA;EAClB,IAAID,QAAQ,KAAK,IAAI,EAAE;IACtB,IAAI,OAAOpC,cAAc,KAAK,WAAW,EAAE;MAC1CoC,QAAQ,GAAG,IAAIzC,MAAM,EAAE;KAEvB,MAAM;MACNyC,QAAQ,GAAG,IAAIrB,GAAG,EAAE;;;EAItB,OAAOqB,QAAQ;AAChB;AAEA;;;AAGA,OAAM,MAAOE,YAAY;EAMxB1C,YAAY2C,OAAgB,EAAEhC,QAAoB;IALlDV,MAAA,CAAAC,cAAA;;;;;;IACAD,MAAA,CAAAC,cAAA;;;;;;IACAD,MAAA,CAAAC,cAAA;;;;;;IACAD,MAAA,CAAAC,cAAA;;;;aAA6B;;IAG5B,IAAI,CAAC0C,OAAO,GAAGH,UAAU,EAAE;IAC3B,IAAI,CAACI,QAAQ,GAAGF,OAAO;IAEvB;IACA,IAAI,CAACG,SAAS,GAAGhD,MAAM,CAACiD,MAAM,CAACpC,QAAQ,CAAC;IAExC,IAAI,CAACiC,OAAO,CAAChC,SAAS,CAAC+B,OAAO,EAAEhC,QAAQ,CAAC;EAC1C;EAEOqC,UAAUA,CAAA;IAChB,OAAO,IAAI,CAACC,SAAS;EACtB;EAEOC,OAAOA,CAAA;IACb,IAAI,CAAC,IAAI,CAACD,SAAS,EAAE;MACpB,IAAI,CAACA,SAAS,GAAG,IAAI;MACrB,IAAI,CAACL,OAAO,CAAC5B,YAAY,CAAC,IAAI,CAAC6B,QAAQ,CAAC;MACxC,IAAI,CAACC,SAAS,CAACI,OAAO,EAAE;;EAE1B;EAEA,IAAWC,MAAMA,CAAA;IAChB,OAAO,IAAI,CAACP,OAAO;EACpB"},"metadata":{},"sourceType":"module","externalDependencies":[]}