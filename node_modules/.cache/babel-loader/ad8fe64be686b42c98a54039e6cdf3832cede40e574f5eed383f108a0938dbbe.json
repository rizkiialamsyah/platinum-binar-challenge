{"ast":null,"code":"import { Layout, eachChildren } from \"./Layout\";\nimport * as $array from \"../util/Array\";\nimport * as $math from \"../util/Math\";\n/**\r\n * A grid children layout for [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\r\n */\nexport class GridLayout extends Layout {\n  _afterNew() {\n    this._setRawDefault(\"maxColumns\", Number.MAX_VALUE);\n    super._afterNew();\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateContainer(container) {\n    let paddingLeft = container.get(\"paddingLeft\", 0);\n    let paddingRight = container.get(\"paddingRight\", 0);\n    let paddingTop = container.get(\"paddingTop\", 0);\n    let availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n    let minCellWidth = availableWidth;\n    let maxCellWidth = 1;\n    eachChildren(container, child => {\n      if (child.get(\"visible\") && child.getPrivate(\"visible\") && !child.get(\"forceHidden\")) {\n        if (child.get(\"position\") != \"absolute\") {\n          let childWidth = child.width();\n          if (childWidth < minCellWidth) {\n            minCellWidth = childWidth;\n          }\n          if (childWidth > maxCellWidth) {\n            maxCellWidth = childWidth;\n          }\n        }\n      }\n    });\n    minCellWidth = $math.fitToRange(minCellWidth, 1, availableWidth);\n    maxCellWidth = $math.fitToRange(maxCellWidth, 1, availableWidth);\n    let columnCount = 1;\n    if (this.get(\"fixedWidthGrid\")) {\n      columnCount = availableWidth / maxCellWidth;\n    } else {\n      columnCount = availableWidth / minCellWidth;\n    }\n    columnCount = Math.max(1, Math.floor(columnCount));\n    columnCount = Math.min(this.get(\"maxColumns\", Number.MAX_VALUE), columnCount);\n    let columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n    let prevY = paddingTop;\n    let column = 0;\n    let maxColumnHeight = 0;\n    columnCount = columnWidths.length;\n    let prevX = paddingLeft;\n    eachChildren(container, child => {\n      if (child.get(\"position\") == \"relative\" && child.isVisible()) {\n        const marginTop = child.get(\"marginTop\", 0);\n        const marginBottom = child.get(\"marginBottom\", 0);\n        let bounds = child.adjustedLocalBounds();\n        let marginLeft = child.get(\"marginLeft\", 0);\n        let marginRight = child.get(\"marginRight\", 0);\n        let x = prevX + marginLeft - bounds.left;\n        let y = prevY + marginTop - bounds.top;\n        child.setPrivate(\"x\", x);\n        child.setPrivate(\"y\", y);\n        prevX += columnWidths[column] + marginRight;\n        maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n        column++;\n        if (column >= columnCount) {\n          column = 0;\n          prevX = paddingLeft;\n          prevY += maxColumnHeight;\n        }\n      }\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  getColumnWidths(container, columnCount, maxCellWidth, availableWidth) {\n    let totalWidth = 0;\n    let columnWidths = [];\n    let column = 0;\n    eachChildren(container, child => {\n      let bounds = child.adjustedLocalBounds();\n      if (child.get(\"position\") != \"absolute\" && child.isVisible()) {\n        if (this.get(\"fixedWidthGrid\")) {\n          columnWidths[column] = maxCellWidth;\n        } else {\n          columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get(\"marginLeft\", 0) + child.get(\"marginRight\", 0));\n        }\n        if (column < container.children.length - 1) {\n          column++;\n          if (column == columnCount) {\n            column = 0;\n          }\n        }\n      }\n    });\n    $array.each(columnWidths, w => {\n      totalWidth += w;\n    });\n    if (totalWidth > availableWidth) {\n      if (columnCount > 2) {\n        columnCount -= 1;\n        return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n      } else {\n        return [availableWidth];\n      }\n    }\n    return columnWidths;\n  }\n}\nObject.defineProperty(GridLayout, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"GridLayout\"\n});\nObject.defineProperty(GridLayout, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Layout.classNames.concat([GridLayout.className])\n});","map":{"version":3,"names":["Layout","eachChildren","$array","$math","GridLayout","_afterNew","_setRawDefault","Number","MAX_VALUE","updateContainer","container","paddingLeft","get","paddingRight","paddingTop","availableWidth","maxWidth","minCellWidth","maxCellWidth","child","getPrivate","childWidth","width","fitToRange","columnCount","Math","max","floor","min","columnWidths","getColumnWidths","prevY","column","maxColumnHeight","length","prevX","isVisible","marginTop","marginBottom","bounds","adjustedLocalBounds","marginLeft","marginRight","x","left","y","top","setPrivate","height","totalWidth","right","children","each","w","Object","defineProperty","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\render\\GridLayout.ts"],"sourcesContent":["import { Layout, ILayoutSettings, ILayoutPrivate, eachChildren } from \"./Layout\";\nimport * as $array from \"../util/Array\";\nimport * as $math from \"../util/Math\";\nimport type { Container } from \"./Container\";\n\n\nexport interface IGridLayoutSettings extends ILayoutSettings {\n\n\t/**\n\t * If set to `true` all columns in the grid will be equal width.\n\t *\n\t * @default false\n\t */\n\tfixedWidthGrid?: boolean;\n\n\t/**\n\t * Maximum number of columns in the grid.\n\t */\n\tmaxColumns?: number;\n\n}\n\nexport interface IGridLayoutPrivate extends ILayoutPrivate {\n}\n\n/**\n * A grid children layout for [[Container]].\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\n */\nexport class GridLayout extends Layout {\n\n\tpublic static className: string = \"GridLayout\";\n\tpublic static classNames: Array<string> = Layout.classNames.concat([GridLayout.className]);\n\n\tdeclare public _settings: IGridLayoutSettings;\n\tdeclare public _privateSettings: IGridLayoutPrivate;\n\n\n\tprotected _afterNew() {\n\t\tthis._setRawDefault(\"maxColumns\", Number.MAX_VALUE);\n\t\tsuper._afterNew();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic updateContainer(container: Container): void {\n\t\tlet paddingLeft = container.get(\"paddingLeft\", 0);\n\t\tlet paddingRight = container.get(\"paddingRight\", 0);\n\t\tlet paddingTop = container.get(\"paddingTop\", 0);\n\n\t\tlet availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n\n\t\tlet minCellWidth = availableWidth;\n\t\tlet maxCellWidth = 1;\n\n\t\teachChildren(container, (child) => {\n\t\t\tif(child.get(\"visible\") && child.getPrivate(\"visible\") && !child.get(\"forceHidden\")){\n\t\t\t\tif (child.get(\"position\") != \"absolute\") {\n\t\t\t\t\tlet childWidth = child.width();\n\n\t\t\t\t\tif (childWidth < minCellWidth) {\n\t\t\t\t\t\tminCellWidth = childWidth;\n\t\t\t\t\t}\n\t\t\t\t\tif (childWidth > maxCellWidth) {\n\t\t\t\t\t\tmaxCellWidth = childWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tminCellWidth = $math.fitToRange(minCellWidth, 1, availableWidth);\n\t\tmaxCellWidth = $math.fitToRange(maxCellWidth, 1, availableWidth);\n\n\t\tlet columnCount = 1;\n\t\tif (this.get(\"fixedWidthGrid\")) {\n\t\t\tcolumnCount = availableWidth / maxCellWidth;\n\t\t}\n\t\telse {\n\t\t\tcolumnCount = availableWidth / minCellWidth;\n\t\t}\n\n\t\tcolumnCount = Math.max(1, Math.floor(columnCount));\n\t\tcolumnCount = Math.min(this.get(\"maxColumns\", Number.MAX_VALUE), columnCount);\n\n\t\tlet columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n\n\t\tlet prevY = paddingTop;\n\n\t\tlet column = 0;\n\t\tlet maxColumnHeight = 0;\n\n\t\tcolumnCount = columnWidths.length;\n\n\t\tlet prevX = paddingLeft;\n\n\t\teachChildren(container, (child) => {\n\t\t\tif (child.get(\"position\") == \"relative\" && child.isVisible()) {\n\t\t\t\tconst marginTop = child.get(\"marginTop\", 0);\n\t\t\t\tconst marginBottom = child.get(\"marginBottom\", 0);\n\n\t\t\t\tlet bounds = child.adjustedLocalBounds();\n\n\t\t\t\tlet marginLeft = child.get(\"marginLeft\", 0);\n\t\t\t\tlet marginRight = child.get(\"marginRight\", 0);\n\t\t\t\tlet x = prevX + marginLeft - bounds.left;\n\t\t\t\tlet y = prevY + marginTop - bounds.top;\n\n\t\t\t\tchild.setPrivate(\"x\", x);\n\t\t\t\tchild.setPrivate(\"y\", y);\n\n\t\t\t\tprevX += columnWidths[column] + marginRight;\n\n\t\t\t\tmaxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n\n\t\t\t\tcolumn++;\n\n\t\t\t\tif (column >= columnCount) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tprevX = paddingLeft;\n\t\t\t\t\tprevY += maxColumnHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getColumnWidths(container: Container, columnCount: number, maxCellWidth: number, availableWidth: number): number[] {\n\t\tlet totalWidth = 0;\n\t\tlet columnWidths: Array<number> = [];\n\t\tlet column = 0;\n\n\t\teachChildren(container, (child) => {\n\t\t\tlet bounds = child.adjustedLocalBounds();\n\t\t\tif (child.get(\"position\") != \"absolute\" && child.isVisible()) {\n\t\t\t\tif (this.get(\"fixedWidthGrid\")) {\n\t\t\t\t\tcolumnWidths[column] = maxCellWidth;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get(\"marginLeft\", 0) + child.get(\"marginRight\", 0));\n\t\t\t\t}\n\n\t\t\t\tif (column < container.children.length - 1) {\n\t\t\t\t\tcolumn++;\n\t\t\t\t\tif (column == columnCount) {\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$array.each(columnWidths, (w) => {\n\t\t\ttotalWidth += w;\n\t\t})\n\n\t\tif (totalWidth > availableWidth) {\n\t\t\tif (columnCount > 2) {\n\t\t\t\tcolumnCount -= 1;\n\t\t\t\treturn this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn [availableWidth];\n\t\t\t}\n\t\t}\n\n\t\treturn columnWidths;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}