{"ast":null,"code":"import { MultiDisposer } from \"../util/Disposer\";\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n/**\r\n * Creates a tooltip.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\r\n * @important\r\n */\nexport class Tooltip extends Container {\n  constructor(root, settings, isReal) {\n    let templates = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    super(root, settings, isReal, templates);\n    Object.defineProperty(this, \"_fx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_fy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_label\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_fillDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_strokeDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_labelDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_w\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_h\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_keepHoverDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_htmlContentHovered\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n    super._afterNew();\n    this.set(\"background\", PointedRectangle.new(this._root, {\n      themeTags: [\"tooltip\", \"background\"]\n    }));\n    this._label = this.children.push(Label.new(this._root, {}));\n    this._disposers.push(this._label.events.on(\"boundschanged\", () => {\n      this._updateBackground();\n    }));\n    this._disposers.push(this.on(\"bounds\", () => {\n      this._updateBackground();\n    }));\n    this._updateTextColor();\n    this._root.tooltipContainer.children.push(this);\n    this.hide(0);\n    this._disposers.push(this.label.onPrivate(\"htmlElement\", htmlElement => {\n      if (htmlElement) {\n        $utils.addEventListener(htmlElement, \"pointerover\", _ev => {\n          this._htmlContentHovered = true;\n        });\n        $utils.addEventListener(htmlElement, \"pointerout\", _ev => {\n          this._htmlContentHovered = false;\n        });\n      }\n    }));\n    this._root._tooltips.push(this);\n  }\n  /**\r\n   * A [[Label]] element for the tooltip.\r\n   *\r\n   * @readonly\r\n   * @return Label\r\n   */\n  get label() {\n    return this._label;\n  }\n  /**\r\n   * Permanently disposes the tooltip.\r\n   */\n  dispose() {\n    super.dispose();\n    $array.remove(this._root._tooltips, this);\n  }\n  _updateChildren() {\n    super._updateChildren();\n    if (this.isDirty(\"pointerOrientation\") || this.isPrivateDirty(\"minWidth\") || this.isPrivateDirty(\"minHeight\")) {\n      this.get(\"background\")._markDirtyKey(\"width\");\n    }\n    const labelText = this.get(\"labelText\");\n    if (labelText != null) {\n      this.label.set(\"text\", this.get(\"labelText\"));\n    }\n    const labelHTML = this.get(\"labelHTML\");\n    if (labelHTML != null) {\n      this.label.set(\"html\", this.get(\"labelHTML\"));\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this.isDirty(\"pointTo\") || this.isDirty(\"pointerOrientation\")) {\n      // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n      this._updateBackground();\n    }\n    if (this.isDirty(\"tooltipTarget\")) {\n      this.updateBackgroundColor();\n    }\n    if (this.isDirty(\"keepTargetHover\")) {\n      const keephover = this.get(\"keepTargetHover\");\n      if (keephover) {\n        const bg = this.get(\"background\");\n        this._keepHoverDp = new MultiDisposer([bg.events.on(\"pointerover\", _ev => {\n          let target = this.get(\"tooltipTarget\");\n          if (target) {\n            if (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n              target = target.parent;\n            }\n            target.hover();\n          }\n        }), bg.events.on(\"pointerout\", _ev => {\n          let target = this.get(\"tooltipTarget\");\n          if (target) {\n            if (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n              target = target.parent;\n            }\n            if (!this._htmlContentHovered) {\n              target.unhover();\n            }\n          }\n        })]);\n      } else {\n        if (this._keepHoverDp) {\n          this._keepHoverDp.dispose();\n          this._keepHoverDp = undefined;\n        }\n      }\n    }\n  }\n  _onShow() {\n    super._onShow();\n    this.updateBackgroundColor();\n  }\n  updateBackgroundColor() {\n    let tooltipTarget = this.get(\"tooltipTarget\");\n    const background = this.get(\"background\");\n    let fill;\n    let stroke;\n    if (tooltipTarget && background) {\n      fill = tooltipTarget.get(\"fill\");\n      stroke = tooltipTarget.get(\"stroke\");\n      if (fill == null) {\n        fill = stroke;\n      }\n      if (this.get(\"getFillFromSprite\")) {\n        if (this._fillDp) {\n          this._fillDp.dispose();\n        }\n        if (fill != null) {\n          background.set(\"fill\", fill);\n        }\n        this._fillDp = tooltipTarget.on(\"fill\", fill => {\n          if (fill != null) {\n            background.set(\"fill\", fill);\n            this._updateTextColor(fill);\n          }\n        });\n        this._disposers.push(this._fillDp);\n      }\n      if (this.get(\"getStrokeFromSprite\")) {\n        if (this._strokeDp) {\n          this._strokeDp.dispose();\n        }\n        if (fill != null) {\n          background.set(\"stroke\", fill);\n        }\n        this._strokeDp = tooltipTarget.on(\"fill\", fill => {\n          if (fill != null) {\n            background.set(\"stroke\", fill);\n          }\n        });\n        this._disposers.push(this._strokeDp);\n      }\n      if (this.get(\"getLabelFillFromSprite\")) {\n        if (this._labelDp) {\n          this._labelDp.dispose();\n        }\n        if (fill != null) {\n          this.label.set(\"fill\", fill);\n        }\n        this._labelDp = tooltipTarget.on(\"fill\", fill => {\n          if (fill != null) {\n            this.label.set(\"fill\", fill);\n          }\n        });\n        this._disposers.push(this._labelDp);\n      }\n    }\n    this._updateTextColor(fill);\n  }\n  _updateTextColor(fill) {\n    if (this.get(\"autoTextColor\")) {\n      if (fill == null) {\n        fill = this.get(\"background\").get(\"fill\");\n      }\n      if (fill == null) {\n        fill = this._root.interfaceColors.get(\"background\");\n      }\n      if (fill instanceof Color) {\n        this.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n      }\n    }\n  }\n  _setDataItem(dataItem) {\n    super._setDataItem(dataItem);\n    this.label._setDataItem(dataItem);\n  }\n  _updateBackground() {\n    super.updateBackground();\n    const parent = this._root.container;\n    if (parent) {\n      let cw = 0.5;\n      let ch = 0.5;\n      let centerX = this.get(\"centerX\");\n      if (centerX instanceof Percent) {\n        cw = centerX.value;\n      }\n      let centerY = this.get(\"centerY\");\n      if (centerY instanceof Percent) {\n        ch = centerY.value;\n      }\n      let parentW = parent.width();\n      let parentH = parent.height();\n      let tooltipContainer = this.parent;\n      let xx = 0;\n      let yy = 0;\n      if (tooltipContainer) {\n        xx = tooltipContainer.x();\n        yy = tooltipContainer.y();\n        const layerMargin = tooltipContainer.get(\"layerMargin\");\n        if (layerMargin) {\n          xx += layerMargin.left || 0;\n          yy += layerMargin.top || 0;\n          parentW += (layerMargin.left || 0) + (layerMargin.right || 0);\n          parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);\n        }\n      }\n      const bounds = this.get(\"bounds\", {\n        left: -xx,\n        top: -yy,\n        right: parentW - xx,\n        bottom: parentH - yy\n      });\n      this._updateBounds();\n      let w = this.width();\n      let h = this.height();\n      // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n      if (w === 0) {\n        w = this._w;\n      }\n      if (h === 0) {\n        h = this._h;\n      }\n      let pointTo = this.get(\"pointTo\", {\n        x: parentW / 2,\n        y: parentH / 2\n      });\n      let x = pointTo.x;\n      let y = pointTo.y;\n      let pointerOrientation = this.get(\"pointerOrientation\");\n      let background = this.get(\"background\");\n      let pointerLength = 0;\n      let bgStrokeSizeY = 0;\n      let bgStrokeSizeX = 0;\n      if (background instanceof PointedRectangle) {\n        pointerLength = background.get(\"pointerLength\", 0);\n        bgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n        bgStrokeSizeX = bgStrokeSizeY;\n        background.set(\"width\", w);\n        background.set(\"height\", h);\n      }\n      let pointerX = 0;\n      let pointerY = 0;\n      let boundsW = bounds.right - bounds.left;\n      let boundsH = bounds.bottom - bounds.top;\n      // horizontal\n      if (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n        bgStrokeSizeY = 0;\n        if (pointerOrientation == \"horizontal\") {\n          if (x > bounds.left + boundsW / 2) {\n            x -= w * (1 - cw) + pointerLength;\n            bgStrokeSizeX *= -1;\n          } else {\n            x += w * cw + pointerLength;\n          }\n        } else if (pointerOrientation == \"left\") {\n          x += w * (1 - cw) + pointerLength;\n        } else {\n          x -= w * cw + pointerLength;\n          bgStrokeSizeX *= -1;\n        }\n      }\n      // vertical pointer\n      else {\n        bgStrokeSizeX = 0;\n        if (pointerOrientation == \"vertical\") {\n          if (y > bounds.top + h / 2 + pointerLength) {\n            y -= h * (1 - ch) + pointerLength;\n          } else {\n            y += h * ch + pointerLength;\n            bgStrokeSizeY *= -1;\n          }\n        } else if (pointerOrientation == \"down\") {\n          y -= h * (1 - ch) + pointerLength;\n        } else {\n          y += h * ch + pointerLength;\n          bgStrokeSizeY *= -1;\n        }\n      }\n      x = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n      y = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n      pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n      pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n      this._fx = x;\n      this._fy = y;\n      const animationDuration = this.get(\"animationDuration\", 0);\n      if (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n        const animationEasing = this.get(\"animationEasing\");\n        this.animate({\n          key: \"x\",\n          to: x,\n          duration: animationDuration,\n          easing: animationEasing\n        });\n        this.animate({\n          key: \"y\",\n          to: y,\n          duration: animationDuration,\n          easing: animationEasing\n        });\n      } else {\n        this.set(\"x\", x);\n        this.set(\"y\", y);\n      }\n      if (background instanceof PointedRectangle) {\n        background.set(\"pointerX\", pointerX);\n        background.set(\"pointerY\", pointerY);\n      }\n      if (w > 0) {\n        this._w = w;\n      }\n      if (h > 0) {\n        this._h = h;\n      }\n    }\n  }\n}\nObject.defineProperty(Tooltip, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"Tooltip\"\n});\nObject.defineProperty(Tooltip, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Tooltip.className])\n});","map":{"version":3,"names":["MultiDisposer","Label","PointedRectangle","Container","Percent","Color","$math","$array","$utils","Tooltip","constructor","root","settings","isReal","templates","arguments","length","undefined","Object","defineProperty","_afterNew","_settings","themeTags","mergeTags","set","new","_root","_label","children","push","_disposers","events","on","_updateBackground","_updateTextColor","tooltipContainer","hide","label","onPrivate","htmlElement","addEventListener","_ev","_htmlContentHovered","_tooltips","dispose","remove","_updateChildren","isDirty","isPrivateDirty","get","_markDirtyKey","labelText","labelHTML","_changed","updateBackgroundColor","keephover","bg","_keepHoverDp","target","parent","getPrivate","hover","unhover","_onShow","tooltipTarget","background","fill","stroke","_fillDp","_strokeDp","_labelDp","interfaceColors","alternative","_setDataItem","dataItem","updateBackground","container","cw","ch","centerX","value","centerY","parentW","width","parentH","height","xx","yy","x","y","layerMargin","left","top","right","bottom","bounds","_updateBounds","w","h","_w","_h","pointTo","pointerOrientation","pointerLength","bgStrokeSizeY","bgStrokeSizeX","pointerX","pointerY","boundsW","boundsH","fitToRange","_fx","_fy","animationDuration","animationEasing","animate","key","to","duration","easing","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\render\\Tooltip.ts"],"sourcesContent":["import type { IBounds } from \"../util/IBounds\";\nimport type { IPoint } from \"../util/IPoint\";\nimport type { Pattern } from \"../render/patterns/Pattern\";\nimport type { Time } from \"../util/Animation\";\nimport type { Sprite } from \"../render/Sprite\";\n\nimport { MultiDisposer, IDisposer } from \"../util/Disposer\";\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container, IContainerPrivate, IContainerSettings } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\n\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n//import * as $utils from \"../util/Utils\";\nimport type { DataItem, IComponentDataItem } from \"./Component\";\n\nimport type { Root } from \"../Root\";\nimport type { Template } from \"../util/Template\";\nimport type { Entity } from \"../util/Entity\";\n\n\nexport interface ITooltipSettings extends IContainerSettings {\n\n\t/**\n\t * Text to use for tooltip's label.\n\t */\n\tlabelText?: string\n\n\t/**\n\t * HTML content to use for tooltip's label.\n\t *\n\t * @since 5.2.11\n\t */\n\tlabelHTML?: string\n\n\t/**\n\t * A direction of the tooltip pointer.\n\t *\n\t * https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Orientation\n\t */\n\tpointerOrientation?: \"left\" | \"right\" | \"up\" | \"down\" | \"vertical\" | \"horizontal\";\n\n\t/**\n\t * If set to `true` will use the same `fill` color for its background as\n\t * its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetFillFromSprite?: boolean;\n\n\t/**\n\t * If set to `true` will use the same `fill` color as its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetLabelFillFromSprite?: boolean;\n\n\t/**\n\t * If set to `true` will use the same `stroke` color as its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetStrokeFromSprite?: boolean;\n\n\t/**\n\t * Screen bounds to constrain the tooltip within.\n\t */\n\tbounds?: IBounds;\n\n\t/**\n\t * If set to `true` tooltip will adjust its text color for better visibility\n\t * on its background.\n\t *\n\t * @default true\n\t */\n\tautoTextColor?: boolean;\n\n\t/**\n\t * Screen coordinates the tooltip show point to.\n\t */\n\tpointTo?: IPoint;\n\n\t/**\n\t * Duration in milliseconds for tooltip position change, e.g. when tooltip\n\t * is jumping from one target to another.\n\t */\n\tanimationDuration?: number;\n\n\t/**\n\t * Easing function for tooltip animation.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Easing_functions} for more info\n\t */\n\tanimationEasing?: (t: Time) => Time;\n\n\t/**\n\t * A target element tooltip is shown fow.\n\t */\n\ttooltipTarget?: Sprite;\n\n\t/**\n\t * If set to `true`, tooltip's target element will considered to be hovered\n\t * when mouse pointer is over tooltip itself.\n\t *\n\t * @since 5.2.14\n\t */\n\tkeepTargetHover?: boolean;\n\n}\n\nexport interface ITooltipPrivate extends IContainerPrivate {\n}\n\n/**\n * Creates a tooltip.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\n * @important\n */\nexport class Tooltip extends Container {\n\n\tpublic _fx: number = 0;\n\tpublic _fy: number = 0;\n\n\tdeclare public _settings: ITooltipSettings;\n\tdeclare public _privateSettings: ITooltipPrivate;\n\n\tprotected _label!: Label;\n\tpublic static className: string = \"Tooltip\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([Tooltip.className]);\n\n\tprotected _fillDp: IDisposer | undefined;\n\tprotected _strokeDp: IDisposer | undefined;\n\tprotected _labelDp: IDisposer | undefined;\n\n\tprotected _w: number = 0;\n\tprotected _h: number = 0;\n\n\tprotected _keepHoverDp: MultiDisposer | undefined;\n\tprotected _htmlContentHovered: boolean = false;\n\n\tconstructor(root: Root, settings: Entity[\"_settings\"], isReal: boolean, templates: Array<Template<Entity>> = []) {\n\t\tsuper(root, settings, isReal, templates);\n\t}\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n\n\t\tsuper._afterNew();\n\n\t\tthis.set(\"background\", PointedRectangle.new(this._root, {\n\t\t\tthemeTags: [\"tooltip\", \"background\"]\n\t\t}));\n\n\t\tthis._label = this.children.push(Label.new(this._root, {}));\n\n\t\tthis._disposers.push(this._label.events.on(\"boundschanged\", () => {\n\t\t\tthis._updateBackground();\n\t\t}))\n\n\t\tthis._disposers.push(this.on(\"bounds\", () => {\n\t\t\tthis._updateBackground();\n\t\t}))\n\n\t\tthis._updateTextColor();\n\n\t\tthis._root.tooltipContainer.children.push(this);\n\t\tthis.hide(0);\n\n\t\tthis._disposers.push(this.label.onPrivate(\"htmlElement\", (htmlElement) => {\n\t\t\tif (htmlElement) {\n\t\t\t\t$utils.addEventListener(htmlElement, \"pointerover\", (_ev) => {\n\t\t\t\t\tthis._htmlContentHovered = true;\n\t\t\t\t});\n\t\t\t\t$utils.addEventListener(htmlElement, \"pointerout\", (_ev) => {\n\t\t\t\t\tthis._htmlContentHovered = false;\n\t\t\t\t});\n\t\t\t}\n\t\t}))\n\n\t\tthis._root._tooltips.push(this);\n\t}\n\n\t/**\n\t * A [[Label]] element for the tooltip.\n\t *\n\t * @readonly\n\t * @return Label\n\t */\n\tpublic get label(): Label {\n\t\treturn this._label;\n\t}\n\n\t/**\n\t * Permanently disposes the tooltip.\n\t */\n\tpublic dispose() {\n\t\tsuper.dispose();\n\t\t$array.remove(this._root._tooltips, this);\n\t}\n\n\tpublic _updateChildren() {\n\t\tsuper._updateChildren();\n\n\t\tif (this.isDirty(\"pointerOrientation\") || this.isPrivateDirty(\"minWidth\") || this.isPrivateDirty(\"minHeight\")) {\n\t\t\tthis.get(\"background\")!._markDirtyKey(\"width\");\n\t\t}\n\n\t\tconst labelText = this.get(\"labelText\");\n\t\tif (labelText != null) {\n\t\t\tthis.label.set(\"text\", this.get(\"labelText\"));\n\t\t}\n\t\tconst labelHTML = this.get(\"labelHTML\");\n\t\tif (labelHTML != null) {\n\t\t\tthis.label.set(\"html\", this.get(\"labelHTML\"));\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this.isDirty(\"pointTo\") || this.isDirty(\"pointerOrientation\")) {\n\t\t\t// can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n\t\t\tthis._updateBackground();\n\t\t}\n\n\t\tif (this.isDirty(\"tooltipTarget\")) {\n\t\t\tthis.updateBackgroundColor();\n\t\t}\n\n\t\tif (this.isDirty(\"keepTargetHover\")) {\n\t\t\tconst keephover = this.get(\"keepTargetHover\");\n\t\t\tif (keephover) {\n\t\t\t\tconst bg = this.get(\"background\")!;\n\t\t\t\tthis._keepHoverDp = new MultiDisposer([\n\t\t\t\t\tbg.events.on(\"pointerover\", (_ev) => {\n\t\t\t\t\t\tlet target = this.get(\"tooltipTarget\");\n\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\tif (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n\t\t\t\t\t\t\t\ttarget = target.parent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget.hover();\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tbg.events.on(\"pointerout\", (_ev) => {\n\t\t\t\t\t\tlet target = this.get(\"tooltipTarget\");\n\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\tif (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n\t\t\t\t\t\t\t\ttarget = target.parent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!this._htmlContentHovered) {\n\t\t\t\t\t\t\t\ttarget.unhover();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this._keepHoverDp) {\n\t\t\t\t\tthis._keepHoverDp.dispose();\n\t\t\t\t\tthis._keepHoverDp = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _onShow() {\n\t\tsuper._onShow();\n\t\tthis.updateBackgroundColor();\n\t}\n\n\n\tpublic updateBackgroundColor() {\n\t\tlet tooltipTarget = this.get(\"tooltipTarget\");\n\t\tconst background = this.get(\"background\");\n\t\tlet fill: Color | undefined;\n\t\tlet stroke: Color | undefined;\n\n\n\t\tif (tooltipTarget && background) {\n\n\t\t\tfill = tooltipTarget.get(\"fill\" as any);\n\t\t\tstroke = tooltipTarget.get(\"stroke\" as any);\n\n\t\t\tif (fill == null) {\n\t\t\t\tfill = stroke;\n\t\t\t}\n\n\t\t\tif (this.get(\"getFillFromSprite\")) {\n\n\t\t\t\tif (this._fillDp) {\n\t\t\t\t\tthis._fillDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tbackground.set(\"fill\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._fillDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tbackground.set(\"fill\", fill as any);\n\t\t\t\t\t\tthis._updateTextColor(fill);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tthis._disposers.push(this._fillDp);\n\t\t\t}\n\n\t\t\tif (this.get(\"getStrokeFromSprite\")) {\n\n\t\t\t\tif (this._strokeDp) {\n\t\t\t\t\tthis._strokeDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tbackground.set(\"stroke\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._strokeDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tbackground.set(\"stroke\", fill as any);\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tthis._disposers.push(this._strokeDp);\n\t\t\t}\n\n\t\t\tif (this.get(\"getLabelFillFromSprite\")) {\n\n\t\t\t\tif (this._labelDp) {\n\t\t\t\t\tthis._labelDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tthis.label.set(\"fill\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._labelDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tthis.label.set(\"fill\", fill as any);\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tthis._disposers.push(this._labelDp);\n\t\t\t}\n\t\t}\n\n\t\tthis._updateTextColor(fill);\n\t}\n\n\n\tprotected _updateTextColor(fill?: Color | Pattern) {\n\t\tif (this.get(\"autoTextColor\")) {\n\t\t\tif (fill == null) {\n\t\t\t\tfill = this.get(\"background\")!.get(\"fill\") as Color;\n\t\t\t}\n\n\t\t\tif (fill == null) {\n\t\t\t\tfill = this._root.interfaceColors.get(\"background\");\n\t\t\t}\n\n\t\t\tif (fill instanceof Color) {\n\t\t\t\tthis.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _setDataItem(dataItem?: DataItem<IComponentDataItem>): void {\n\t\tsuper._setDataItem(dataItem);\n\t\tthis.label._setDataItem(dataItem);\n\t}\n\n\n\tprotected _updateBackground() {\n\t\tsuper.updateBackground();\n\t\tconst parent = this._root.container;\n\n\t\tif (parent) {\n\n\t\t\tlet cw = 0.5;\n\t\t\tlet ch = 0.5;\n\n\t\t\tlet centerX = this.get(\"centerX\");\n\t\t\tif (centerX instanceof Percent) {\n\t\t\t\tcw = centerX.value;\n\t\t\t}\n\n\t\t\tlet centerY = this.get(\"centerY\");\n\t\t\tif (centerY instanceof Percent) {\n\t\t\t\tch = centerY.value;\n\t\t\t}\n\n\t\t\tlet parentW = parent.width();\n\t\t\tlet parentH = parent.height();\n\n\t\t\tlet tooltipContainer = this.parent;\n\t\t\tlet xx = 0;\n\t\t\tlet yy = 0;\n\t\t\tif (tooltipContainer) {\n\t\t\t\txx = tooltipContainer.x();\n\t\t\t\tyy = tooltipContainer.y();\n\n\t\t\t\tconst layerMargin = tooltipContainer.get(\"layerMargin\");\n\t\t\t\tif (layerMargin) {\n\t\t\t\t\txx += layerMargin.left || 0;\n\t\t\t\t\tyy += layerMargin.top || 0;\n\t\t\t\t\tparentW += (layerMargin.left || 0) + (layerMargin.right || 0);\n\t\t\t\t\tparentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bounds = this.get(\"bounds\", { left: -xx, top: -yy, right: parentW - xx, bottom: parentH - yy });\n\n\t\t\tthis._updateBounds();\n\n\t\t\tlet w = this.width();\n\t\t\tlet h = this.height();\n\n\t\t\t// use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n\t\t\tif (w === 0) {\n\t\t\t\tw = this._w;\n\t\t\t}\n\n\t\t\tif (h === 0) {\n\t\t\t\th = this._h;\n\t\t\t}\n\n\t\t\tlet pointTo = this.get(\"pointTo\", { x: parentW / 2, y: parentH / 2 });\n\t\t\tlet x = pointTo.x;\n\t\t\tlet y = pointTo.y;\n\n\t\t\tlet pointerOrientation = this.get(\"pointerOrientation\");\n\n\t\t\tlet background = this.get(\"background\");\n\t\t\tlet pointerLength = 0;\n\t\t\tlet bgStrokeSizeY = 0;\n\t\t\tlet bgStrokeSizeX = 0;\n\n\t\t\tif (background instanceof PointedRectangle) {\n\t\t\t\tpointerLength = background.get(\"pointerLength\", 0);\n\t\t\t\tbgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n\t\t\t\tbgStrokeSizeX = bgStrokeSizeY;\n\t\t\t\tbackground.set(\"width\", w);\n\t\t\t\tbackground.set(\"height\", h);\n\t\t\t}\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerY = 0;\n\n\t\t\tlet boundsW = bounds.right - bounds.left;\n\t\t\tlet boundsH = bounds.bottom - bounds.top;\n\n\n\t\t\t// horizontal\n\t\t\tif (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n\t\t\t\tbgStrokeSizeY = 0;\n\t\t\t\tif (pointerOrientation == \"horizontal\") {\n\t\t\t\t\tif (x > bounds.left + boundsW / 2) {\n\t\t\t\t\t\tx -= (w * (1 - cw) + pointerLength);\n\t\t\t\t\t\tbgStrokeSizeX *= -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx += (w * cw + pointerLength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pointerOrientation == \"left\") {\n\t\t\t\t\tx += (w * (1 - cw) + pointerLength);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx -= (w * cw + pointerLength);\n\t\t\t\t\tbgStrokeSizeX *= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// vertical pointer\n\t\t\telse {\n\t\t\t\tbgStrokeSizeX = 0;\n\t\t\t\tif (pointerOrientation == \"vertical\") {\n\t\t\t\t\tif (y > bounds.top + h / 2 + pointerLength) {\n\t\t\t\t\t\ty -= (h * (1 - ch) + pointerLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ty += (h * ch + pointerLength);\n\t\t\t\t\t\tbgStrokeSizeY *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pointerOrientation == \"down\") {\n\t\t\t\t\ty -= (h * (1 - ch) + pointerLength);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ty += (h * ch + pointerLength);\n\t\t\t\t\tbgStrokeSizeY *= -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n\t\t\ty = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n\n\t\t\tpointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n\t\t\tpointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n\n\t\t\tthis._fx = x;\n\t\t\tthis._fy = y;\n\n\t\t\tconst animationDuration = this.get(\"animationDuration\", 0);\n\n\t\t\tif (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n\t\t\t\tconst animationEasing = this.get(\"animationEasing\");\n\t\t\t\tthis.animate({ key: \"x\", to: x, duration: animationDuration, easing: animationEasing });\n\t\t\t\tthis.animate({ key: \"y\", to: y, duration: animationDuration, easing: animationEasing });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.set(\"x\", x);\n\t\t\t\tthis.set(\"y\", y);\n\t\t\t}\n\n\t\t\tif (background instanceof PointedRectangle) {\n\t\t\t\tbackground.set(\"pointerX\", pointerX);\n\t\t\t\tbackground.set(\"pointerY\", pointerY);\n\t\t\t}\n\n\t\t\tif (w > 0) {\n\t\t\t\tthis._w = w;\n\t\t\t}\n\t\t\tif (h > 0) {\n\t\t\t\tthis._h = h;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}