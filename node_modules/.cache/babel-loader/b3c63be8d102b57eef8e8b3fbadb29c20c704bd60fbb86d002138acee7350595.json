{"ast":null,"code":"import { PicturePattern } from \"../render/patterns/PicturePattern\";\nimport { Sprite } from \"./Sprite\";\nimport { BlendMode } from \"./backend/Renderer\";\nimport * as $type from \"../util/Type\";\nimport * as $array from \"../util/Array\";\nexport const visualSettings = [\"fill\", \"fillOpacity\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"fillPattern\", \"strokePattern\", \"fillGradient\", \"strokeGradient\", \"strokeDasharray\", \"strokeDashoffset\"];\n/**\r\n * Base class used for drawing shapes.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nexport class Graphics extends Sprite {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"_display\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeGraphics()\n    });\n    Object.defineProperty(this, \"_clear\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty(\"draw\") || this.isDirty(\"svgPath\")) {\n      this.markDirtyBounds();\n    }\n    if (this.isDirty(\"fill\") || this.isDirty(\"stroke\") || this.isDirty(\"visible\") || this.isDirty(\"forceHidden\") || this.isDirty(\"scale\") || this.isDirty(\"fillGradient\") || this.isDirty(\"strokeGradient\") || this.isDirty(\"fillPattern\") || this.isDirty(\"strokePattern\") || this.isDirty(\"fillOpacity\") || this.isDirty(\"strokeOpacity\") || this.isDirty(\"strokeWidth\") || this.isDirty(\"draw\") || this.isDirty(\"blendMode\") || this.isDirty(\"strokeDasharray\") || this.isDirty(\"strokeDashoffset\") || this.isDirty(\"svgPath\") || this.isDirty(\"lineJoin\") || this.isDirty(\"shadowColor\") || this.isDirty(\"shadowBlur\") || this.isDirty(\"shadowOffsetX\") || this.isDirty(\"shadowOffsetY\")) {\n      this._clear = true;\n    }\n    this._display.crisp = this.get(\"crisp\", false);\n    if (this.isDirty(\"fillGradient\")) {\n      const gradient = this.get(\"fillGradient\");\n      if (gradient) {\n        this._display.isMeasured = true;\n        const gradientTarget = gradient.get(\"target\");\n        if (gradientTarget) {\n          this._disposers.push(gradientTarget.events.on(\"boundschanged\", () => {\n            this._markDirtyKey(\"fill\");\n          }));\n          this._disposers.push(gradientTarget.events.on(\"positionchanged\", () => {\n            this._markDirtyKey(\"fill\");\n          }));\n        }\n      }\n    }\n    if (this.isDirty(\"strokeGradient\")) {\n      const gradient = this.get(\"strokeGradient\");\n      if (gradient) {\n        this._display.isMeasured = true;\n        const gradientTarget = gradient.get(\"target\");\n        if (gradientTarget) {\n          this._disposers.push(gradientTarget.events.on(\"boundschanged\", () => {\n            this._markDirtyKey(\"stroke\");\n          }));\n          this._disposers.push(gradientTarget.events.on(\"positionchanged\", () => {\n            this._markDirtyKey(\"stroke\");\n          }));\n        }\n      }\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      this.markDirtyBounds();\n      this.markDirtyLayer();\n      this._display.clear();\n      let strokeDasharray = this.get(\"strokeDasharray\");\n      if ($type.isNumber(strokeDasharray)) {\n        if (strokeDasharray < 0.5) {\n          strokeDasharray = [0];\n        } else {\n          strokeDasharray = [strokeDasharray];\n        }\n      }\n      this._display.setLineDash(strokeDasharray);\n      const strokeDashoffset = this.get(\"strokeDashoffset\");\n      if (strokeDashoffset) {\n        this._display.setLineDashOffset(strokeDashoffset);\n      }\n      const blendMode = this.get(\"blendMode\", BlendMode.NORMAL);\n      this._display.blendMode = blendMode;\n      const draw = this.get(\"draw\");\n      if (draw) {\n        draw(this._display, this);\n      }\n      const svgPath = this.get(\"svgPath\");\n      if (svgPath != null) {\n        this._display.svgPath(svgPath);\n      }\n    }\n  }\n  _afterChanged() {\n    super._afterChanged();\n    if (this._clear) {\n      const fill = this.get(\"fill\");\n      const fillGradient = this.get(\"fillGradient\");\n      const fillPattern = this.get(\"fillPattern\");\n      const fillOpacity = this.get(\"fillOpacity\");\n      const stroke = this.get(\"stroke\");\n      const strokeGradient = this.get(\"strokeGradient\");\n      const strokePattern = this.get(\"strokePattern\");\n      const shadowColor = this.get(\"shadowColor\");\n      const shadowBlur = this.get(\"shadowBlur\");\n      const shadowOffsetX = this.get(\"shadowOffsetX\");\n      const shadowOffsetY = this.get(\"shadowOffsetY\");\n      const shadowOpacity = this.get(\"shadowOpacity\");\n      //const bounds = this._display.getLocalBounds();\n      if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n        this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n      }\n      if (fillPattern) {\n        let changed = false;\n        if (fill && (!fillPattern.get(\"fill\") || fillPattern.get(\"fillInherited\"))) {\n          fillPattern.set(\"fill\", fill);\n          fillPattern.set(\"fillInherited\", true);\n          changed = true;\n        }\n        if (stroke && (!fillPattern.get(\"color\") || fillPattern.get(\"colorInherited\"))) {\n          fillPattern.set(\"color\", stroke);\n          fillPattern.set(\"colorInherited\", true);\n          changed = true;\n        }\n        if (changed) {\n          // @todo: is this OK?\n          fillPattern._changed();\n        }\n        const pattern = fillPattern.pattern;\n        if (pattern) {\n          this._display.beginFill(pattern, fillOpacity);\n          this._display.endFill();\n          if (fillPattern instanceof PicturePattern) {\n            fillPattern.events.once(\"loaded\", () => {\n              this._clear = true;\n              this.markDirty();\n            });\n          }\n        }\n      } else if (fillGradient) {\n        if (fill) {\n          const stops = fillGradient.get(\"stops\", []);\n          if (stops.length) {\n            $array.each(stops, stop => {\n              if ((!stop.color || stop.colorInherited) && fill) {\n                stop.color = fill;\n                stop.colorInherited = true;\n              }\n              if (stop.opacity == null || stop.opacityInherited) {\n                stop.opacity = fillOpacity;\n                stop.opacityInherited = true;\n              }\n            });\n          }\n        }\n        const gradient = fillGradient.getFill(this);\n        if (gradient) {\n          this._display.beginFill(gradient, fillOpacity);\n          this._display.endFill();\n        }\n      } else if (fill) {\n        this._display.beginFill(fill, fillOpacity);\n        this._display.endFill();\n      }\n      if (stroke || strokeGradient || strokePattern) {\n        const strokeOpacity = this.get(\"strokeOpacity\");\n        let strokeWidth = this.get(\"strokeWidth\", 1);\n        if (this.get(\"nonScalingStroke\")) {\n          strokeWidth = strokeWidth / this.get(\"scale\", 1);\n        }\n        if (this.get(\"crisp\")) {\n          strokeWidth /= this._root._renderer.resolution;\n        }\n        const lineJoin = this.get(\"lineJoin\");\n        if (strokePattern) {\n          let changed = false;\n          if (stroke && (!strokePattern.get(\"color\") || strokePattern.get(\"colorInherited\"))) {\n            strokePattern.set(\"color\", stroke);\n            strokePattern.set(\"colorInherited\", true);\n            changed = true;\n          }\n          if (changed) {\n            // @todo: is this OK?\n            strokePattern._changed();\n          }\n          const pattern = strokePattern.pattern;\n          if (pattern) {\n            this._display.lineStyle(strokeWidth, pattern, strokeOpacity, lineJoin);\n            this._display.endStroke();\n            if (strokePattern instanceof PicturePattern) {\n              strokePattern.events.once(\"loaded\", () => {\n                this._clear = true;\n                this.markDirty();\n              });\n            }\n          }\n        } else if (strokeGradient) {\n          const stops = strokeGradient.get(\"stops\", []);\n          if (stops.length) {\n            $array.each(stops, stop => {\n              if ((!stop.color || stop.colorInherited) && stroke) {\n                stop.color = stroke;\n                stop.colorInherited = true;\n              }\n              if (stop.opacity == null || stop.opacityInherited) {\n                stop.opacity = strokeOpacity;\n                stop.opacityInherited = true;\n              }\n            });\n          }\n          const gradient = strokeGradient.getFill(this);\n          if (gradient) {\n            this._display.lineStyle(strokeWidth, gradient, strokeOpacity, lineJoin);\n            this._display.endStroke();\n          }\n        } else if (stroke) {\n          this._display.lineStyle(strokeWidth, stroke, strokeOpacity, lineJoin);\n          this._display.endStroke();\n        }\n      }\n      if (this.getPrivate(\"showingTooltip\")) {\n        this.showTooltip();\n      }\n    }\n    this._clear = false;\n  }\n}\nObject.defineProperty(Graphics, \"className\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"Graphics\"\n});\nObject.defineProperty(Graphics, \"classNames\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Sprite.classNames.concat([Graphics.className])\n});","map":{"version":3,"names":["PicturePattern","Sprite","BlendMode","$type","$array","visualSettings","Graphics","constructor","Object","defineProperty","_root","_renderer","makeGraphics","_beforeChanged","isDirty","markDirtyBounds","_clear","_display","crisp","get","gradient","isMeasured","gradientTarget","_disposers","push","events","on","_markDirtyKey","_changed","markDirtyLayer","clear","strokeDasharray","isNumber","setLineDash","strokeDashoffset","setLineDashOffset","blendMode","NORMAL","draw","svgPath","_afterChanged","fill","fillGradient","fillPattern","fillOpacity","stroke","strokeGradient","strokePattern","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","shadowOpacity","shadow","changed","set","pattern","beginFill","endFill","once","markDirty","stops","length","each","stop","color","colorInherited","opacity","opacityInherited","getFill","strokeOpacity","strokeWidth","resolution","lineJoin","lineStyle","endStroke","getPrivate","showTooltip","classNames","concat","className"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\render\\Graphics.ts"],"sourcesContent":["import type { Color } from \"../util/Color\";\nimport type { Pattern } from \"../render/patterns/Pattern\";\nimport type { Gradient } from \"../render/gradients/Gradient\";\n\nimport { PicturePattern } from \"../render/patterns/PicturePattern\";\nimport { ISpriteSettings, ISpritePrivate, ISpriteEvents, Sprite } from \"./Sprite\";\nimport { IGraphics, BlendMode } from \"./backend/Renderer\";\n\nimport * as $type from \"../util/Type\";\nimport * as $array from \"../util/Array\";\n\n\nexport const visualSettings = [\"fill\", \"fillOpacity\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"fillPattern\", \"strokePattern\", \"fillGradient\", \"strokeGradient\", \"strokeDasharray\", \"strokeDashoffset\"];\n\nexport interface IGraphicsSettings extends ISpriteSettings {\n\n\t/**\n\t * Fill color.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more information\n\t */\n\tfill?: Color;\n\n\t/**\n\t * Stroke (border or line) color.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more information\n\t */\n\tstroke?: Color;\n\n\t/**\n\t * Fill pattern.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more information\n\t */\n\tfillPattern?: Pattern;\n\n\t/**\n\t * Stroke (border or line) pattern.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more information\n\t */\n\tstrokePattern?: Pattern;\n\n\t/**\n\t * Fill gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more information\n\t */\n\tfillGradient?: Gradient;\n\n\t/**\n\t * Stroke (border or line) gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more information\n\t */\n\tstrokeGradient?: Gradient;\n\n\t/**\n\t * Stroke (border or line) dash settings.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Dashed_lines} for more information\n\t */\n\tstrokeDasharray?: number[] | number;\n\n\t/**\n\t * Stroke (border or line) dash offset.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Dashed_lines} for more information\n\t */\n\tstrokeDashoffset?: number;\n\n\t/**\n\t * Opacity of the fill. 0 - fully transparent; 1 - fully opaque.\n\t */\n\tfillOpacity?: number;\n\n\t/**\n\t * Opacity of the stroke (border or line). 0 - fully transparent; 1 - fully opaque.\n\t */\n\tstrokeOpacity?: number;\n\n\t/**\n\t * Width of the stroke (border or line) in pixels.\n\t */\n\tstrokeWidth?: number;\n\n\t/**\n\t * Indicates if stroke of a Graphics should stay the same when it's scale changes. Note, this doesn't take into account parent container scale changes.\n\t * @default false\n\t */\n\tnonScalingStroke?: boolean;\n\n\t/**\n\t * Drawing function.\n\t *\n\t * Must use renderer (`display` parameter) methods to draw.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/#Custom_draw_functions} for more info\n\t */\n\tdraw?: (display: IGraphics, graphics: Graphics) => void;\n\n\t/**\n\t * Rendering mode.\n\t *\n\t * @default BlendMode.NORMAL (\"source-over\")\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation} for more information\n\t * @ignore\n\t */\n\tblendMode?: BlendMode;\n\n\t/**\n\t * Draw a shape using an SVG path.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n\t/**\n\t * Color of the element's shadow.\n\t *\n\t * For this to work at least one of the following needs to be set as well:\n\t * `shadowBlur`, `shadowOffsetX`, `shadowOffsetY`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowColor?: Color | null;\n\n\t/**\n\t * Blurriness of the the shadow.\n\t *\n\t * The bigger the number, the more blurry shadow will be.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowBlur?: number;\n\n\t/**\n\t * Horizontal shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetX?: number;\n\n\t/**\n\t * Vertical shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetY?: number;\n\n\t/**\n\t * Opacity of the shadow (0-1).\n\t *\n\t * If not set, will use the same as `fillOpacity` of the element.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOpacity?: number;\n\n\t/**\n\t * A method to be used on anchor points (joints) of the multi-point line.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin} for more info\n\t * @default \"miter\"\n\t * @since 5.2.10\n\t */\n\tlineJoin?: \"miter\" | \"round\" | \"bevel\";\n}\n\nexport interface IGraphicsPrivate extends ISpritePrivate {\n}\n\nexport interface IGraphicsEvents extends ISpriteEvents {\n}\n\n/**\n * Base class used for drawing shapes.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\n * @important\n */\nexport class Graphics extends Sprite {\n\n\tdeclare public _settings: IGraphicsSettings;\n\tdeclare public _privateSettings: IGraphicsPrivate;\n\tdeclare public _events: IGraphicsEvents;\n\n\tpublic _display: IGraphics = this._root._renderer.makeGraphics();\n\n\tprotected _clear = false;\n\n\tpublic static className: string = \"Graphics\";\n\tpublic static classNames: Array<string> = Sprite.classNames.concat([Graphics.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"draw\") || this.isDirty(\"svgPath\")) {\n\t\t\tthis.markDirtyBounds();\n\t\t}\n\n\t\tif (this.isDirty(\"fill\") || this.isDirty(\"stroke\") || this.isDirty(\"visible\") || this.isDirty(\"forceHidden\") || this.isDirty(\"scale\") || this.isDirty(\"fillGradient\") || this.isDirty(\"strokeGradient\") || this.isDirty(\"fillPattern\") || this.isDirty(\"strokePattern\") || this.isDirty(\"fillOpacity\") || this.isDirty(\"strokeOpacity\") || this.isDirty(\"strokeWidth\") || this.isDirty(\"draw\") || this.isDirty(\"blendMode\") || this.isDirty(\"strokeDasharray\") || this.isDirty(\"strokeDashoffset\") || this.isDirty(\"svgPath\") || this.isDirty(\"lineJoin\") || this.isDirty(\"shadowColor\") || this.isDirty(\"shadowBlur\") || this.isDirty(\"shadowOffsetX\") || this.isDirty(\"shadowOffsetY\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\n\t\tthis._display.crisp = this.get(\"crisp\", false);\n\n\t\tif (this.isDirty(\"fillGradient\")) {\n\t\t\tconst gradient = this.get(\"fillGradient\");\n\t\t\tif (gradient) {\n\t\t\t\tthis._display.isMeasured = true;\n\t\t\t\tconst gradientTarget = gradient.get(\"target\");\n\t\t\t\tif (gradientTarget) {\n\t\t\t\t\tthis._disposers.push(gradientTarget.events.on(\"boundschanged\", () => {\n\t\t\t\t\t\tthis._markDirtyKey(\"fill\");\n\t\t\t\t\t}))\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"positionchanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"fill\");\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"strokeGradient\")) {\n\t\t\tconst gradient = this.get(\"strokeGradient\");\n\t\t\tif (gradient) {\n\t\t\t\tthis._display.isMeasured = true;\n\t\t\t\tconst gradientTarget = gradient.get(\"target\");\n\t\t\t\tif (gradientTarget) {\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"boundschanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"stroke\");\n\t\t\t\t\t\t}))\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"positionchanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"stroke\");\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this._clear) {\n\t\t\tthis.markDirtyBounds();\n\t\t\tthis.markDirtyLayer();\n\t\t\tthis._display.clear();\n\n\t\t\tlet strokeDasharray = this.get(\"strokeDasharray\");\n\t\t\tif ($type.isNumber(strokeDasharray)) {\n\t\t\t\tif (strokeDasharray < 0.5) {\n\t\t\t\t\tstrokeDasharray = [0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstrokeDasharray = [strokeDasharray]\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._display.setLineDash(strokeDasharray as number[]);\n\n\t\t\tconst strokeDashoffset = this.get(\"strokeDashoffset\");\n\t\t\tif (strokeDashoffset) {\n\t\t\t\tthis._display.setLineDashOffset(strokeDashoffset);\n\t\t\t}\n\n\t\t\tconst blendMode = this.get(\"blendMode\", BlendMode.NORMAL);\n\t\t\tthis._display.blendMode = blendMode;\n\n\t\t\tconst draw = this.get(\"draw\");\n\t\t\tif (draw) {\n\t\t\t\tdraw(this._display, this);\n\t\t\t}\n\n\t\t\tconst svgPath = this.get(\"svgPath\");\n\t\t\tif (svgPath != null) {\n\t\t\t\tthis._display.svgPath(svgPath!);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _afterChanged() {\n\t\tsuper._afterChanged();\n\n\t\tif (this._clear) {\n\t\t\tconst fill = this.get(\"fill\");\n\t\t\tconst fillGradient = this.get(\"fillGradient\");\n\t\t\tconst fillPattern = this.get(\"fillPattern\");\n\t\t\tconst fillOpacity = this.get(\"fillOpacity\");\n\n\t\t\tconst stroke = this.get(\"stroke\");\n\t\t\tconst strokeGradient = this.get(\"strokeGradient\");\n\t\t\tconst strokePattern = this.get(\"strokePattern\");\n\n\t\t\tconst shadowColor = this.get(\"shadowColor\");\n\t\t\tconst shadowBlur = this.get(\"shadowBlur\");\n\t\t\tconst shadowOffsetX = this.get(\"shadowOffsetX\");\n\t\t\tconst shadowOffsetY = this.get(\"shadowOffsetY\");\n\t\t\tconst shadowOpacity = this.get(\"shadowOpacity\");\n\n\t\t\t//const bounds = this._display.getLocalBounds();\n\n\t\t\tif (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n\t\t\t\tthis._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n\t\t\t}\n\n\t\t\tif (fillPattern) {\n\t\t\t\tlet changed = false;\n\t\t\t\tif (fill && (!fillPattern.get(\"fill\") || fillPattern.get(\"fillInherited\"))) {\n\t\t\t\t\tfillPattern.set(\"fill\", fill);\n\t\t\t\t\tfillPattern.set(\"fillInherited\", true)\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (stroke && (!fillPattern.get(\"color\") || fillPattern.get(\"colorInherited\"))) {\n\t\t\t\t\tfillPattern.set(\"color\", stroke);\n\t\t\t\t\tfillPattern.set(\"colorInherited\", true)\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (changed) {\n\t\t\t\t\t// @todo: is this OK?\n\t\t\t\t\tfillPattern._changed();\n\t\t\t\t}\n\t\t\t\tconst pattern = fillPattern.pattern;\n\t\t\t\tif (pattern) {\n\t\t\t\t\tthis._display.beginFill(pattern, fillOpacity);\n\t\t\t\t\tthis._display.endFill();\n\n\t\t\t\t\tif (fillPattern instanceof PicturePattern) {\n\t\t\t\t\t\tfillPattern.events.once(\"loaded\", () => {\n\t\t\t\t\t\t\tthis._clear = true;\n\t\t\t\t\t\t\tthis.markDirty();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fillGradient) {\n\t\t\t\tif (fill) {\n\t\t\t\t\tconst stops = fillGradient.get(\"stops\", []);\n\t\t\t\t\tif (stops.length) {\n\t\t\t\t\t\t$array.each(stops, (stop: any) => {\n\t\t\t\t\t\t\tif ((!stop.color || stop.colorInherited) && fill) {\n\t\t\t\t\t\t\t\tstop.color = fill;\n\t\t\t\t\t\t\t\tstop.colorInherited = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stop.opacity == null || stop.opacityInherited) {\n\t\t\t\t\t\t\t\tstop.opacity = fillOpacity;\n\t\t\t\t\t\t\t\tstop.opacityInherited = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst gradient = fillGradient.getFill(this);\n\t\t\t\tif (gradient) {\n\t\t\t\t\tthis._display.beginFill(gradient, fillOpacity);\n\t\t\t\t\tthis._display.endFill();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fill) {\n\t\t\t\tthis._display.beginFill(fill, fillOpacity);\n\t\t\t\tthis._display.endFill();\n\t\t\t}\n\n\t\t\tif (stroke || strokeGradient || strokePattern) {\n\t\t\t\tconst strokeOpacity = this.get(\"strokeOpacity\");\n\t\t\t\tlet strokeWidth = this.get(\"strokeWidth\", 1);\n\n\t\t\t\tif (this.get(\"nonScalingStroke\")) {\n\t\t\t\t\tstrokeWidth = strokeWidth / this.get(\"scale\", 1)\n\t\t\t\t}\n\n\t\t\t\tif(this.get(\"crisp\")){\n\t\t\t\t\tstrokeWidth /= this._root._renderer.resolution;\n\t\t\t\t}\n\n\t\t\t\tconst lineJoin = this.get(\"lineJoin\");\n\n\t\t\t\tif (strokePattern) {\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tif (stroke && (!strokePattern.get(\"color\") || strokePattern.get(\"colorInherited\"))) {\n\t\t\t\t\t\tstrokePattern.set(\"color\", stroke);\n\t\t\t\t\t\tstrokePattern.set(\"colorInherited\", true);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// @todo: is this OK?\n\t\t\t\t\t\tstrokePattern._changed();\n\t\t\t\t\t}\n\t\t\t\t\tconst pattern = strokePattern.pattern;\n\t\t\t\t\tif (pattern) {\n\t\t\t\t\t\tthis._display.lineStyle(strokeWidth, pattern, strokeOpacity, lineJoin);\n\t\t\t\t\t\tthis._display.endStroke();\n\n\t\t\t\t\t\tif (strokePattern instanceof PicturePattern) {\n\t\t\t\t\t\t\tstrokePattern.events.once(\"loaded\", () => {\n\t\t\t\t\t\t\t\tthis._clear = true;\n\t\t\t\t\t\t\t\tthis.markDirty();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strokeGradient) {\n\n\t\t\t\t\tconst stops = strokeGradient.get(\"stops\", []);\n\t\t\t\t\tif (stops.length) {\n\t\t\t\t\t\t$array.each(stops, (stop: any) => {\n\t\t\t\t\t\t\tif ((!stop.color || stop.colorInherited) && stroke) {\n\t\t\t\t\t\t\t\tstop.color = stroke;\n\t\t\t\t\t\t\t\tstop.colorInherited = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stop.opacity == null || stop.opacityInherited) {\n\t\t\t\t\t\t\t\tstop.opacity = strokeOpacity;\n\t\t\t\t\t\t\t\tstop.opacityInherited = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tconst gradient = strokeGradient.getFill(this);\n\t\t\t\t\tif (gradient) {\n\t\t\t\t\t\tthis._display.lineStyle(strokeWidth, gradient, strokeOpacity, lineJoin);\n\t\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (stroke) {\n\t\t\t\t\tthis._display.lineStyle(strokeWidth, stroke, strokeOpacity, lineJoin);\n\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.getPrivate(\"showingTooltip\")){\n\t\t\t\tthis.showTooltip();\n\t\t\t}\n\t\t}\n\n\t\tthis._clear = false;\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}