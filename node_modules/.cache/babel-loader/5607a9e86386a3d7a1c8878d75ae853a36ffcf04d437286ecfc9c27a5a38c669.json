{"ast":null,"code":"import { Entity } from \"./Entity\";\nimport { TextFormatter } from \"./TextFormatter\";\nimport * as $object from \"./Object\";\nimport * as $utils from \"./Utils\";\nimport * as $type from \"./Type\";\n/**\r\n * Number formatter\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\r\n * @important\r\n */\nexport class NumberFormatter extends Entity {\n  _setDefaults() {\n    // Defaults\n    this._setDefault(\"negativeBase\", 0);\n    this._setDefault(\"numberFormat\", \"#,###.#####\");\n    this._setDefault(\"smallNumberThreshold\", 1.00);\n    const bns = \"_big_number_suffix_\";\n    const sns = \"_small_number_suffix_\";\n    const bs = \"_byte_suffix_\";\n    this._setDefault(\"bigNumberPrefixes\", [{\n      \"number\": 1e+3,\n      \"suffix\": this._t(bns + \"3\")\n    }, {\n      \"number\": 1e+6,\n      \"suffix\": this._t(bns + \"6\")\n    }, {\n      \"number\": 1e+9,\n      \"suffix\": this._t(bns + \"9\")\n    }, {\n      \"number\": 1e+12,\n      \"suffix\": this._t(bns + \"12\")\n    }, {\n      \"number\": 1e+15,\n      \"suffix\": this._t(bns + \"15\")\n    }, {\n      \"number\": 1e+18,\n      \"suffix\": this._t(bns + \"18\")\n    }, {\n      \"number\": 1e+21,\n      \"suffix\": this._t(bns + \"21\")\n    }, {\n      \"number\": 1e+24,\n      \"suffix\": this._t(bns + \"24\")\n    }]);\n    this._setDefault(\"smallNumberPrefixes\", [{\n      \"number\": 1e-24,\n      \"suffix\": this._t(sns + \"24\")\n    }, {\n      \"number\": 1e-21,\n      \"suffix\": this._t(sns + \"21\")\n    }, {\n      \"number\": 1e-18,\n      \"suffix\": this._t(sns + \"18\")\n    }, {\n      \"number\": 1e-15,\n      \"suffix\": this._t(sns + \"15\")\n    }, {\n      \"number\": 1e-12,\n      \"suffix\": this._t(sns + \"12\")\n    }, {\n      \"number\": 1e-9,\n      \"suffix\": this._t(sns + \"9\")\n    }, {\n      \"number\": 1e-6,\n      \"suffix\": this._t(sns + \"6\")\n    }, {\n      \"number\": 1e-3,\n      \"suffix\": this._t(sns + \"3\")\n    }]);\n    this._setDefault(\"bytePrefixes\", [{\n      \"number\": 1,\n      suffix: this._t(bs + \"B\")\n    }, {\n      \"number\": 1024,\n      suffix: this._t(bs + \"KB\")\n    }, {\n      \"number\": 1048576,\n      suffix: this._t(bs + \"MB\")\n    }, {\n      \"number\": 1073741824,\n      suffix: this._t(bs + \"GB\")\n    }, {\n      \"number\": 1099511627776,\n      suffix: this._t(bs + \"TB\")\n    }, {\n      \"number\": 1125899906842624,\n      suffix: this._t(bs + \"PB\")\n    }]);\n    super._setDefaults();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n  }\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n  format(value, format, precision) {\n    // no format passed in or \"Number\"\n    if (format == null || $type.isString(format) && format.toLowerCase() === \"number\") {\n      format = this.get(\"numberFormat\", \"\");\n    }\n    // Init return value\n    let formatted;\n    // Cast to number just in case\n    // TODO: maybe use better casting\n    let source = Number(value);\n    // Is it a built-in format or Intl.NumberFormatOptions\n    if ($type.isObject(format)) {\n      try {\n        if (this.get(\"intlLocales\")) {\n          return new Intl.NumberFormat(this.get(\"intlLocales\"), format).format(source);\n        } else {\n          return new Intl.NumberFormat(undefined, format).format(source);\n        }\n      } catch (e) {\n        return \"Invalid\";\n      }\n    } else {\n      // Clean format\n      format = $utils.cleanFormat(format);\n      // Get format info (it will also deal with parser caching)\n      let info = this.parseFormat(format, this._root.language);\n      // format and replace the number\n      let details;\n      if (source > this.get(\"negativeBase\")) {\n        details = info.positive;\n      } else if (source < this.get(\"negativeBase\")) {\n        details = info.negative;\n      } else {\n        details = info.zero;\n      }\n      // Adjust precision\n      if (precision != null && !details.mod) {\n        details = $object.copy(details);\n        details.decimals.active = source == 0 ? 0 : precision;\n      }\n      // Format\n      formatted = details.template.split($type.PLACEHOLDER).join(this.applyFormat(source, details));\n    }\n    return formatted;\n  }\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. \"#,###.00\"\r\n   * @param language Language\r\n   * @ignore\r\n   */\n  parseFormat(format, language) {\n    // Check cache\n    // TODO\n    // let cached = this.getCache(format);\n    // if (cached != null) {\n    // \treturn cached;\n    // }\n    const thousandSeparator = language.translateEmpty(\"_thousandSeparator\");\n    const decimalSeparator = language.translateEmpty(\"_decimalSeparator\");\n    // init format parse info holder\n    let info = {\n      \"positive\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": thousandSeparator\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": decimalSeparator\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"negative\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": thousandSeparator\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": decimalSeparator\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"zero\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": thousandSeparator\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": decimalSeparator\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      }\n    };\n    // Escape double vertical bars (that mean display one vertical bar)\n    format = format.replace(\"||\", $type.PLACEHOLDER2);\n    // Split it up and deal with different formats\n    let parts = format.split(\"|\");\n    info.positive.source = parts[0];\n    if (typeof parts[2] === \"undefined\") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n    if (typeof parts[1] === \"undefined\") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    }\n    // Parse each\n    $object.each(info, (_part, item) => {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      }\n      // Check cached\n      // TODO\n      // if (typeof this.getCache(item.source) !== \"undefined\") {\n      // \tinfo[part] = this.getCache(item.source);\n      // \treturn;\n      // }\n      // Begin parsing\n      let partFormat = item.source;\n      // Just \"Number\"?\n      if (partFormat.toLowerCase() === \"number\") {\n        partFormat = this.get(\"numberFormat\", \"#,###.#####\");\n      }\n      // Let TextFormatter split into chunks\n      let chunks = TextFormatter.chunk(partFormat, true);\n      for (let i = 0; i < chunks.length; i++) {\n        let chunk = chunks[i];\n        // replace back double vertical bar\n        chunk.text = chunk.text.replace($type.PLACEHOLDER2, \"|\");\n        if (chunk.type === \"value\") {\n          // Parse format\n          // Look for codes\n          let matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\n          if (matches) {\n            if (matches === null || matches[0] === \"\") {\n              // no codes here - assume string\n              // nothing to do here\n              item.template += chunk.text;\n            } else {\n              // look for the format modifiers at the end\n              let mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\n              if (mods) {\n                item.mod = mods[0].toLowerCase();\n                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\n              }\n              // break the format up\n              let a = matches[0].split(\".\");\n              // Deal with thousands\n              if (a[0] === \"\") {\n                // No directives for thousands\n                // Leave default settings (no formatting)\n              } else {\n                // Counts\n                item.thousands.active = (a[0].match(/0/g) || []).length;\n                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\n                // Separator interval\n                let b = a[0].split(\",\");\n                if (b.length === 1) {\n                  // No thousands separators\n                  // Do nothing\n                } else {\n                  // Use length fo the last chunk as thousands length\n                  item.thousands.interval = (b.pop() || \"\").length;\n                  if (item.thousands.interval === 0) {\n                    item.thousands.interval = -1;\n                  }\n                }\n              }\n              // Deal with decimals\n              if (typeof a[1] === \"undefined\") {\n                // No directives for decimals\n                // Leave at defaults (no formatting)\n              } else {\n                // Counts\n                item.decimals.active = (a[1].match(/0/g) || []).length;\n                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n              }\n              // Add special code to template\n              item.template += chunk.text.split(matches[0]).join($type.PLACEHOLDER);\n            }\n          }\n        } else {\n          // Quoted string - take it as it is\n          item.template += chunk.text;\n        }\n      }\n      // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n      // TODO\n      //this.setCache(item.source, item);\n      // Mark this as parsed\n      item.parsed = true;\n    });\n    // Save cache (the whole thing)\n    // TODO\n    //this.setCache(format, info);\n    return info;\n  }\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   * @ignore\r\n   */\n  applyFormat(value, details) {\n    // Use absolute values\n    let negative = value < 0;\n    value = Math.abs(value);\n    // Recalculate according to modifier\n    let prefix = \"\",\n      suffix = \"\";\n    let mods = details.mod ? details.mod.split(\"\") : [];\n    if (mods.indexOf(\"b\") !== -1) {\n      let a = this.applyPrefix(value, this.get(\"bytePrefixes\"), mods.indexOf(\"!\") !== -1);\n      value = a[0];\n      prefix = a[1];\n      suffix = a[2];\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"a\") !== -1) {\n      let a = this.applyPrefix(value, value < this.get(\"smallNumberThreshold\") ? this.get(\"smallNumberPrefixes\") : this.get(\"bigNumberPrefixes\"), mods.indexOf(\"!\") !== -1);\n      value = a[0];\n      prefix = a[1];\n      suffix = a[2];\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"p\") !== -1) {\n      let ol = Math.min(value.toString().length + 2, 21);\n      //value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      prefix = this._root.language.translate(\"_percentPrefix\");\n      suffix = this._root.language.translate(\"_percentSuffix\");\n      if (prefix == \"\" && suffix == \"\") {\n        suffix = \"%\";\n      }\n    } else if (mods.indexOf(\"%\") !== -1) {\n      let ol = Math.min(value.toString().length + 2, 21);\n      value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = \"%\";\n    } else if (mods.indexOf(\"‰\") !== -1) {\n      let ol = Math.min(value.toString().length + 3, 21);\n      value *= 1000;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = \"‰\";\n    }\n    // Round to passive\n    if (mods.indexOf(\"e\") !== -1) {\n      // convert the value to exponential\n      let exp;\n      if (details.decimals.passive >= 0) {\n        exp = value.toExponential(details.decimals.passive).split(\"e\");\n      } else {\n        exp = value.toExponential().split(\"e\");\n      }\n      value = Number(exp[0]);\n      suffix = \"e\" + exp[1];\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (details.decimals.passive === 0) {\n      value = Math.round(value);\n    } else if (details.decimals.passive > 0) {\n      let d = Math.pow(10, details.decimals.passive);\n      value = Math.round(value * d) / d;\n    }\n    // Init return value\n    let res = \"\";\n    // Calc integer and decimal parts\n    let a = $type.numberToString(value).split(\".\");\n    // Format integers\n    let ints = a[0];\n    // Pad integers to active length\n    if (ints.length < details.thousands.active) {\n      ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n    }\n    // Insert thousands separators\n    if (details.thousands.interval > 0) {\n      let ip = [];\n      let intsr = ints.split(\"\").reverse().join(\"\");\n      for (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n        let c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n        if (c !== \"\") {\n          ip.unshift(c);\n        }\n      }\n      ints = ip.join(details.thousands.separator);\n    }\n    // Add integers\n    res += ints;\n    // Add decimals\n    if (a.length === 1) {\n      a.push(\"\");\n    }\n    let decs = a[1];\n    // Fill zeros?\n    if (decs.length < details.decimals.active) {\n      decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n    }\n    if (decs !== \"\") {\n      res += details.decimals.separator + decs;\n    }\n    // Can't have empty return value\n    if (res === \"\") {\n      res = \"0\";\n    }\n    // Add minus sign back\n    if (value !== 0 && negative && mods.indexOf(\"s\") === -1) {\n      res = \"-\" + res;\n    }\n    // Add suffixes/prefixes\n    if (prefix) {\n      res = prefix + res;\n    }\n    if (suffix) {\n      res += suffix;\n    }\n    return res;\n  }\n  applyPrefix(value, prefixes) {\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let newvalue = value;\n    let prefix = \"\";\n    let suffix = \"\";\n    let applied = false;\n    let k = 1;\n    for (let i = 0, len = prefixes.length; i < len; i++) {\n      if (prefixes[i].number <= value) {\n        if (prefixes[i].number === 0) {\n          newvalue = 0;\n        } else {\n          newvalue = value / prefixes[i].number;\n          k = prefixes[i].number;\n        }\n        prefix = prefixes[i].prefix;\n        suffix = prefixes[i].suffix;\n        applied = true;\n      }\n    }\n    if (!applied && force && prefixes.length && value != 0) {\n      // Prefix was not applied. Use the first prefix.\n      newvalue = value / prefixes[0].number;\n      prefix = prefixes[0].prefix;\n      suffix = prefixes[0].suffix;\n      applied = true;\n    }\n    if (applied) {\n      newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)));\n    }\n    return [newvalue, prefix, suffix];\n  }\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  escape(text) {\n    return text.replace(\"||\", $type.PLACEHOLDER2);\n  }\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  unescape(text) {\n    return text.replace($type.PLACEHOLDER2, \"|\");\n  }\n}","map":{"version":3,"names":["Entity","TextFormatter","$object","$utils","$type","NumberFormatter","_setDefaults","_setDefault","bns","sns","bs","_t","suffix","_beforeChanged","format","value","precision","isString","toLowerCase","get","formatted","source","Number","isObject","Intl","NumberFormat","undefined","e","cleanFormat","info","parseFormat","_root","language","details","positive","negative","zero","mod","copy","decimals","active","template","split","PLACEHOLDER","join","applyFormat","thousandSeparator","translateEmpty","decimalSeparator","replace","PLACEHOLDER2","parts","each","_part","item","parsed","partFormat","chunks","chunk","i","length","text","type","matches","match","mods","modSpacing","a","thousands","passive","b","interval","pop","Math","abs","prefix","indexOf","applyPrefix","ol","min","toString","parseFloat","toPrecision","translate","exp","toExponential","round","d","pow","res","numberToString","ints","Array","ip","intsr","reverse","len","c","substr","unshift","separator","push","decs","prefixes","force","arguments","newvalue","applied","k","number","floor","escape","unescape"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\util\\NumberFormatter.ts"],"sourcesContent":["import type { Language } from \"./Language\";\n\nimport { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\"\nimport { TextFormatter } from \"./TextFormatter\";\n\nimport * as $object from \"./Object\";\nimport * as $utils from \"./Utils\";\nimport * as $type from \"./Type\";\n\n/**\n * @ignore\n */\nexport interface INumberSuffix {\n\tnumber: number;\n\tsuffix: string;\n}\n\nexport interface INumberFormatterSettings extends IEntitySettings {\n\n\t/**\n\t * Number format to be used when formatting numbers.\n\t *\n\t * @default \"#,###.#####\"\n\t */\n\tnumberFormat?: string | Intl.NumberFormatOptions;\n\n\t/**\n\t * A threshold value for negative numbers.\n\t *\n\t * @default 0\n\t */\n\tnegativeBase?: number;\n\n\t/**\n\t * Prefixes and thresholds to group big numbers into, e.g. 1M.\n\t *\n\t * Used in conjunction with `a` modifier of the number format.\n\t */\n\tbigNumberPrefixes?: INumberSuffix[];\n\n\t/**\n\t * Prefixes and thresholds to group small numbers into, e.g. 1m.\n\t *\n\t * Used in conjunction with `a` modifier of the number format.\n\t */\n\tsmallNumberPrefixes?: INumberSuffix[];\n\n\t/**\n\t * All numbers below this value are considered small.\n\t *\n\t * @default 1\n\t */\n\tsmallNumberThreshold?: number;\n\n\t/**\n\t * Prefixes to and thresholds to use when grouping data size numbers, e.g. 1MB.\n\t *\n\t * Used in conjunction with `b` modifier of the number format.\n\t */\n\tbytePrefixes?: INumberSuffix[];\n\n\t/**\n\t * Indicates which fields in data should be considered numeric.\n\t *\n\t * It is used when formatting data placeholder values.\n\t */\n\tnumericFields?: string[];\n\n\t/**\n\t * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\n\t *\n\t * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\n\t * @param value Locales\n\t */\n\tintlLocales?: string;\n\n}\n\nexport interface INumberFormatterPrivate extends IEntityPrivate {\n}\n\n/**\n * Number formatter\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\n * @important\n */\nexport class NumberFormatter extends Entity {\n\tdeclare public _settings: INumberFormatterSettings;\n\tdeclare public _privateSettings: INumberFormatterPrivate;\n\n\tprotected _setDefaults() {\n\t\t// Defaults\n\t\tthis._setDefault(\"negativeBase\", 0);\n\t\tthis._setDefault(\"numberFormat\", \"#,###.#####\");\n\t\tthis._setDefault(\"smallNumberThreshold\", 1.00);\n\n\t\tconst bns = \"_big_number_suffix_\";\n\t\tconst sns = \"_small_number_suffix_\";\n\t\tconst bs = \"_byte_suffix_\";\n\n\t\tthis._setDefault(\"bigNumberPrefixes\", [\n\t\t\t{ \"number\": 1e+3, \"suffix\": this._t(bns + \"3\") },\n\t\t\t{ \"number\": 1e+6, \"suffix\": this._t(bns + \"6\") },\n\t\t\t{ \"number\": 1e+9, \"suffix\": this._t(bns + \"9\") },\n\t\t\t{ \"number\": 1e+12, \"suffix\": this._t(bns + \"12\") },\n\t\t\t{ \"number\": 1e+15, \"suffix\": this._t(bns + \"15\") },\n\t\t\t{ \"number\": 1e+18, \"suffix\": this._t(bns + \"18\") },\n\t\t\t{ \"number\": 1e+21, \"suffix\": this._t(bns + \"21\") },\n\t\t\t{ \"number\": 1e+24, \"suffix\": this._t(bns + \"24\") }\n\t\t]);\n\n\t\tthis._setDefault(\"smallNumberPrefixes\", [\n\t\t\t{ \"number\": 1e-24, \"suffix\": this._t(sns + \"24\") },\n\t\t\t{ \"number\": 1e-21, \"suffix\": this._t(sns + \"21\") },\n\t\t\t{ \"number\": 1e-18, \"suffix\": this._t(sns + \"18\") },\n\t\t\t{ \"number\": 1e-15, \"suffix\": this._t(sns + \"15\") },\n\t\t\t{ \"number\": 1e-12, \"suffix\": this._t(sns + \"12\") },\n\t\t\t{ \"number\": 1e-9, \"suffix\": this._t(sns + \"9\") },\n\t\t\t{ \"number\": 1e-6, \"suffix\": this._t(sns + \"6\") },\n\t\t\t{ \"number\": 1e-3, \"suffix\": this._t(sns + \"3\") }\n\t\t]);\n\n\t\tthis._setDefault(\"bytePrefixes\", [\n\t\t\t{ \"number\": 1, suffix: this._t(bs + \"B\") },\n\t\t\t{ \"number\": 1024, suffix: this._t(bs + \"KB\") },\n\t\t\t{ \"number\": 1048576, suffix: this._t(bs + \"MB\") },\n\t\t\t{ \"number\": 1073741824, suffix: this._t(bs + \"GB\") },\n\t\t\t{ \"number\": 1099511627776, suffix: this._t(bs + \"TB\") },\n\t\t\t{ \"number\": 1125899906842624, suffix: this._t(bs + \"PB\") }\n\t\t]);\n\n\t\tsuper._setDefaults();\n\t}\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\t}\n\n\t/**\n\t * Formats the number according to specific format.\n\t *\n\t * @param value   Value to format\n\t * @param format  Format to apply\n\t * @return Formatted number\n\t */\n\tpublic format(value: number | string, format?: string | Intl.NumberFormatOptions, precision?: number): string {\n\n\t\t// no format passed in or \"Number\"\n\t\tif (format == null || ($type.isString(format) && format.toLowerCase() === \"number\")) {\n\t\t\tformat = this.get(\"numberFormat\", \"\");\n\t\t}\n\n\t\t// Init return value\n\t\tlet formatted;\n\n\t\t// Cast to number just in case\n\t\t// TODO: maybe use better casting\n\t\tlet source: number = Number(value);\n\n\t\t// Is it a built-in format or Intl.NumberFormatOptions\n\t\tif ($type.isObject(format)) {\n\t\t\ttry {\n\t\t\t\tif (this.get(\"intlLocales\")) {\n\t\t\t\t\treturn new Intl.NumberFormat(this.get(\"intlLocales\"), <Intl.NumberFormatOptions>format).format(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Intl.NumberFormat(undefined, <Intl.NumberFormatOptions>format).format(source);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\treturn \"Invalid\";\n\t\t\t}\n\n\t\t}\n\t\telse {\n\n\t\t\t// Clean format\n\t\t\tformat = $utils.cleanFormat(format!);\n\n\t\t\t// Get format info (it will also deal with parser caching)\n\t\t\tlet info = this.parseFormat(format, this._root.language);\n\n\n\t\t\t// format and replace the number\n\t\t\tlet details;\n\t\t\tif (source > this.get(\"negativeBase\")) {\n\t\t\t\tdetails = info.positive;\n\t\t\t}\n\t\t\telse if (source < this.get(\"negativeBase\")) {\n\t\t\t\tdetails = info.negative;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdetails = info.zero;\n\t\t\t}\n\n\t\t\t// Adjust precision\n\t\t\tif (precision != null && !details.mod) {\n\t\t\t\tdetails = $object.copy(details);\n\t\t\t\tdetails.decimals.active = source == 0 ? 0 : precision;\n\t\t\t}\n\n\t\t\t// Format\n\t\t\tformatted = details.template.split($type.PLACEHOLDER).join(this.applyFormat(source, details));\n\n\t\t}\n\n\t\treturn formatted;\n\t}\n\n\t/**\n\t * Parses supplied format into structured object which can be used to format\n\t * the number.\n\t *\n\t * @param format Format string, i.e. \"#,###.00\"\n\t * @param language Language\n\t * @ignore\n\t */\n\tprotected parseFormat(format: string, language: Language): any {\n\n\t\t// Check cache\n\t\t// TODO\n\t\t// let cached = this.getCache(format);\n\t\t// if (cached != null) {\n\t\t// \treturn cached;\n\t\t// }\n\n\t\tconst thousandSeparator = language.translateEmpty(\"_thousandSeparator\");\n\t\tconst decimalSeparator = language.translateEmpty(\"_decimalSeparator\")\n\n\t\t// init format parse info holder\n\t\tlet info: any = {\n\t\t\t\"positive\": {\n\t\t\t\t\"thousands\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"interval\": -1,\n\t\t\t\t\t\"separator\": thousandSeparator\n\t\t\t\t},\n\t\t\t\t\"decimals\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"separator\": decimalSeparator\n\t\t\t\t},\n\t\t\t\t\"template\": \"\",\n\t\t\t\t\"source\": \"\",\n\t\t\t\t\"parsed\": false\n\t\t\t},\n\t\t\t\"negative\": {\n\t\t\t\t\"thousands\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"interval\": -1,\n\t\t\t\t\t\"separator\": thousandSeparator\n\t\t\t\t},\n\t\t\t\t\"decimals\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"separator\": decimalSeparator\n\t\t\t\t},\n\t\t\t\t\"template\": \"\",\n\t\t\t\t\"source\": \"\",\n\t\t\t\t\"parsed\": false\n\t\t\t},\n\t\t\t\"zero\": {\n\t\t\t\t\"thousands\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"interval\": -1,\n\t\t\t\t\t\"separator\": thousandSeparator\n\t\t\t\t},\n\t\t\t\t\"decimals\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"separator\": decimalSeparator\n\t\t\t\t},\n\t\t\t\t\"template\": \"\",\n\t\t\t\t\"source\": \"\",\n\t\t\t\t\"parsed\": false\n\t\t\t}\n\t\t};\n\n\t\t// Escape double vertical bars (that mean display one vertical bar)\n\t\tformat = format.replace(\"||\", $type.PLACEHOLDER2);\n\n\t\t// Split it up and deal with different formats\n\t\tlet parts = format.split(\"|\");\n\t\tinfo.positive.source = parts[0];\n\n\t\tif (typeof parts[2] === \"undefined\") {\n\t\t\tinfo.zero = info.positive;\n\t\t}\n\t\telse {\n\t\t\tinfo.zero.source = parts[2];\n\t\t}\n\n\t\tif (typeof parts[1] === \"undefined\") {\n\t\t\tinfo.negative = info.positive;\n\t\t}\n\t\telse {\n\t\t\tinfo.negative.source = parts[1];\n\t\t}\n\n\t\t// Parse each\n\t\t$object.each(info, (_part, item) => {\n\t\t\t// Already parsed\n\t\t\tif (item.parsed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check cached\n\t\t\t// TODO\n\t\t\t// if (typeof this.getCache(item.source) !== \"undefined\") {\n\t\t\t// \tinfo[part] = this.getCache(item.source);\n\t\t\t// \treturn;\n\t\t\t// }\n\n\t\t\t// Begin parsing\n\t\t\tlet partFormat = item.source;\n\n\t\t\t// Just \"Number\"?\n\t\t\tif (partFormat.toLowerCase() === \"number\") {\n\t\t\t\tpartFormat = this.get(\"numberFormat\", \"#,###.#####\");\n\t\t\t}\n\n\t\t\t// Let TextFormatter split into chunks\n\t\t\tlet chunks = TextFormatter.chunk(partFormat, true);\n\t\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\t\tlet chunk = chunks[i];\n\n\t\t\t\t// replace back double vertical bar\n\t\t\t\tchunk.text = chunk.text.replace($type.PLACEHOLDER2, \"|\");\n\n\t\t\t\tif (chunk.type === \"value\") {\n\t\t\t\t\t// Parse format\n\n\t\t\t\t\t// Look for codes\n\t\t\t\t\tlet matches: string[] | null = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\n\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (matches === null || matches[0] === \"\") {\n\t\t\t\t\t\t\t// no codes here - assume string\n\t\t\t\t\t\t\t// nothing to do here\n\t\t\t\t\t\t\titem.template += chunk.text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t// look for the format modifiers at the end\n\t\t\t\t\t\t\tlet mods: string[] | null = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\n\n\t\t\t\t\t\t\tif (mods) {\n\t\t\t\t\t\t\t\titem.mod = mods[0].toLowerCase();\n\t\t\t\t\t\t\t\titem.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// break the format up\n\t\t\t\t\t\t\tlet a = matches[0].split(\".\");\n\n\t\t\t\t\t\t\t// Deal with thousands\n\t\t\t\t\t\t\tif (a[0] === \"\") {\n\t\t\t\t\t\t\t\t// No directives for thousands\n\t\t\t\t\t\t\t\t// Leave default settings (no formatting)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Counts\n\t\t\t\t\t\t\t\titem.thousands.active = (a[0].match(/0/g) || []).length;\n\t\t\t\t\t\t\t\titem.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\n\n\t\t\t\t\t\t\t\t// Separator interval\n\t\t\t\t\t\t\t\tlet b = a[0].split(\",\");\n\t\t\t\t\t\t\t\tif (b.length === 1) {\n\t\t\t\t\t\t\t\t\t// No thousands separators\n\t\t\t\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// Use length fo the last chunk as thousands length\n\t\t\t\t\t\t\t\t\titem.thousands.interval = (b.pop() || \"\").length;\n\n\t\t\t\t\t\t\t\t\tif (item.thousands.interval === 0) {\n\t\t\t\t\t\t\t\t\t\titem.thousands.interval = -1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Deal with decimals\n\t\t\t\t\t\t\tif (typeof (a[1]) === \"undefined\") {\n\t\t\t\t\t\t\t\t// No directives for decimals\n\t\t\t\t\t\t\t\t// Leave at defaults (no formatting)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Counts\n\t\t\t\t\t\t\t\titem.decimals.active = (a[1].match(/0/g) || []).length;\n\t\t\t\t\t\t\t\titem.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add special code to template\n\t\t\t\t\t\t\titem.template += chunk.text.split(matches[0]).join($type.PLACEHOLDER);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Quoted string - take it as it is\n\t\t\t\t\titem.template += chunk.text;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply style formatting\n\t\t\t//item.template = getTextFormatter().format(item.template, this.outputFormat);\n\n\t\t\t// Save cache\n\t\t\t// TODO\n\t\t\t//this.setCache(item.source, item);\n\n\t\t\t// Mark this as parsed\n\t\t\titem.parsed = true;\n\n\t\t});\n\n\t\t// Save cache (the whole thing)\n\t\t// TODO\n\t\t//this.setCache(format, info);\n\n\t\treturn info;\n\t}\n\n\t/**\n\t * Applies parsed format to a numeric value.\n\t *\n\t * @param value    Value\n\t * @param details  Parsed format as returned by parseFormat()\n\t * @return Formatted number\n\t * @ignore\n\t */\n\tprotected applyFormat(value: number, details: any): string {\n\n\t\t// Use absolute values\n\t\tlet negative: boolean = value < 0;\n\t\tvalue = Math.abs(value);\n\n\t\t// Recalculate according to modifier\n\t\tlet prefix: string = \"\", suffix: string = \"\";\n\t\tlet mods: string[] = details.mod ? details.mod.split(\"\") : [];\n\t\tif (mods.indexOf(\"b\") !== -1) {\n\t\t\tlet a = this.applyPrefix(value, this.get(\"bytePrefixes\")!, mods.indexOf(\"!\") !== -1);\n\t\t\tvalue = a[0];\n\t\t\tprefix = a[1];\n\t\t\tsuffix = a[2];\n\t\t\tif (details.modSpacing) {\n\t\t\t\tsuffix = \" \" + suffix;\n\t\t\t}\n\t\t}\n\t\telse if (mods.indexOf(\"a\") !== -1) {\n\t\t\tlet a = this.applyPrefix(value, value < this.get(\"smallNumberThreshold\")! ? this.get(\"smallNumberPrefixes\")! : this.get(\"bigNumberPrefixes\")!, mods.indexOf(\"!\") !== -1);\n\t\t\tvalue = a[0];\n\t\t\tprefix = a[1];\n\t\t\tsuffix = a[2];\n\t\t\tif (details.modSpacing) {\n\t\t\t\tsuffix = \" \" + suffix;\n\t\t\t}\n\t\t}\n\t\telse if (mods.indexOf(\"p\") !== -1) {\n\t\t\tlet ol = Math.min(value.toString().length + 2, 21);\n\t\t\t//value *= 100;\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\n\t\t\tprefix = this._root.language.translate(\"_percentPrefix\");\n\t\t\tsuffix = this._root.language.translate(\"_percentSuffix\");\n\t\t\tif (prefix == \"\" && suffix == \"\") {\n\t\t\t\tsuffix = \"%\";\n\t\t\t}\n\t\t}\n\t\telse if (mods.indexOf(\"%\") !== -1) {\n\t\t\tlet ol = Math.min(value.toString().length + 2, 21);\n\t\t\tvalue *= 100;\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\n\t\t\tsuffix = \"%\";\n\t\t}\n\t\telse if (mods.indexOf(\"‰\") !== -1) {\n\t\t\tlet ol = Math.min(value.toString().length + 3, 21);\n\t\t\tvalue *= 1000;\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\n\t\t\tsuffix = \"‰\";\n\t\t}\n\n\t\t// Round to passive\n\t\tif (mods.indexOf(\"e\") !== -1) {\n\t\t\t// convert the value to exponential\n\t\t\tlet exp: string[];\n\t\t\tif (details.decimals.passive >= 0) {\n\t\t\t\texp = value.toExponential(details.decimals.passive).split(\"e\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\texp = value.toExponential().split(\"e\");\n\t\t\t}\n\t\t\tvalue = Number(exp[0]);\n\t\t\tsuffix = \"e\" + exp[1];\n\t\t\tif (details.modSpacing) {\n\t\t\t\tsuffix = \" \" + suffix;\n\t\t\t}\n\t\t}\n\t\telse if (details.decimals.passive === 0) {\n\t\t\tvalue = Math.round(value);\n\t\t}\n\t\telse if (details.decimals.passive > 0) {\n\t\t\tlet d: number = Math.pow(10, details.decimals.passive);\n\t\t\tvalue = Math.round(value * d) / d;\n\t\t}\n\n\t\t// Init return value\n\t\tlet res: string = \"\";\n\n\t\t// Calc integer and decimal parts\n\t\tlet a = $type.numberToString(value).split(\".\");\n\n\t\t// Format integers\n\t\tlet ints = a[0];\n\n\t\t// Pad integers to active length\n\t\tif (ints.length < details.thousands.active) {\n\t\t\tints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n\t\t}\n\n\t\t// Insert thousands separators\n\t\tif (details.thousands.interval > 0) {\n\t\t\tlet ip: string[] = [];\n\t\t\tlet intsr: string = ints.split(\"\").reverse().join(\"\");\n\t\t\tfor (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n\t\t\t\tlet c: string = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\t\t\t\tif (c !== \"\") {\n\t\t\t\t\tip.unshift(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tints = ip.join(details.thousands.separator);\n\t\t}\n\n\t\t// Add integers\n\t\tres += ints;\n\n\t\t// Add decimals\n\t\tif (a.length === 1) {\n\t\t\ta.push(\"\");\n\t\t}\n\t\tlet decs: string = a[1];\n\n\t\t// Fill zeros?\n\t\tif (decs.length < details.decimals.active) {\n\t\t\tdecs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n\t\t}\n\n\t\tif (decs !== \"\") {\n\t\t\tres += details.decimals.separator + decs;\n\t\t}\n\n\t\t// Can't have empty return value\n\t\tif (res === \"\") {\n\t\t\tres = \"0\";\n\t\t}\n\n\t\t// Add minus sign back\n\t\tif (value !== 0 && negative && (mods.indexOf(\"s\") === -1)) {\n\t\t\tres = \"-\" + res;\n\t\t}\n\n\t\t// Add suffixes/prefixes\n\t\tif (prefix) {\n\t\t\tres = prefix + res;\n\t\t}\n\t\tif (suffix) {\n\t\t\tres += suffix;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\n\tprotected applyPrefix(value: number, prefixes: any[], force: boolean = false): any[] {\n\t\tlet newvalue = value;\n\t\tlet prefix = \"\";\n\t\tlet suffix = \"\";\n\t\tlet applied = false;\n\t\tlet k = 1;\n\n\t\tfor (let i = 0, len = prefixes.length; i < len; i++) {\n\t\t\tif (prefixes[i].number <= value) {\n\t\t\t\tif (prefixes[i].number === 0) {\n\t\t\t\t\tnewvalue = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewvalue = value / prefixes[i].number;\n\t\t\t\t\tk = prefixes[i].number;\n\t\t\t\t}\n\t\t\t\tprefix = prefixes[i].prefix;\n\t\t\t\tsuffix = prefixes[i].suffix;\n\t\t\t\tapplied = true;\n\t\t\t}\n\t\t}\n\n\n\t\tif (!applied && force && prefixes.length && value != 0) {\n\t\t\t// Prefix was not applied. Use the first prefix.\n\t\t\tnewvalue = value / prefixes[0].number;\n\t\t\tprefix = prefixes[0].prefix;\n\t\t\tsuffix = prefixes[0].suffix;\n\t\t\tapplied = true;\n\t\t}\n\n\t\tif (applied) {\n\t\t\tnewvalue = parseFloat(\n\t\t\t\tnewvalue.toPrecision(\n\t\t\t\t\tMath.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn [newvalue, prefix, suffix];\n\t}\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic escape(text: string): string {\n\t\treturn text.replace(\"||\", $type.PLACEHOLDER2);\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic unescape(text: string): string {\n\t\treturn text.replace($type.PLACEHOLDER2, \"|\");\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}