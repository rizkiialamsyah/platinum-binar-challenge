{"ast":null,"code":"/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Disposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\nexport class EventDispatcher {\n  /**\r\n   * Constructor\r\n   */\n  constructor() {\n    Object.defineProperty(this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_killed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_iterating\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_enabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      const a = this._listeners;\n      this._iterating = 1;\n      this._listeners = null;\n      this._disabled = null;\n      try {\n        $array.each(a, x => {\n          x.disposer.dispose();\n        });\n      } finally {\n        this._killed = null;\n        this._iterating = null;\n      }\n    }\n  }\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n  hasListeners() {\n    return this._listeners.length !== 0;\n  }\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n  hasListenersByType(type) {\n    return $array.any(this._listeners, x => (x.type === null || x.type === type) && !x.killed);\n  }\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n  enable() {\n    this._enabled = true;\n  }\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n  disable() {\n    this._enabled = false;\n  }\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n  enableType(type) {\n    delete this._disabled[type];\n  }\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n  disableType(type) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n    this._disabled[type] = amount;\n  }\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n  _removeListener(listener) {\n    if (this._iterating === 0) {\n      const index = this._listeners.indexOf(listener);\n      if (index === -1) {\n        throw new Error(\"Invalid state: could not remove listener\");\n      }\n      this._listeners.splice(index, 1);\n    } else {\n      this._killed.push(listener);\n    }\n  }\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n  _removeExistingListener(once, type, callback, context) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    this._eachListener(info => {\n      if (info.once === once &&\n      // TODO is this correct ?\n      info.type === type && (callback === undefined || info.callback === callback) && info.context === context) {\n        info.disposer.dispose();\n      }\n    });\n  }\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n  isEnabled(type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    // TODO is this check correct ?\n    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n  }\n  /**\r\n   * Removes all listeners of a particular event type\r\n   *\r\n   * @param type  Listener's type\r\n   */\n  removeType(type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    this._eachListener(info => {\n      if (info.type === type) {\n        info.disposer.dispose();\n      }\n    });\n  }\n  /**\r\n   * Checks if there's already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener's type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n  has(type, callback, context) {\n    const index = $array.findIndex(this._listeners, info => {\n      return info.once !== true &&\n      // Ignoring \"once\" listeners\n      info.type === type && (callback === undefined || info.callback === callback) && info.context === context;\n    });\n    return index !== -1;\n  }\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n  _shouldDispatch(type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    const count = this._disabled[type];\n    if (!$type.isNumber(count)) {\n      return this._enabled;\n    } else {\n      if (count <= 1) {\n        delete this._disabled[type];\n      } else {\n        --this._disabled[type];\n      }\n      return false;\n    }\n  }\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n  _eachListener(fn) {\n    ++this._iterating;\n    try {\n      $array.each(this._listeners, fn);\n    } finally {\n      --this._iterating;\n      // TODO should this be inside or outside the finally ?\n      if (this._iterating === 0 && this._killed.length !== 0) {\n        // Remove killed listeners\n        $array.each(this._killed, killed => {\n          this._removeListener(killed);\n        });\n        this._killed.length = 0;\n      }\n    }\n  }\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n  dispatch(type, event) {\n    if (this._shouldDispatch(type)) {\n      // TODO check if it's faster to use an object of listeners rather than a single big array\n      // TODO if the function throws, maybe it should keep going ?\n      this._eachListener(listener => {\n        if (!listener.killed && (listener.type === null || listener.type === type)) {\n          listener.dispatch(type, event);\n        }\n      });\n    }\n  }\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n      if (this._shouldDispatch(type)) {\r\n          this._eachListener((listener) => {\r\n              // TODO check if it's faster to use an object of listeners rather than a single big array\r\n              if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                  // TODO if the function throws, maybe it should keep going ?\r\n                  // TODO dispatch during the update cycle, rather than using whenIdle\r\n                  $async.whenIdle(() => {\r\n                      if (!listener.killed) {\r\n                          listener.dispatch(type, event);\r\n                      }\r\n                  });\r\n              }\r\n          });\r\n      }\r\n  }*/\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n  _on(once, type, callback, context, shouldClone, dispatch) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    this._removeExistingListener(once, type, callback, context);\n    const info = {\n      type: type,\n      callback: callback,\n      context: context,\n      shouldClone: shouldClone,\n      dispatch: dispatch,\n      killed: false,\n      once: once,\n      disposer: new Disposer(() => {\n        info.killed = true;\n        this._removeListener(info);\n      })\n    };\n    this._listeners.push(info);\n    return info;\n  }\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n  onAll(callback, context) {\n    let shouldClone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this._on(false, null, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n  }\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n  on(type, callback, context) {\n    let shouldClone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n  }\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n  once(type, callback, context) {\n    let shouldClone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const x = this._on(true, type, callback, context, shouldClone, (_type, event) => {\n      x.disposer.dispose();\n      callback.call(context, event);\n    });\n    // TODO maybe this should return a different Disposer ?\n    return x.disposer;\n  }\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n  off(type, callback, context) {\n    this._removeExistingListener(false, type, callback, context);\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n  copyFrom(source) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    if (source === this) {\n      throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n    }\n    const disposers = [];\n    $array.each(source._listeners, x => {\n      // TODO is this correct ?\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          disposers.push(this.onAll(x.callback, x.context));\n        } else if (x.once) {\n          disposers.push(this.once(x.type, x.callback, x.context));\n        } else {\n          disposers.push(this.on(x.type, x.callback, x.context));\n        }\n      }\n    });\n    return new MultiDisposer(disposers);\n  }\n}\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @ignore\r\n */\nexport class TargetedEventDispatcher extends EventDispatcher {\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n  constructor(target) {\n    super();\n    /**\r\n     * A target object which is originating events using this dispatcher.\r\n     */\n    Object.defineProperty(this, \"target\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.target = target;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n  copyFrom(source) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n    if (source === this) {\n      throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n    }\n    const disposers = [];\n    $array.each(source._listeners, x => {\n      // TODO very hacky\n      if (x.context === source.target) {\n        return;\n      }\n      // TODO is this correct ?\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          disposers.push(this.onAll(x.callback, x.context));\n        } else if (x.once) {\n          disposers.push(this.once(x.type, x.callback, x.context));\n        } else {\n          disposers.push(this.on(x.type, x.callback, x.context));\n        }\n      }\n    });\n    return new MultiDisposer(disposers);\n  }\n}","map":{"version":3,"names":["Disposer","MultiDisposer","$array","$type","EventDispatcher","constructor","Object","defineProperty","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","isDisposed","dispose","a","each","x","disposer","hasListeners","length","hasListenersByType","type","any","killed","enable","disable","enableType","disableType","amount","arguments","undefined","Infinity","_removeListener","listener","index","indexOf","Error","splice","push","_removeExistingListener","once","callback","context","_eachListener","info","isEnabled","removeType","has","findIndex","_shouldDispatch","count","isNumber","fn","dispatch","event","_on","shouldClone","onAll","_type","call","on","off","copyFrom","source","disposers","TargetedEventDispatcher","target"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\util\\EventDispatcher.ts"],"sourcesContent":["/**\n * Event Dispatcher module is used for registering listeners and dispatching\n * events across amCharts system.\n */\n\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { Disposer, IDisposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n\n/**\n * @ignore\n */\nexport type Events<Target, T> = {\n\t[K in keyof T]: T[K] & { type: K, target: Target }\n};\n\n/**\n * A universal interface for event listeners.\n *\n * @ignore\n */\nexport interface EventListener {\n\tkilled: boolean;\n\tonce: boolean;\n\ttype: any | null;\n\tcallback: (event: any) => void;\n\tcontext: unknown;\n\tshouldClone: boolean;\n\tdispatch: (type: any, event: any) => void;\n\tdisposer: IDisposer;\n}\n\n/**\n * Universal Event Dispatcher.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\n */\nexport class EventDispatcher<T> implements IDisposer {\n\tprotected _listeners: Array<EventListener>;\n\tprotected _killed: Array<EventListener>;\n\tprotected _disabled: { [key in keyof T]?: number };\n\tprotected _iterating: number;\n\tprotected _enabled: boolean;\n\tprotected _disposed: boolean;\n\n\n\t/**\n\t * Constructor\n\t */\n\tconstructor() {\n\t\tthis._listeners = [];\n\t\tthis._killed = [];\n\t\tthis._disabled = {};\n\t\tthis._iterating = 0;\n\t\tthis._enabled = true;\n\t\tthis._disposed = false;\n\t}\n\n\t/**\n\t * Returns if this object has been already disposed.\n\t *\n\t * @return Disposed?\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Dispose (destroy) this object.\n\t */\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\tconst a = this._listeners;\n\n\t\t\tthis._iterating = 1;\n\t\t\tthis._listeners = <any>null;\n\t\t\tthis._disabled = <any>null;\n\n\t\t\ttry {\n\t\t\t\t$array.each(a, (x) => {\n\t\t\t\t\tx.disposer.dispose();\n\t\t\t\t});\n\n\t\t\t} finally {\n\t\t\t\tthis._killed = <any>null;\n\t\t\t\tthis._iterating = <any>null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any listeners set.\n\t *\n\t * @return Has listeners?\n\t */\n\tpublic hasListeners(): boolean {\n\t\treturn this._listeners.length !== 0;\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any particular listeners set.\n\t *\n\t * @return Has particular event listeners?\n\t */\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\n\t}\n\n\t/**\n\t * Enable dispatching of events if they were previously disabled by\n\t * `disable()`.\n\t */\n\tpublic enable(): void {\n\t\tthis._enabled = true;\n\t}\n\n\t/**\n\t * Disable dispatching of events until re-enabled by `enable()`.\n\t */\n\tpublic disable(): void {\n\t\tthis._enabled = false;\n\t}\n\n\t/**\n\t * Enable dispatching particular event, if it was disabled before by\n\t * `disableType()`.\n\t *\n\t * @param type Event type\n\t */\n\tpublic enableType<Key extends keyof T>(type: Key): void {\n\t\tdelete this._disabled[type];\n\t}\n\n\t/**\n\t * Disable dispatching of events for a certain event type.\n\t *\n\t * Optionally, can set how many dispatches to skip before automatically\n\t * re-enabling the dispatching.\n\t *\n\t * @param type    Event type\n\t * @param amount  Number of event dispatches to skip\n\t */\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\n\t\tthis._disabled[type] = amount;\n\t}\n\n\t/**\n\t * Removes listener from dispatcher.\n\t *\n\t * Will throw an exception if such listener does not exists.\n\t *\n\t * @param listener Listener to remove\n\t */\n\tprotected _removeListener(listener: EventListener): void {\n\t\tif (this._iterating === 0) {\n\t\t\tconst index = this._listeners.indexOf(listener);\n\n\t\t\tif (index === -1) {\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\n\t\t\t}\n\n\t\t\tthis._listeners.splice(index, 1);\n\n\t\t} else {\n\t\t\tthis._killed.push(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Removes existing listener by certain parameters.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tprotected _removeExistingListener<C, Key extends keyof T>(once: boolean, type: Key | null, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.once === once && // TODO is this correct ?\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if dispatching for particular event type is enabled.\n\t *\n\t * @param type  Event type\n\t * @return Enabled?\n\t */\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\t// TODO is this check correct ?\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n\t}\n\n\t/**\n\t * Removes all listeners of a particular event type\n\t *\n\t * @param type  Listener's type\n\t */\n\tpublic removeType<Key extends keyof T>(type: Key): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.type === type) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if there's already a listener with specific parameters.\n\t *\n\t * @param type      Listener's type\n\t * @param callback  Callback function\n\t * @param context   Callback context\n\t * @return Has listener?\n\t */\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context;\n\t\t});\n\n\t\treturn index !== -1;\n\t}\n\n\t/**\n\t * Checks whether event of the particular type should be dispatched.\n\t *\n\t * @param type  Event type\n\t * @return Dispatch?\n\t */\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tconst count = this._disabled[type];\n\n\t\tif (!$type.isNumber(count)) {\n\t\t\treturn this._enabled;\n\n\t\t} else {\n\t\t\tif (count <= 1) {\n\t\t\t\tdelete this._disabled[type];\n\n\t\t\t} else {\n\t\t\t\t--this._disabled[type]!;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * [_eachListener description]\n\t *\n\t * All of this extra code is needed when a listener is removed while iterating\n\t *\n\t * @todo Description\n\t * @param fn [description]\n\t */\n\tprotected _eachListener(fn: (listener: EventListener) => void): void {\n\t\t++this._iterating;\n\n\t\ttry {\n\t\t\t$array.each(this._listeners, fn);\n\n\t\t} finally {\n\t\t\t--this._iterating;\n\n\t\t\t// TODO should this be inside or outside the finally ?\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\n\t\t\t\t// Remove killed listeners\n\t\t\t\t$array.each(this._killed, (killed) => {\n\t\t\t\t\tthis._removeListener(killed);\n\t\t\t\t});\n\n\t\t\t\tthis._killed.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Dispatches an event immediately without waiting for next cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Shelves the event to be dispatched within next update cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\t/*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\n\t\t\t\t\t$async.whenIdle(() => {\n\t\t\t\t\t\tif (!listener.killed) {\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}*/\n\n\t/**\n\t * Creates, catalogs and returns an [[EventListener]].\n\t *\n\t * Event listener can be disposed.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @param dispatch\n\t * @returns An event listener\n\t */\n\tprotected _on<C, Key extends keyof T>(once: boolean, type: Key | null, callback: any, context: C, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._removeExistingListener(once, type, callback, context);\n\n\t\tconst info: EventListener = {\n\t\t\ttype: type,\n\t\t\tcallback: callback,\n\t\t\tcontext: context,\n\t\t\tshouldClone: shouldClone,\n\t\t\tdispatch: <any>dispatch,\n\t\t\tkilled: false,\n\t\t\tonce: once,\n\t\t\tdisposer: new Disposer(() => {\n\t\t\t\tinfo.killed = true;\n\t\t\t\tthis._removeListener(info);\n\t\t\t})\n\t\t};\n\n\t\tthis._listeners.push(info);\n\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on **any** event.\n\t *\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic onAll<C, K extends keyof T>(callback: (this: C, event: T[K]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, null, callback, context, shouldClone, (_type, event) => (<any>callback).call(context, event as any)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler whenever series we put\n\t * event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type once.\n\t *\n\t * Once the event listener is invoked, it is automatically disposed.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler the first time series we\n\t * put event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (_type, event) => {\n\t\t\tx.disposer.dispose();\n\t\t\tcallback.call(context, event)\n\t\t});\n\n\t\t// TODO maybe this should return a different Disposer ?\n\t\treturn x.disposer;\n\t}\n\n\t/**\n\t * Removes the event listener with specific parameters.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tthis._removeExistingListener(false, type, callback, context);\n\t}\n\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n\n/**\n * A version of the [[EventDispatcher]] that dispatches events for a specific\n * target object.\n *\n * @ignore\n */\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\n\n\t/**\n\t * A target object which is originating events using this dispatcher.\n\t */\n\tpublic target: Target;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param target Event dispatcher target\n\t */\n\tconstructor(target: Target) {\n\t\tsuper();\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO very hacky\n\t\t\tif (x.context === source.target) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}