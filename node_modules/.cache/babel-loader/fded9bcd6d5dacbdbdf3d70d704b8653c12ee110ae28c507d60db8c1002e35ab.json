{"ast":null,"code":"/** @ignore */ /** */\nimport * as $math from \"./Math\";\n/**\r\n * @ignore\r\n */\nexport function segmentedLine(display, segments) {\n  for (let s = 0, len = segments.length; s < len; s++) {\n    const groups = segments[s];\n    if (groups.length > 0) {\n      let firstGroup = groups[0];\n      if (firstGroup.length > 0) {\n        let firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n        for (let g = 0, len = groups.length; g < len; g++) {\n          line(display, groups[g]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport function line(display, points) {\n  for (let p = 0, len = points.length; p < len; p++) {\n    const point = points[p];\n    display.lineTo(point.x, point.y);\n  }\n}\n/**\r\n * @ignore\r\n */\nexport function moveTo(display, point) {\n  display.moveTo(point.x, point.y);\n}\n/**\r\n * @ignore\r\n */\nexport function clear(display) {\n  display.clear();\n}\n/**\r\n * @ignore\r\n */\nexport function smoothedSegmentedline(display, segments, tensionX, tensionY) {\n  for (let s = 0, len = segments.length; s < len; s++) {\n    const groups = segments[s];\n    if (groups.length > 0) {\n      let firstGroup = groups[0];\n      if (firstGroup.length > 0) {\n        let firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n        for (let g = 0, len = groups.length; g < len; g++) {\n          const points = groups[g];\n          if (points.length > 0) {\n            display.lineTo(points[0].x, points[0].y);\n          }\n          smoothedLine(display, points, tensionX, tensionY);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport function smoothedLine(display, points, tensionX, tensionY) {\n  for (let i = points.length - 1; i > 0; i--) {\n    let p0 = points[i];\n    let p1 = points[i - 1];\n    if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n      points.splice(i - 1, 1);\n    }\n  }\n  if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n    line(display, points);\n    return;\n  }\n  tensionX = 1 - tensionX + 0.00001;\n  tensionY = 1 - tensionY + 0.00001;\n  let first = points[0];\n  let last = points[points.length - 1];\n  let closed = false;\n  if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n    closed = true;\n  }\n  // Can't moveTo here, as it wont be possible to have fill then.\n  let path = \"\";\n  for (let i = 0, len = points.length - 1; i < len; i++) {\n    let p0 = points[i - 1];\n    let p1 = points[i];\n    let p2 = points[i + 1];\n    let p3 = points[i + 2];\n    if (i === 0) {\n      if (closed) {\n        p0 = points[len - 2];\n      } else {\n        p0 = points[0];\n      }\n    } else if (i == len - 1) {\n      if (closed) {\n        p3 = points[1];\n      } else {\n        p3 = p2;\n      }\n    }\n    let controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n    let controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n    display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n  }\n  return path;\n}","map":{"version":3,"names":["$math","segmentedLine","display","segments","s","len","length","groups","firstGroup","firstPoint","moveTo","x","y","g","line","points","p","point","lineTo","clear","smoothedSegmentedline","tensionX","tensionY","smoothedLine","i","p0","p1","Math","abs","splice","first","last","closed","round","path","p2","p3","controlPointA","getCubicControlPointA","controlPointB","getCubicControlPointB","bezierCurveTo"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\util\\Draw.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport type { IPoint } from \"./IPoint\"\nimport * as $math from \"./Math\";\nimport type { IGraphics } from \"../render/backend/Renderer\";\n\n/**\n * @ignore\n */\nexport function segmentedLine(display: IGraphics, segments: Array<Array<Array<IPoint>>>) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tline(display, groups[g]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function line(display: IGraphics, points: Array<IPoint>) {\n\tfor (let p = 0, len = points.length; p < len; p++) {\n\t\tconst point = points[p];\n\t\tdisplay.lineTo(point.x, point.y);\n\t}\n}\n\n/**\n * @ignore\n */\nexport function moveTo(display: IGraphics, point: IPoint) {\n\tdisplay.moveTo(point.x, point.y);\n}\n\n/**\n * @ignore\n */\nexport function clear(display: IGraphics) {\n\tdisplay.clear();\n}\n\n/**\n * @ignore\n */\nexport function smoothedSegmentedline(display: IGraphics, segments: Array<Array<Array<IPoint>>>, tensionX: number, tensionY: number) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tconst points = groups[g];\n\t\t\t\t\tif (points.length > 0) {\n\t\t\t\t\t\tdisplay.lineTo(points[0].x, points[0].y)\n\t\t\t\t\t}\n\t\t\t\t\tsmoothedLine(display, points, tensionX, tensionY);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function smoothedLine(display: IGraphics, points: Array<IPoint>, tensionX: number, tensionY: number) {\n\n\tfor (let i = points.length - 1; i > 0; i--) {\n\t\tlet p0 = points[i];\n\t\tlet p1 = points[i - 1];\n\n\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\tpoints.splice(i - 1, 1);\n\t\t}\n\t}\n\n\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\tline(display, points);\n\t\treturn;\n\t}\n\n\ttensionX = 1 - tensionX + 0.00001;\n\ttensionY = 1 - tensionY + 0.00001;\n\n\tlet first = points[0];\n\tlet last = points[points.length - 1];\n\n\tlet closed: boolean = false;\n\n\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\tclosed = true;\n\t}\n\n\t// Can't moveTo here, as it wont be possible to have fill then.\n\tlet path: string = \"\";\n\n\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\tlet p0: IPoint = points[i - 1];\n\n\t\tlet p1: IPoint = points[i];\n\n\t\tlet p2: IPoint = points[i + 1];\n\n\t\tlet p3: IPoint = points[i + 2];\n\n\t\tif (i === 0) {\n\t\t\tif (closed) {\n\t\t\t\tp0 = points[len - 2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp0 = points[0];\n\t\t\t}\n\t\t} else if (i == len - 1) {\n\t\t\tif (closed) {\n\t\t\t\tp3 = points[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp3 = p2;\n\t\t\t}\n\t\t}\n\n\n\t\tlet controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n\t\tlet controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n\n\t\tdisplay.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n\t}\n\n\treturn path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}