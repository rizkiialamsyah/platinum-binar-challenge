{"ast":null,"code":"import { Color } from \"./Color\";\nimport * as $type from \"./Type\";\nexport class TextFormatter {\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  static escape(text) {\n    return text.replace(/\\[\\[/g, this.prefix + \"1\").replace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").replace(/\\]\\]/g, this.prefix + \"2\").replace(/\\{\\{/g, this.prefix + \"3\").replace(/\\}\\}/g, this.prefix + \"4\").replace(/\\'\\'/g, this.prefix + \"5\");\n  }\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  static unescape(text) {\n    return text.replace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").replace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").replace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").replace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").replace(new RegExp(this.prefix + \"5\", \"g\"), \"''\");\n  }\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n  static cleanUp(text) {\n    return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n  }\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n  static chunk(text) {\n    let quotedBlocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let noFormatting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // Init result\n    let res = [];\n    // Replace double (escaped) square spaces and quotes with temporary codes\n    text = this.escape(text);\n    // Deal with style blocks\n    let chunks = quotedBlocks ? text.split(\"'\") : [text];\n    for (let i = 0; i < chunks.length; i++) {\n      let chunk = chunks[i];\n      // Empty?\n      if (chunk === \"\") {\n        continue;\n      }\n      if (i % 2 === 0) {\n        // Text outside quotes\n        // Parse for style blocks which are \"text\" chunks, the rest chunks are\n        // \"value\"\n        chunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n        chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n        let chunks2 = chunk.split(/[\\[\\]]+/);\n        for (let i2 = 0; i2 < chunks2.length; i2++) {\n          let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Placeholder?\n          if (chunk2 === $type.PLACEHOLDER) {\n            continue;\n          }\n          // Empty?\n          if (chunk2 === \"\") {\n            continue;\n          }\n          // Block or value\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"value\",\n              \"text\": chunk2\n            });\n          } else {\n            res.push({\n              \"type\": noFormatting ? \"value\" : \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      } else {\n        // A text within doublequotes\n        // All chunks are \"text\"\n        let chunks2 = chunk.split(/[\\[\\]]+/);\n        for (let i2 = 0; i2 < chunks2.length; i2++) {\n          let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Empty?\n          if (chunk2 === \"\") {\n            continue;\n          }\n          // Block or text\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"text\",\n              \"text\": chunk2\n            });\n          } else if (this.isImage(chunk2)) {\n            res.push({\n              \"type\": \"image\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          } else {\n            res.push({\n              \"type\": \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      }\n    }\n    return res;\n  }\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore\r\n   * @param  text  Format\r\n   * @return true if it is an image\r\n   */\n  static isImage(text) {\n    return text.match(/img[ ]?:/) ? true : false;\n  }\n  static getTextStyle(style) {\n    // let textStyle: string[] = [];\n    // let textFill: string | undefined;\n    let format = {};\n    if (style == \"\" || style == \"[ ]\") {\n      return {};\n    }\n    // Pre-process quoted text\n    const q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n    if (q) {\n      for (let i = 0; i < q.length; i++) {\n        style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n      }\n    }\n    // Get style parts\n    let b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w\\-]+)|(\\/)/gi);\n    // Empty?\n    if (!b) {\n      return {};\n    }\n    // Check each part\n    for (let i = 0; i < b.length; i++) {\n      if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n        format.fontWeight = b[i];\n      } else if (b[i].match(/^(underline|line-through)$/i)) {\n        format.textDecoration = b[i];\n      } else if (b[i] == \"/\") {\n        // Just closing tag\n        // Do nothing\n      } else if (!b[i].match(/:/)) {\n        // Color\n        format.fill = Color.fromString(b[i]);\n      } else {\n        const p = b[i].replace(\"+\", \" \").split(/:[ ]*/);\n        format[p[0]] = p[1];\n        //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n        //b[i] = b[i].replace(/\\+/g, \" \");\n      }\n    }\n\n    return format;\n  }\n}\nObject.defineProperty(TextFormatter, \"prefix\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: \"__amcharts__\"\n});","map":{"version":3,"names":["Color","$type","TextFormatter","escape","text","replace","prefix","unescape","RegExp","cleanUp","chunk","quotedBlocks","arguments","length","undefined","noFormatting","res","chunks","split","i","PLACEHOLDER","chunks2","i2","chunk2","push","isImage","match","getTextStyle","style","format","q","b","fontWeight","textDecoration","fill","fromString","p","Object","defineProperty"],"sources":["C:\\Users\\Rizki\\binar-course\\cms-binar-platinum\\node_modules\\src\\.internal\\core\\util\\TextFormatter.ts"],"sourcesContent":["import { Color } from \"./Color\"\nimport type { ITextStyle } from \"../render/backend/Renderer\"\nimport * as $type from \"./Type\";\n\n/**\n * Defines an interface for an object that holds a chunk of text.\n */\nexport interface ITextChunk {\n\n\t/**\n\t * Type of the chunk.\n\t */\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\n\n\t/**\n\t * Text.\n\t */\n\t\"text\": string\n\n}\n\nexport class TextFormatter {\n\n\tpublic static prefix = \"__amcharts__\";\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic static escape(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, this.prefix + \"1\").\n\t\t\treplace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").\n\t\t\treplace(/\\]\\]/g, this.prefix + \"2\").\n\t\t\treplace(/\\{\\{/g, this.prefix + \"3\").\n\t\t\treplace(/\\}\\}/g, this.prefix + \"4\").\n\t\t\treplace(/\\'\\'/g, this.prefix + \"5\");\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic static unescape(text: string): string {\n\t\treturn text.\n\t\t\treplace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").\n\t\t\treplace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").\n\t\t\treplace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").\n\t\t\treplace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").\n\t\t\treplace(new RegExp(this.prefix + \"5\", \"g\"), \"''\");\n\t}\n\n\t/**\n\t * Cleans up the text text for leftover double square brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Cleaned up text\n\t */\n\tpublic static cleanUp(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, \"[\").\n\t\t\treplace(/\\]\\]/g, \"]\").\n\t\t\treplace(/\\{\\{/g, \"{\").\n\t\t\treplace(/\\}\\}/g, \"}\").\n\t\t\treplace(/\\'\\'/g, \"'\");\n\t}\n\n\t/**\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\n\t *\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\n\t * also single out text blocks enclosed within single quotes that no\n\t * formatting should be applied to, and they should be displayed as is.\n\t *\n\t * Default for the above is `false`, so that you can use single quote in text\n\t * without escaping it.\n\t *\n\t * If enabled, single quotes can be escaped by doubling it - adding two\n\t * single quotes, which will be replaced by a one single quote in the final\n\t * output.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text          Text to chunk\n\t * @param quotedBlocks  Use quoted blocks\n\t * @param noFormatting  Formatting blocks will be treated as regular text\n\t * @return Array of string chunks\n\t */\n\tpublic static chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\n\n\t\t// Init result\n\t\tlet res: ITextChunk[] = [];\n\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\n\t\ttext = this.escape(text);\n\n\t\t// Deal with style blocks\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\tlet chunk = chunks[i];\n\n\t\t\t// Empty?\n\t\t\tif (chunk === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((i % 2) === 0) {\n\n\t\t\t\t// Text outside quotes\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\n\t\t\t\t// \"value\"\n\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Placeholder?\n\t\t\t\t\tif (chunk2 === $type.PLACEHOLDER) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or value\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"value\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// A text within doublequotes\n\t\t\t\t// All chunks are \"text\"\n\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or text\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isImage(chunk2)) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Checks if supplied format contains image information and should be\n\t * formatted as such.\n\t * I.e.: `[img: myImage.png]`\n\t *\n\t * @ignore\n\t * @param  text  Format\n\t * @return true if it is an image\n\t */\n\tpublic static isImage(text: string): boolean {\n\t\treturn text.match(/img[ ]?:/) ? true : false;\n\t}\n\n\tpublic static getTextStyle(style: string): ITextStyle {\n\n\t\t// let textStyle: string[] = [];\n\t\t// let textFill: string | undefined;\n\t\tlet format: ITextStyle = {};\n\n\t\tif (style == \"\" || style == \"[ ]\") {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Pre-process quoted text\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\t\tif (q) {\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n\t\t\t}\n\t\t}\n\n\t\t// Get style parts\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w\\-]+)|(\\/)/gi);\n\n\t\t// Empty?\n\t\tif (!b) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check each part\n\t\tfor (let i: number = 0; i < b.length; i++) {\n\n\t\t\tif (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n\t\t\t\t(<any>format).fontWeight = b[i];\n\t\t\t}\n\t\t\telse if (b[i].match(/^(underline|line-through)$/i)) {\n\t\t\t\t(<any>format).textDecoration = b[i];\n\t\t\t}\n\t\t\telse if (b[i] == \"/\") {\n\t\t\t\t// Just closing tag\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if (!b[i].match(/:/)) {\n\t\t\t\t// Color\n\t\t\t\tformat.fill = Color.fromString(b[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst p = b[i].replace(\"+\", \" \").split(/:[ ]*/);\n\t\t\t\t(<any>format)[p[0]] = p[1];\n\t\t\t\t//textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n\t\t\t\t//b[i] = b[i].replace(/\\+/g, \" \");\n\t\t\t}\n\n\t\t}\n\n\t\treturn format;\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}